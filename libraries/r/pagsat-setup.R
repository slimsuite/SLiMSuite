########################################################
### PAGSAT Setup Script                        ~~~~~ ###
### VERSION: 2.0.0                             ~~~~~ ###
### LAST EDIT: 03/10/16                        ~~~~~ ###
### AUTHORS: Richard Edwards 2016              ~~~~~ ###
### CONTACT: richard.edwards@unsw.edu.au       ~~~~~ ###
########################################################

################# ::: HISTORY ::: ######################
# v2.0.0 : Major overhaul to work with PAGSAT v2.0.0.

############### ::: GENERAL SETUP ::: ##################
#i# This is called from the main pagsat.R script.
#i# It has been partitioned off to enable the main data to be loaded independently of function called.
#i# This in turn should make development easier.
#i# Prior to running, rje.r must have been run to set up general colours (rje_col) and functions (rje_misc)
#i# arglist has been setup by rje.r already. 

## ~ Read commandline arguments ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
rtype = arglist$rtype        # arglist is generated by rje.r
basefile = arglist$basefile  # arglist is generated by rje.r
print(basefile)
refbase = arglist$refbase
print(refbase)
assbase = arglist$assbase
print(assbase)

## ~ Set up global parameters and file names ~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
settings = list(basefile=basefile)   # Access with settings[["basefile"]] or settings$basefile
settings$refbase = refbase 
settings$assbase = arglist$assbase 
settings$assessment = TRUE # Process outputs from assessment run
settings$covplot = TRUE    # Whether to generate chromosome and contig coverage plots.
settings$diploid = TRUE    # Whether to run ChromAlignLoc in diploid mode.
settings$genesummary = FALSE    # Whether to run GeneSummary plot.
settings$protsummary = FALSE    # Whether to run ProtSummary plot.
settings$chromalign = FALSE    # Whether to run ChromAlign plot.
settings$features = TRUE    # Whether to expect Features table plot.
settings$pngwidth = 2400
settings$pngheight = 1600
settings$pointsize = 36
settings$minloclen = 250
settings$topcontigs = 10        # Number of contigs to display as local alignment matches
#!# May not use topcontigprop
settings$topcontigprop = 0.33  # Min proportion of contig that must match chromosome for local alignment
settings$units = "kb"
settings$plotft = c("gene","mRNA","CDS","rRNA","tRNA","ncRNA","mobile","LTR","origin","centromere","telomere")

## ~ Update default settings from commandline arguments (setting=value) ~~~~~ ##
(arglist)  # This contains settings read in from arguments
arglist = argBool(arglist,c("assessment","covplot","diploid","genesummary","protsummary","chromalign"))    # List of Boolean settings
arglist = argNum(arglist,c("pngwidth","pngheight","pointsize","minloclen","topcontigs"))     # List of numeric settings
arglist = argList(arglist,c("plotft"))
for(cmd in names(arglist)){
  settings[[cmd]] = arglist[[cmd]]  # Need to add processing of booleans etc.
}
(settings)  # This contains settings read in from arguments

## ~ Setup base filenames for inputs and outputs ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
settings$basename = strsplit(basefile,'/')[[1]]
settings$gablamdir = paste0(settings$basename[1:length(settings$basename)-1],collapse="/")
settings$gablamdir = strsplit(settings$gablamdir,'[.]')[[1]]
(settings$gablamdir = paste0(c(settings$gablamdir[1:length(settings$gablamdir)-1],'GABLAM/'),collapse="."))
(settings$basename = settings$basename[length(settings$basename)])
(settings$pngbase = paste(basefile,".Plots/",settings$basename,sep=""))
if(file.exists(paste(basefile,".Plots/",sep=""))==FALSE){
  dir.create(paste(basefile,".Plots/",sep=""))
}

## ~ Setup scaling and units ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
settings$scaling = 1
if(settings$units == "kb"){
  settings$scaling = 1000
}
if(settings$units == "Mb"){
  settings$scaling = 1e6
}

## ~ Setup colour profile ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
settings$col = list()   # This will have contigs and chromosomes added later.
# Setup feature colour scheme
for(fi in 1:length(settings$plotft)){
  settings$col[[settings$plotft[fi]]] = soton$col[fi+1]
}
settings$col[["LTR"]] = soton$col[15]
settings$col[["mobile"]] = soton$col[16]

(settings)  # This contains final settings

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##

####################### ::: LOAD AND TIDY DATA ::: ##########################

### ~ Sequence information table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#i# These data come from Sequences.tdt and are now all *seqdb data frames.
#># Locus,Name,Chrom,MapChrom,MapUniq,MapDirn,Spec,Source,Desc,HitNum,MaxScore,EVal,Length,Coverage,Identity,Positives,Missing,Errors,Perfect[,Col]
#i# Should rationalise variables to use chrname (Name) and chrid (Chrom or MapChrom)
seqdb = read.table( paste(basefile,".Sequences.tdt",sep=""), header = T, stringsAsFactors = F, sep = '\t', quote = '', comment.char="")
rownames(seqdb) = seqdb$Name
colnames(seqdb)
summary(seqdb)
# Update colour dicionary for chromosomes
seqdb$Col = seqdb$Chrom
for(ctype in c("Reference","Assembly")){
  cdata = seqdb[seqdb$Source == ctype,]
  cx = 0
  for(chrname in cdata[order(cdata$Length,decreasing=TRUE),"Name"]){
    cx = cx + 1
    if(cx > length(soton$col)){ cx = 1 }
    seqdb[chrname,"Col"] = soton$col[cx]
    #!# Replace all below with chromCol() calls.
    settings$col[[chrname]] = soton$col[cx]                  #!# Remove once no longer needed
    settings$col[seqdb[chrname,"Chrom"]] = soton$col[cx]  #!# Remove once no longer needed
  }
}
settings$col[["NULL"]] = "black"
print(settings$col)
# General Sequence Data Retrieval
seqData = function(chrom,datafield,field="Name",ctype="All"){
  if(ctype == "All"){
    return( seqdb[seqdb[field]==chrom,datafield] )  
  }
  return( seqdb[seqdb[field]==chrom & seqdb["Source"]==ctype,datafield] )  
}
# Function for retrieving chromosome colours
chromCol = function(chrom,field="Name",ctype="All"){
  if(chrom == "NULL"){ return("black") }
  return( seqData(chrom,"Col",field,ctype) )  
}

#i# NOTE: rcovdata and acovdata (Coverage Summaries) are now in the Sequences Table
#i#       As a results, these are now called rseqdb and aseqdb.
#># [1] "Qry"       "HitNum"    "MaxScore"  "EVal"      "Length"    "Coverage"  "Identity"  "Positives" "Missing"   "Errors"    "Perfect"
#!# Qry is now Name but rest of fields the same.
#i# Elsewhere, HitNum is called HitSeq. (Number of Hit Sequences.)
rseqdb = seqdb[seqdb$Source == "Reference",]
rseqdb$Qry = rseqdb$Name
summary(rseqdb)
aseqdb = seqdb[seqdb$Source == "Assembly",]
aseqdb$Qry = aseqdb$Name
summary(aseqdb)


### ~ Overall summary data ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#># [1] "Summary"   "HitSeq"    "Length"    "Coverage"  "Identity"  "Positives" "Missing"   "Errors"    "Perfect"   "N"
(summdb = read.table( paste(basefile,".Summary.tdt",sep=""), header = T, stringsAsFactors = F, sep = '\t', quote = '', comment.char=""))

### ~ Chromosome-Contig Mapping data ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#># Qry,Chrom,Fwd,Rev,Unique,Rank,Dirn 
#i# Rank is the rank of Chrom for a Qry. Will need to calculate ranks of a Qry for Chrom - or just sort by Unique.
mapdb = read.table( paste(basefile,".Assembly.mapping.tdt",sep=""), header = T, stringsAsFactors = T, sep = '\t', quote = '', comment.char="")
colnames(mapdb)
summary(mapdb)


### ~ Chromosome-Contig Coverage data ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#># Qry, Pos, HitAln, HitSeq, HitChrom, Class, RecAln, RecSeq, RecChrom
#i# *.covplot.tdt data is used for the BLAST hit plots at the top of the covplot and assembly png outputs
#i# This used to be chromdata (covplotdb[["Reference"]]) and contigdata (covplotdb[["Assembly"]])
#i# [1] "Chrom"     "Pos"       "HitNum"    "ContigNum" "Contigs"   "Class"     "ChromHit"  "ChromNum"  "RefChrom" 
#i# There is now additional Snapper covplot data, which has "pure" coverage of unique assembly regions
#i# where each assembly contig region is only mapped to ONE reference chromosome. Therefore, the contig
#i# plots using covplotdb[["AssSnap"]] data should only have a single chromosome in HitSeq and HitChrom.
#i# NOTE: covplotdb[["AssSnap"]] and covplotdb[["RefSnap"]] are not designed to use Rec data chromPlot(recdata=FALSE).
#!# PLAN: update method to plot regular HitSeq and Snapper HitSeq on one plot w/o rec data
#!#
covplotdb = list()   # Covplot data loaded into data frame, else empty if file not found
for(ctype in c("Reference","Assembly","RefSnap","AssSnap")){
  covfile = paste(basefile,ctype,"covplot.tdt",sep=".")
  if(file.exists(covfile)){
    covplotdb[[ctype]] = read.table( covfile, header = T, stringsAsFactors = T, sep = '\t', quote = '', comment.char="")
    colnames(covplotdb[[ctype]])
    summary(covplotdb[[ctype]])
  }else{ covplotdb[[ctype]] = data.frame() }
}


### ~ Reference vs Assembly local BLAST hits ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#i# This has not been altered for PAGSAT V2.0 except removal of QryCol and HitCol.
#i# These data are used for the main "hit stack" and "chromosome map" plots.
#># Qry, Hit, AlnNum, BitScore, Expect, Length, Identity, Positives, QryStart, QryEnd, SbjStart, SbjEnd, Dirn
locdb = read.table( paste(settings$gablamdir,settings$basename,".Reference.local.tdt",sep=""), header = T, stringsAsFactors = T, sep = '\t', quote = '', comment.char="")
locdb = locdb[locdb$Length >= settings$minloclen,]
locdb$Dirn = "Fwd"
if(length(locdb[locdb$SbjStart > locdb$SbjEnd,]$Dirn) > 0){
  locdb[locdb$SbjStart > locdb$SbjEnd,]$Dirn = "Bwd"  
}
colnames(locdb)
summary(locdb)

## ~ Optional Snapper data for assembly plots, else use locdb data ~~~~~~~ ##
#># Qry, Hit, AlnNum, BitScore, Expect, Length, Identity, Positives, QryStart, QryEnd, SbjStart, SbjEnd, Dirn
#i# This file should have the same format as the local alignment file.
uniqfile = paste(settings$gablamdir,settings$basename,".Reference.unique.tdt",sep="")
if(file.exists(uniqfile)){
  uniqdb = read.table( uniqfile, header = T, stringsAsFactors = T, sep = '\t', quote = '', comment.char="")
  uniqdb = uniqdb[uniqdb$Length >= settings$minloclen,]
  uniqdb$Dirn = "Fwd"
  if(length(uniqdb[uniqdb$SbjStart > uniqdb$SbjEnd,]$Dirn) > 0){
    uniqdb[uniqdb$SbjStart > uniqdb$SbjEnd,]$Dirn = "Bwd"  
  }
  colnames(uniqdb) = colnames(locdb)
}else{
  uniqdb = locdb
}

(idlen = strsplit(settings$basename,'[.]')[[1]])
(idlen = idlen[length(idlen)])
(asslocfile = paste(assbase,idlen,"local.tdt",sep="."))
asslocdb = read.table( asslocfile, header = T, stringsAsFactors = T, sep = '\t', quote = '', comment.char="")
asslocdb = asslocdb[asslocdb$Length >= settings$minloclen,]
asslocdb$Dirn = "Fwd"
if(length(asslocdb[asslocdb$SbjStart > asslocdb$SbjEnd,]$Dirn) > 0){
  asslocdb[asslocdb$SbjStart > asslocdb$SbjEnd,]$Dirn = "Bwd"  
}
colnames(asslocdb)
summary(asslocdb)


### ~ Reference genome features ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
#># locus, feature, position, start, end, product, gene_synonym, note, db_xref, locus_tag, details
#!# Update this at some point to make ftdb[["Reference"]] and ftdb[["Assembly"]]
#!# Possibly add genedata and protdata to ftdb[["Assembly"]]?
if(settings$features){
  ftdb = read.table( paste(refbase,".Feature.tdt",sep=""), header = T, stringsAsFactors = F, sep = '\t', quote = '', comment.char="")
  ftdb = ftdb[ftdb$feature != "source",]
  ftdb = ftdb[ftdb$feature != "misc_RNA",]
  ftdb = ftdb[ftdb$feature != "misc_feature",]
  if(length(ftdb[ftdb$feature == "mobile_element",]$feature)>0){
    ftdb[ftdb$feature == "mobile_element",]$feature = "mobile"    
  }
  if(length(ftdb[ftdb$feature == "rep_origin",]$feature)>0){
    ftdb[ftdb$feature == "rep_origin",]$feature = "origin"
  }
  ftdb$feature = as.factor(ftdb$feature)
  colnames(ftdb)
  summary(ftdb)
  (levels(ftdb$feature))
}else{ ftdb = data.frame() }

#i# depthdb contains Xdepth data for each locus, generated by rje_samtools
#># Locus,	Pos,	X
settings$depth = FALSE
depthdb = list(Assembly=data.frame())
depfile = paste(assbase,".depthplot.tdt",sep="")
if(file.exists(depfile)){
  settings$depth = TRUE
  depthdb[["Assembly"]] = read.table( depfile, header = T, stringsAsFactors = F, sep = '\t', quote = '', comment.char="")
}

#i# xcovdb contains average Xdepth data for each locus, generated by rje_samtools
#># Locus, Length, MeanX, MedianX
xcovdb = list(Assembly=data.frame())
xcovfile = paste(assbase,".coverage.tdt",sep="")
if(file.exists(xcovfile)){
  xcovdb[["Assembly"]] = read.table( xcovfile, header = T, stringsAsFactors = F, sep = '\t', quote = '', comment.char="")
}


#!# >>> EDITED CAREFULLY TO HERE. NEED TO CHECK EVERYTHING WORKS AND THEN UPDATE FUNCTIONS <<< #!#

#!# Gene and Protein data and plots are currently unsupported but will be update in futurer version? #!#
## ~ Gene and Protein TopHits data ~ ##
#># [1] "Gene"       "Hit"        "ContigGene" "QryLen"     "Qry_AlnLen" "Qry_AlnID"  "Qry_Start"  "Qry_End"    "Hit_Start"  "Hit_End"    "Locus"      "Chrom"      "Contig"    
#># [14] "Position"   "Start"      "End"        "Product"    "Synonym"    "XRef"       "Note"       "Mapping"    "Chr5"       "Chr3"       "Ctg5"       "Ctg3"       "Synteny"  
if(settings$genesummary){
  genedb = read.table( paste(basefile,".Genes.TopHits.tdt",sep=""), header = T, stringsAsFactors = T, sep = '\t', quote = '', comment.char="")
  if(dim(genedb[genedb$Hit == "",])[1] > 0){
    genedb[genedb$Hit == "",]$Qry_AlnID = 0
  }
  colnames(genedb)
  summary(genedb)  
}

if(settings$protsummary){
  protdb = read.table( paste(basefile,".Proteins.TopHits.tdt",sep=""), header = T, stringsAsFactors = T, sep = '\t', quote = '', comment.char="")
  if(dim(protdb[protdb$Hit == "",])[1] >0){
    protdb[protdb$Hit == "",]$Qry_AlnID = 0
  }
  colnames(protdb)
  summary(protdb)
}
  
#==> MBG482001.sgd.ref.GABLAM/MBG482001.sgd.ref.L250ID95.Reference.cnv.tdt <==
#Source	Locus	Start	End	Copy
#Alt	A101_MBG482__MBG482001.194	1	36288	1
#Alt	A103_MBG482__MBG482001.197	1	30901	1
#># Want: Qry, Pos, HitAln, HitSeq, HitChrom, Class, RecAln, RecSeq, RecChrom
cnvfile = paste(settings$gablamdir,settings$basename,".Reference.cnv.tdt",sep="")
if(file.exists(cnvfile) & FALSE){
  cnvdb = read.table( cnvfile, header = T, stringsAsFactors = F, sep = '\t', quote = '', comment.char="")
  cnvdb = cnvdb[cnvdb$Source == "Ref",2:5]
  nrow = dim(cnvdb)[1]
  cnvdb$HitChrom = cnvdb$Locus
  for(i in 1:nrow){
    cnvdb$HitChrom[i] = strsplit(cnvdb$Locus[i],"_")[[1]][1]
  }
  cnvdb = cnvdb[c(1:nrow,1:nrow),]
  cnvdb[1:nrow,"Start"] = cnvdb[1:nrow,"End"]
  cnvdb = cnvdb[,c(1,2,4,6)]
  colnames(cnvdb) = c("Qry","Pos","HitAln")
  cnvdb$HitSeq = cnvdb$HitAln
  cnvdb$Class = "C"
  cnvdb[cnvdb$HitAln==1,]["Class"] = "U"
  cnvdb[cnvdb$HitAln==0,]["Class"] = "N"
}else{
  cnvdb = covplotdb[["Reference"]]
}
summary(cnvdb)
#!# Add the CNV output table and make a function to plot.
#!# Not actually used for anything!

#!# Add read depth data and plot too.

#!# Add minlocid and use to filter both locdb and uniqdb?
#!# Should no longer be necessary: applied at GABLAM stage on all data.
#?# Could make an optional visualisation filter in addition?



