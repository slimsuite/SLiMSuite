#!/usr/bin/python

# See below for name and description
# Copyright (C) 2014 Richard J. Edwards <redwards@cabbagesofdoom.co.uk>
#  
# This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program; if not, write to 
# the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# Author contact: <seqsuite@gmail.com> / School of Biotechnology and Biomolecular Sciences, UNSW, Sydney, Australia.
#
# To incorporate this module into your own programs, please see GNU Lesser General Public License disclaimer in rje.py

"""
Module:       rje_mitab
Description:  RJE MITAB File Parser
Version:      0.2.0
Last Edit:    30/04/15
Copyright (C) 2015  Richard J. Edwards - See source code for GNU License Notice

Function:
    This module is for parsing PPI data from a MITAB file into a pairwise PPI file, using rje_xref.XRef to map protein
    sequences onto the KeyID of XRef and a Uniprot field set by unifield=X. It is best to use an XRef table generated by
    PINGU as this includes a "Secondary" field of Uniprot secondary accession numbers.

    The complex=LIST setting is used to read in iRef-style MITAB files that have complex:XXX identifiers as one of the
    interactors. These will be kept during the initial parsing of the file and then replaced with ALL members to generate
    a complete set of all-by-all pairwise PPI for the complex.

Commandline:
    ### ~ Input Options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    mitab=FILE          : MITAB interaction file []
    unifield=X          : Uniprot accession number field identifier for xrefdata ['Uniprot']
    dbsource=X          : Source database for evidence field ['mitab']
    idfield=LIST        : Gene/protein identifier fields to look for []
    mapdb=LIST          : Restricted list of database identifier types to try mapping to xref KeyID/MapFields []
    taxafield=LIST      : Taxon identifier fields to look for []
    methodfield=LIST    : PPI detection method fields to look for []
    typefield=LIST      : PPI type fields to look for []
    ### ~ Parsing Options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    taxid=LIST          : List of NCBI Taxa IDs to use [9606]
    symmetry=T/F        : Whether to impose hub/spoke symmetry on parsed PPI [True]
    complex=LIST        : Complex identifier prefixes to expand from mapped PPI [rigid]
    splicevar=T/F       : Whether to allow splice variants in parsed Uniprot identifiers [False]
    unionly=T/F         : Whether to restrict PPI to pairwise with UniProt IDs [False]
    adduni=T/F          : Whether to add Uniprot IDs that are not returned from mapping file [True]
    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
"""
#########################################################################################################################
### SECTION I: GENERAL SETUP & PROGRAM DETAILS                                                                          #
#########################################################################################################################
import os, string, sys, time
slimsuitepath = os.path.abspath(os.path.join(os.path.dirname(os.path.realpath(__file__)),'../')) + os.path.sep
sys.path.append(os.path.join(slimsuitepath,'libraries/'))
sys.path.append(os.path.join(slimsuitepath,'tools/'))
### User modules - remember to add *.__doc__ to cmdHelp() below ###
import rje, rje_db, rje_obj, rje_xref
#########################################################################################################################
def history():  ### Program History - only a method for PythonWin collapsing! ###
    '''
    # 0.0.0 - Initial Compilation.
    # 0.1.0 - Added complex=LIST : Complex identifier prefixes to expand from mapped PPI [complex]
    # 0.1.1 - Fixed Evidence/IType parsing bug for BioGrid/Intact.
    # 0.2.0 - Added splicevar=T/F option.
    '''
#########################################################################################################################
def todo():     ### Major Functionality to Add - only a method for PythonWin collapsing! ###
    '''
    # [Y] : Populate Module Docstring with basic info.
    # [Y] : Populate makeInfo() method with basic info.
    # [Y] : Add full description of program to module docstring.
    # [Y] : Create initial working version of program.
    # [ ] : Add REST outputs to restSetup() and restOutputOrder()
    # [Y] : Add to SLiMSuite or SeqSuite.
    # [ ] : unionly=T/F         : Whether to restrict PPI to pairwise with UniProt IDs [False] ?
    '''
#########################################################################################################################
def makeInfo(): ### Makes Info object which stores program details, mainly for initial print to screen.
    '''Makes Info object which stores program details, mainly for initial print to screen.'''
    (program, version, last_edit, copy_right) = ('RJE_MITAB', '0.2.0', 'April 2015', '2015')
    description = 'RJE MITAB File Parser'
    author = 'Dr Richard J. Edwards.'
    comments = ['This program is still in development and has not been published.',rje_obj.zen()]
    return rje.Info(program,version,last_edit,description,author,time.time(),copy_right,comments)
#########################################################################################################################
def cmdHelp(info=None,out=None,cmd_list=[]):   ### Prints *.__doc__ and asks for more sys.argv commands
    '''Prints *.__doc__ and asks for more sys.argv commands.'''
    try:### ~ [1] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        if not info: info = makeInfo()
        if not out: out = rje.Out()
        ### ~ [2] ~ Look for help commands and print options if found ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        cmd_help = cmd_list.count('help') + cmd_list.count('-help') + cmd_list.count('-h')
        if cmd_help > 0:
            print '\n\nHelp for %s %s: %s\n' % (info.program, info.version, time.asctime(time.localtime(info.start_time)))
            out.verbose(-1,4,text=__doc__)
            if rje.yesNo('Show general commandline options?'): out.verbose(-1,4,text=rje.__doc__)
            if rje.yesNo('Quit?'): sys.exit()           # Option to quit after help
            cmd_list += rje.inputCmds(out,cmd_list)     # Add extra commands interactively.
        elif out.stat['Interactive'] > 1: cmd_list += rje.inputCmds(out,cmd_list)    # Ask for more commands
        ### ~ [3] ~ Return commands ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        return cmd_list
    except SystemExit: sys.exit()
    except KeyboardInterrupt: sys.exit()
    except: print 'Major Problem with cmdHelp()'
#########################################################################################################################
def setupProgram(): ### Basic Setup of Program when called from commandline.
    '''
    Basic Setup of Program when called from commandline:
    - Reads sys.argv and augments if appropriate
    - Makes Info, Out and Log objects
    - Returns [info,out,log,cmd_list]
    '''
    try:### ~ [1] ~ Initial Command Setup & Info ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        info = makeInfo()                                   # Sets up Info object with program details
        cmd_list = rje.getCmdList(sys.argv[1:],info=info)   # Reads arguments and load defaults from program.ini
        out = rje.Out(cmd_list=cmd_list)                    # Sets up Out object for controlling output to screen
        out.verbose(2,2,cmd_list,1)                         # Prints full commandlist if verbosity >= 2 
        out.printIntro(info)                                # Prints intro text using details from Info object
        cmd_list = cmdHelp(info,out,cmd_list)               # Shows commands (help) and/or adds commands from user
        log = rje.setLog(info,out,cmd_list)                 # Sets up Log object for controlling log file output
        return (info,out,log,cmd_list)                      # Returns objects for use in program
    except SystemExit: sys.exit()
    except KeyboardInterrupt: sys.exit()
    except: print 'Problem during initial setup.'; raise
#########################################################################################################################
### END OF SECTION I                                                                                                    #
#########################################################################################################################

                                                    ### ~ ### ~ ###

#########################################################################################################################
### SECTION II: MITAB Class                                                                                             #
#########################################################################################################################
class MITAB(rje_obj.RJE_Object):
    '''
    MITAB Class. Author: Rich Edwards (2015).

    Str:str
    DBSource=X      : Source database for evidence field ['mitab']
    MITAB=FILE          : MITAB interaction file []
    UniField=X          : Uniprot accession number field identifier for xrefdata ['Uniprot']

    Bool:boolean
    - AddUni=T/F          : Whether to add Uniprot IDs that are not returned from mapping file [True]
    - SpliceVar=T/F       : Whether to allow splice variants in parsed Uniprot identifiers [False]
    - Symmetry=T/F        : Whether to impose hub/spoke symmetry on parsed PPI [True]
    - UniOnly=T/F         : Whether to restrict PPI to pairwise with UniProt IDs [False]

    Int:integer

    Num:float

    File:file handles with matching str filenames
    
    List:list
    Complex=LIST        : Complex identifier prefixes to expand from mapped PPI [complex]
    Headers = List of headers read from MITAB file, adjusted to have uppercase A/B where required.
    IDField=LIST        : Gene/protein identifier fields to look for []
    MapDB=LIST      : List of database identifier types to try mapping ['uniprotkb','hgnc','refseq']
    MethodField=LIST    : PPI detection method fields to look for []
    TaxaField=LIST      : Taxon identifier fields to look for []
    TaxID=LIST      : List of NCBI Taxa IDs to use (for DIP and Domino) [9606]
    TypeField=LIST     : PPI type fields to look for []

    Dict:dictionary

    Obj:RJE_Objects
    DB = Database object for pairwise PPI table
    XRef = XRef object for identifier cross-referencing
    '''
#########################################################################################################################
    ### <1> ### Class Initiation etc.: sets attributes                                                                  #
#########################################################################################################################
    def _setAttributes(self):   ### Sets Attributes of Object
        '''Sets Attributes of Object.'''
        ### ~ Basics ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        self.strlist = ['DBSource','MITAB','UniField']
        self.boollist = ['AddUni','SpliceVar','Symmetry','UniOnly']
        self.intlist = []
        self.numlist = []
        self.filelist = ['MITAB']
        self.listlist = ['Complex','Headers','IDField','MapDB','MethodField','TaxaField','TaxID','TypeField']
        self.dictlist = []
        self.objlist = ['DB','XRef']
        ### ~ Defaults ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        self._setDefaults(str='None',bool=False,int=0,num=0.0,obj=None,setlist=True,setdict=True,setfile=True)
        self.setStr({'DBSource':'','UniField':'Uniprot'})
        self.setBool({'AddUni':True,'Symmetry':True})
        self.setInt({})
        self.setNum({})
        self.list['Complex'] = ['rigid']
        self.list['IDField'] = ['INTERACTOR_','uid','#uid','alt','alias','ID interactor','#ID interactor','xrefs_',
                                'Alt. ID interactor','Alias(es) interactor',    # DIP/Domino
                                'Alt IDs Interactor','Aliases Interactor',       # BioGRID
                                'Alt. ID(s) interactor','Xref(s) interactor',
                                'ID interactors','Alt. ID interactors','Alias(es) interactors','xrefs', #MINT
                                '#ID(s) interactor','Alt. ID(s) interactor'
                                ]
        self.list['TaxaField'] = ['tax','Taxid interactor','Taxid interactors']
        self.list['TaxID'] = ['9606']
        self.list['MethodField'] = ['method','Interaction detection method(s)','Interaction Detection Method']
        self.list['TypeField'] = ['interactionType','Interaction Types','Interaction type(s)']
        self.list['MapDB'] = [] #'uniprotkb','hgnc','refseq','ensembl']
        ### ~ Other Attributes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        self._setForkAttributes()   # Delete if no forking
#########################################################################################################################
    def _cmdList(self):     ### Sets Attributes from commandline
        '''
        Sets attributes according to commandline parameters:
        - see .__doc__ or run with 'help' option
        '''
        for cmd in self.cmd_list:
            try:
                self._generalCmd(cmd)   ### General Options ### 
                self._forkCmd(cmd)  # Delete if no forking
                ### Class Options (No need for arg if arg = att.lower()) ### 
                #self._cmdRead(cmd,type='str',att='Att',arg='Cmd')  # No need for arg if arg = att.lower()
                self._cmdReadList(cmd,'str',['DBSource','UniField'])   # Normal strings
                #self._cmdReadList(cmd,'path',['Att'])  # String representing directory path 
                self._cmdReadList(cmd,'file',['MITAB'])  # String representing file path
                #self._cmdReadList(cmd,'date',['Att'])  # String representing date YYYY-MM-DD
                self._cmdReadList(cmd,'bool',['AddUni','SpliceVar','Symmetry','UniOnly'])  # True/False Booleans
                #self._cmdReadList(cmd,'int',['Att'])   # Integers
                #self._cmdReadList(cmd,'float',['Att']) # Floats
                #self._cmdReadList(cmd,'min',['Att'])   # Integer value part of min,max command
                #self._cmdReadList(cmd,'max',['Att'])   # Integer value part of min,max command
                self._cmdReadList(cmd,'list',['Complex','IDField','MapDB','MethodField','TaxaField','TypeField'])  # List of strings (split on commas or file lines)
                #self._cmdReadList(cmd,'clist',['Att']) # Comma separated list as a *string* (self.str)
                #self._cmdReadList(cmd,'glist',['Att']) # List of files using wildcards and glob
                #self._cmdReadList(cmd,'cdict',['Att']) # Splits comma separated X:Y pairs into dictionary
                #self._cmdReadList(cmd,'cdictlist',['Att']) # As cdict but also enters keys into list
            except: self.errorLog('Problem with cmd:%s' % cmd)
        self.list['MapDB'] = rje.listLower(self.list['MapDB'])
        self.list['Complex'] = rje.listLower(self.list['Complex'])
#########################################################################################################################
    ### <2> ### Main Class Backbone                                                                                     #
#########################################################################################################################
    def run(self,save=True):  ### Main run method
        '''Main run method.'''
        try:### ~ [1] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            if not self.setup(): return False
            ### ~ [2] ~ Add main run code here ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.parseMITAB()
            pdb = self.db('pairwise')
            if save:
                pdb.compress(['Hub','Spoke','HubTaxID','SpokeTaxID'],rules={'Evidence':'list','IType':'list'},joinchar='|')
                pdb.dropField('#')
                self.printLog('#PPI','%s unique pairwise PPI (Symmetry=%s)' % (rje.iStr(pdb.entryNum()),self.getBool('Symmetry')))
                pdb.saveToFile()
                pdb.index('Evidence',splitchar='|')
                pdb.indexReport('Evidence','#METHOD')
                pdb.index('IType',splitchar='|')
                pdb.indexReport('IType','#ITYPE')
            return pdb
        except:
            self.errorLog(self.zen())
            raise   # Delete this if method error not terrible
#########################################################################################################################
    def setup(self):    ### Main class setup method.
        '''Main class setup method.'''
        try:### ~ [1] Setup Objects ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            if not self.getStrLC('DBSource'): self.setStr({'DBSource':string.split(rje.stripPath(self.getStr('MITAB')),'.')[0]})
            if not self.obj['DB']: self.obj['DB'] = rje_db.Database(self.log,self.cmd_list)
            pdb = self.db('pairwise',add=False)
            pfields = ['#','Hub','Spoke','HubUni','SpokeUni','HubTaxID','SpokeTaxID','Evidence','IType']
            if not pdb: self.db().addEmptyTable('pairwise',pfields,['#'],log=True)
            if not self.obj['XRef']:
                xcmd = ['mapfields=%s,Secondary,Ensembl,Aliases,Accessions,RefSeq,Previous Symbols,Synonyms' % self.getStr('UniField')]
                self.obj['XRef'] = rje_xref.XRef(self.log,xcmd+self.cmd_list)
                self.obj['XRef'].setup()
            skip_comments = True
            for field in self.list['IDField']:
                if field[:1] == '#': skip_comments = False
            if self.list['MapDB'] and 'uniprotkb' not in self.list['MapDB']:
                self.list['MapDB'].append('uniprotkb')
                self.printLog('#MAP','uniprotkb added to MapDB list.')
            elif not self.list['MapDB']: self.printLog('#MAP','No MapDB list: will attempt to match all IDs to xref KeyID "%s".' % self.obj['XRef'].getStr('KeyID'))
            ### ~ [2] Setup MITAB File ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.open('MITAB')
            if not self.file['MITAB']: raise IOError
            self.printLog('#MITAB','Parse PPI from %s.' % self.getStr('MITAB'))
            ## ~ [2a] MITAB file headers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            headers = []
            while not headers:
                self.list['Headers'] = headers = self.readDelimit('MITAB')
                if not headers: break
                if headers[0][:1] == '#' and skip_comments: headers = []; continue
            #self.debug(headers)
            ## ~ [2b] IDField headers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            idfields = []
            for hfield in headers:
                #self.bugPrint(hfield.upper())
                for idfield in rje.sortUnique(self.list['IDField'])[0:]:
                    idfield = string.replace(idfield.upper(),'(','\(')
                    idfield = string.replace(idfield,')','\)')
                    idmatch = rje.matchExp('^(%s\s?[AB])$' % idfield.upper(),hfield.upper())
                    if not idmatch: idmatch = rje.matchExp('^(%s\s?[AB]) \(\S+\)$' % idfield.upper(),hfield.upper())
                    if idmatch and hfield not in idfields:
                        idfields.append(hfield)
                        self.printLog('#ID','IDField: %s' % hfield)
                        #self.bugPrint(idfields)
                        break
            #self.debug(idfields)
            self.list['IDField'] = idfields
            if not self.list['IDField']: raise ValueError('No IDField found in MITAB headers.')
            ## ~ [2c] TaxaField headers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            taxafields = []
            for tfield in self.list['TaxaField'][0:]:
                for hfield in headers:
                    tmatch = rje.matchExp('^(%s\s?[AB])$' % tfield.upper(),hfield.upper())
                    if not tmatch: tmatch = rje.matchExp('^(%s\s?[AB]) \(\S+\)$' % tfield.upper(),hfield.upper())
                    if tmatch and hfield not in taxafields:
                        taxafields.append(hfield)
                        self.printLog('#TAX','TaxaField: %s' % hfield)
            self.list['TaxaField'] = taxafields
            if not self.list['TaxaField']: self.warnLog('No TaxaField found in MITAB headers.',quitchoice=True)
            ## ~ [2d] TypeField headers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            methfields = []
            lctypes = rje.listLower(self.list['MethodField'])
            for hfield in headers:
                if hfield.lower() in lctypes:
                    methfields.append(hfield)
                    self.printLog('#METH','MethodField: %s' % hfield)
            self.list['MethodField'] = methfields
            if not self.list['MethodField']: self.warnLog('No MethodField found in MITAB headers.',quitchoice=True)
            ## ~ [2e] TypeField headers ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            typefields = []
            lctypes = rje.listLower(self.list['TypeField'])
            for hfield in headers:
                if hfield.lower() in lctypes:
                    typefields.append(hfield)
                    self.printLog('#TYPE','TypeField: %s' % hfield)
            self.list['TypeField'] = typefields
            if not self.list['TypeField']: self.warnLog('No TypeField found in MITAB headers.',quitchoice=True)

            return True     # Setup successful
        except: self.errorLog('Problem during %s setup.' % self.prog()); return False  # Setup failed
#########################################################################################################################
    def restSetup(self):    ### Sets up self.dict['Output'] and associated output options if appropriate.
        '''
        There is currently no specific help available on REST output for this program. Run with &rest=help for general
        options. Run with &rest=full to get full server output. Individual outputs can be identified/parsed:

        ###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~###
        # OUTFMT:
        ...

        &rest=OUTFMT can then be used to retrieve individual parts of the output in future.
        '''
        try:### ~ [0] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            for outfmt in self.restOutputOrder(): self.dict['Output'][outfmt] = 'No output generated.'
            #!# Add specific program output here. Point self.dict['Output'][&rest=X] to self.str key.
            return
        except: self.errorLog('RestSetup error')
#########################################################################################################################
    def restOutputOrder(self): return rje.sortKeys(self.dict['Output'])
#########################################################################################################################
    ### <3> ### Additional Class Methods                                                                                #
#########################################################################################################################
    def parseMITAB(self):   ### Parse MITAB file into pairwise PPI table.
        '''Parse MITAB file into pairwise PPI table.'''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            xref = self.obj['XRef']
            pdb = self.db('pairwise')
            pfields = ['Hub','Spoke','HubUni','SpokeUni','HubTaxID','SpokeTaxID','Evidence','IType']
            headers = {}
            for h in range(len(self.list['Headers'])): headers[self.list['Headers'][h]] = h
            dbsource = self.getStr('DBSource')
            ### ~ [2] Read through MITAB ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            mx = 0; ex = 0; fax = 0; ftx = 0; fx = 0; uhx = 0; usx = 0
            epos = self.endPos('MITAB')
            complexidlist = []
            badtaxa = ['-']
            baduni = []
            while 1:
                self.progLog('\r#MITAB','Parsing %s MITAB %s: %s lines; %s ppi; %s taxa-filtered; %s ambiguous; %s failed; %s complexes.' % (dbsource,self.fileProg('MITAB',epos),rje.iStr(mx),rje.iStr(ex),rje.iStr(ftx),rje.iStr(fax),rje.iStr(fx),rje.iLen(complexidlist)))
                mline = self.readDelimit('MITAB'); mx += 1
                if not mline: break
                entry = {'#':pdb.entryNum()}
                for field in pfields: entry[field] = ''
                ## ~ [2a] Add iRefIndex complexes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                complexid = {}     # This will take the first complex ID
                if 'irigid' in self.list['Headers'] and 'numParticipants' in self.list['Headers']:
                    if int(mline[headers['numParticipants']]) > 2:
                        complexid['A'] = complexid['B'] = 'rigid:%s' % mline[headers['irigid']]
                        self.bugPrint(mline)
                        self.debug(complexid)
                ## ~ [2b] Parse and check taxa ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                taxa = {'A':'','B':''}
                for tfield in self.list['TaxaField']:
                    ab = tfield[-1:].upper()
                    if ab == ')': ab = rje.matchExp('([AB]) \(\S+\)$',tfield.upper())[0]
                    try:
                        taxon = rje.matchExp('^taxid:(\d+)',mline[headers[tfield]].lower())[0]
                        if self.list['TaxID'] and taxon not in self.list['TaxID']: continue
                        taxa[ab] = taxon
                    except:
                        taxon = mline[headers[tfield]]
                        if taxon not in badtaxa:
                            badtaxa.append(taxon)
                            self.warnLog('No TaxID read from %s: "%s"' % (tfield,taxon),'no_tax',suppress=True)
                        if not self.list['TaxID']: taxa[ab] = '-'
                if not taxa['A'] and complexid: taxa['A'] = taxa['B']
                if not taxa['B'] and complexid: taxa['B'] = taxa['A']
                if not (taxa['A'] and taxa['B']): ftx += 1; continue
                ## ~ [2c] Parse protein IDs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                ids = {'A':[],'B':[]}
                uni = {'A':'','B':''}
                for ifield in self.list['IDField']:
                    ab = ifield[-1:].upper()
                    if ab == ')': ab = rje.matchExp('([AB]) \(\S+\)$',ifield.upper())[0]
                    # Split IDs on | then db:id vs self.list['MapDB']
                    for pid in string.split(mline[headers[ifield]],'|'):
                        try: (db,dbid) = string.split(pid,':',1)
                        except: continue
                        if db.lower() in ['uniprotkb'] and '(' in dbid: continue    # Only map uniprotkb accnum
                        dbid = string.split(dbid,'(')[0]
                        dbid = string.split(dbid,';')[0]
                        if db.lower() in ['uniprotkb']:
                            svid = dbid
                            dbid = string.split(svid,'-')[0]
                        if ab not in complexid:     # First identifier for A/B
                            if db.lower() in self.list['Complex']: complexid[ab] = pid; ids[ab].append(pid)
                            else: complexid[ab] = ''
                        if not self.list['MapDB'] or db.lower() in self.list['MapDB']: ids[ab].append(dbid)
                        # Parse uniprot directly if possible
                        if db.lower() in ['uniprotkb'] and not uni[ab]:
                            if self.getBool('SpliceVar'): uni[ab] = svid
                            else: uni[ab] = dbid
                #self.bugPrint(ids)
                ## ~ [2d] Map parsed IDs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                amb = {'A':False,'B':False}
                if not ids['A'] or not ids['B']:
                    self.bugPrint('%s\n=> ID Failure' % mline)
                    self.bugPrint(ids['A']); self.bugPrint(ids['B'])
                    self.bugPrint(entry)
                    fx += 1; continue
                for ida in ids['A']:
                    #self.debug('%s => %s (or %s)' % (ida,xref.xref(ida,unique=True),xref.xref(ida,unique=False)))
                    if not entry['Hub']: entry['Hub'] = xref.xref(ida,unique=True,usedict=True)
                    if entry['Hub'] == False: amb['A'] = True
                    #if not entry['HubUni']: entry['HubUni'] = xref.xref(ida,self.getStr('UniField'),unique=True,usedict=True)
                    if not entry['HubUni']: entry['HubUni'] = self.getUniXRef(ida)
                if self.getBool('AddUni') and not entry['HubUni']:
                    entry['HubUni'] = uni['A']
                    if uni['A'] and uni['A'] not in baduni: baduni.append(uni['A'])
                if not entry['Hub'] and entry['HubUni']:
                    entry['Hub'] = entry['HubUni']
                    #self.warnLog('UniprotKB "%s" used for Hub' % entry['HubUni'],'unihub',suppress=True)
                    uhx += 1
                if not entry['Hub'] and complexid['A']:
                    entry['Hub'] = complexid['A']
                else: complexid['A'] = ''
                if self.getBool('UniOnly') and not complexid['A'] and not entry['HubUni']: entry['Hub'] = ''
                for idb in ids['B']:
                    if not entry['Spoke']: entry['Spoke'] = xref.xref(idb,unique=True,usedict=True)
                    if entry['Spoke'] == False: amb['B'] = True
                    #if not entry['SpokeUni']: entry['SpokeUni'] = xref.xref(idb,self.getStr('UniField'),unique=True,usedict=True)
                    if not entry['SpokeUni']: entry['SpokeUni'] = self.getUniXRef(idb)
                if self.getBool('AddUni') and not entry['SpokeUni']: entry['SpokeUni'] = uni['B']
                if not entry['Spoke'] and entry['SpokeUni']:
                    entry['Spoke'] = entry['SpokeUni']
                    #self.warnLog('UniprotKB "%s" used for Spoke' % entry['SpokeUni'],'unihub',suppress=True)
                    usx += 1
                if not entry['Spoke'] and complexid['B']:
                    entry['Spoke'] = complexid['B']
                else: complexid['B'] = ''
                if self.getBool('UniOnly') and not complexid['B'] and not entry['SpokeUni']:
                    entry['Spoke'] = ''
                    if uni['B'] and uni['B'] not in baduni: baduni.append(uni['B'])
                if complexid['A'] and complexid['B']:
                    if not (complexid['A'].startswith('rigid:') and complexid['B'].startswith('rigid:')):
                        self.printLog('\r#MITAB','',log=False)
                        self.warnLog('Cannot parse complex:complex PPI (%s & %s)' % (complexid['A'],complexid['B']),'complex-complex',suppress=True)
                    entry['Hub'] = entry['Spoke'] = ''
                #self.bugPrint(entry)
                #self.debug(complexid)
                if not (entry['Hub'] and entry['Spoke']):
                    if (entry['Hub'] or amb['A']) and (entry['Spoke'] or amb['B']):
                        fax += 1; continue
                    #self.bugPrint(mline); self.debug(entry)
                    fx += 1; continue
                if self.dev() and 'PCNA' not in [entry['Hub'],entry['Spoke']]: continue
                entry['HubTaxID'] = taxa['A']
                entry['SpokeTaxID'] = taxa['B']
                if complexid['A'] and complexid['A'] not in complexidlist: complexidlist.append(complexid['A'])
                if complexid['B'] and complexid['B'] not in complexidlist: complexidlist.append(complexid['B'])
                if complexid['A'] or complexid['B']: self.debug(entry)
                ## ~ [2c] Parse evidence ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                self.bugPrint(mline)
                evidence = []
                for tfield in self.list['MethodField']:
                    self.bugPrint(string.split(mline[headers[tfield]],'|'))
                    for etype in string.split(mline[headers[tfield]],'|'):
                        ematch = rje.matchExp('MI:\d+"?\((.+)\)',etype)
                        if ematch: evidence.append('%s:%s' % (dbsource,ematch[0]))
                if not evidence: evidence.append('%s:unknown' % (self.getStr('DBSource')))
                #self.debug(evidence)
                entry['Evidence'] = string.join(evidence,'|')
                ## ~ [2d] Parse interaction types ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                itypes = []
                for tfield in self.list['TypeField']:
                    self.bugPrint(string.split(mline[headers[tfield]],'|'))
                    for etype in string.split(mline[headers[tfield]],'|'):
                        ematch = rje.matchExp('MI:\d+"?\((.+)\)',etype)
                        if ematch: itypes.append(ematch[0])
                if not itypes: itypes.append('unknown')
                #self.debug(itypes)
                entry['IType'] = string.join(itypes,'|')
                pdb.addEntry(entry); ex += 1
                #self.debug(entry)
                if self.getBool('Symmetry') and not complexid['A'] and not complexid['B']:
                    pdb.addEntry({'#':pdb.entryNum(),'Hub':entry['Spoke'],'Spoke':entry['Hub'],
                                  'HubUni':entry['SpokeUni'],'SpokeUni':entry['HubUni'],
                                  'HubTaxID':entry['SpokeTaxID'],'SpokeTaxID':entry['HubTaxID'],
                                  'Evidence':entry['Evidence'],'IType':entry['IType']})
            self.printLog('\r#MITAB','Parsing %s MITAB complete: %s lines; %s ppi; %s taxa-filtered; %s ambiguous; %s failed; %s complexes.' % (dbsource,rje.iStr(mx),rje.iStr(ex),rje.iStr(ftx),rje.iStr(fax),rje.iStr(fx),rje.iLen(complexidlist)))
            self.close('MITAB')
            if (uhx+usx): self.warnLog('UniprotKB IDs used for %s Hub and %s Spoke IDs.' % (rje.iStr(uhx),rje.iStr(usx)))
            if baduni:
                baduni.sort()
                accout = '%s.%s.unmapped.uniacc' % (self.baseFile(),dbsource)
                self.warnLog('%s unmapped UniprotKB IDs used: output to %s.' % (rje.iLen(baduni),accout))
                open(accout,'w').write(string.join(baduni,'\n'))

            ### ~ [3] Convert complexes to pairwise PPIs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            if not complexidlist: return pdb
            self.printLog('#CPLEX','%s complex IDs parsed to convert to pairwise PPI.' % rje.iLen(complexidlist))
            ## ~ [3a] Assemble complex memberships ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            complexes = {}; chentries = []; csentries = []
            cevidence = {}  # List of Evidence for each complex
            citypes = {}    # List of ITypes for each complex
            ctaxa = {}
            ex = 0.0; etot = pdb.entryNum()
            for entry in pdb.entries():
                self.progLog('\r#CPLEX','Assembling complexes: %.1f%%' % (ex/etot)); ex += 100.0
                if entry['Hub'] in complexidlist:
                    cid = entry['Hub']
                    if cid not in complexes: complexes[cid] = []; cevidence[cid] = []; citypes[cid] = []
                    complexes[cid].append(entry['Spoke'])
                    ctaxa[entry['Spoke']] = entry['SpokeTaxID']
                    cevidence[cid].append(entry['Evidence'])
                    citypes[cid].append(entry['IType'])
                    chentries.append(entry)
                elif entry['Spoke'] in complexidlist:
                    cid = entry['Spoke']
                    if cid not in complexes: complexes[cid] = []; cevidence[cid] = []; citypes[cid] = []
                    complexes[cid].append(entry['Hub'])
                    ctaxa[entry['Hub']] = entry['HubTaxID']
                    cevidence[cid].append(entry['Evidence'])
                    citypes[cid].append(entry['IType'])
                    csentries.append(entry)
            self.printLog('\r#CPLEX','Assembled %s of %s complexes.' % (rje.iLen(complexes),rje.iLen(complexidlist)))
            self.debug(complexes)
            ## ~ [3b] Update complexes dictionary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            cppi = {}
            ex = 0.0; etot = len(complexes); rx = 0; px = 0; cmax = 0
            for cid in rje.sortKeys(complexes):
                self.progLog('\r#CPLEX','Reducing complexes: %.1f%%' % (ex/etot)); ex += 100.0
                if len(complexes[cid]) < 2:
                    complexes.pop(cid)
                    cevidence.pop(cid)
                    citypes.pop(cid)
                    rx += 1; continue
                complexes[cid].sort()
                #cevidence[cid] = string.join(rje.sortUnique(cevidence[cid]),'|')
                #citypes[cid] = string.join(rje.sortUnique(citypes[cid]),'|')
                cmax = max(cmax,len(complexes[cid]))
                #px += (len(complexes[cid]) * (len(complexes[cid])-1))
                members = complexes[cid][0:]
                while members:
                    hub = members.pop(0)
                    if hub not in cppi: cppi[hub] = {}
                    for spoke in members:
                        if spoke not in cppi[hub]:
                            cppi[hub][spoke] = []; px += 1
                            cppi[hub][spoke].append(cid)
            self.printLog('\r#CPLEX','Reduced %s complexes to %s > 1 member: %s ppi to add.' % (rje.iStr(etot),rje.iLen(complexes),rje.iStr(px)))
            ## ~ [3c] Update pairwise PPI ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            cix = pdb.entryNum()
            for centry in chentries + csentries: pdb.dropEntry(centry)
            ex = 0.0; etot = len(cppi)
            for hub in rje.sortKeys(cppi):
                self.progLog('\r#CPLEX','Expanding complexes: %.1f%%' % (ex/etot)); ex += 100.0
                #hentry = {'Hub':hub,'HubUni':xref.xref(hub,self.getStr('UniField'),unique=True,usedict=True),'HubTaxID':ctaxa[hub]}
                hentry = {'Hub':hub,'HubUni':self.getUniXRef(hub),'HubTaxID':ctaxa[hub]}
                for spoke in rje.sortKeys(cppi[hub]):
                    evidence = []
                    itypes = []
                    ctypes = []
                    for cid in cppi[hub][spoke]:
                        evidence += cevidence[cid]
                        itypes += citypes[cid]
                        ctypes += string.split(cid,':')[0]
                    ctype = string.join(rje.sortUnique(ctypes),'|')
                    evidence = string.join(rje.sortUnique(evidence),'|')
                    if not evidence: evidence = '%s:%s' % (dbsource,ctype)
                    itypes = string.join(rje.sortUnique(itypes),'|')
                    if not itypes: itypes = ctype
                    #newentry = {'#':cix,'Spoke':spoke,'SpokeUni':xref.xref(spoke,self.getStr('UniField'),unique=True,usedict=True),'SpokeTaxID':ctaxa[spoke]}
                    newentry = {'#':cix,'Spoke':spoke,'SpokeUni':self.getUniXRef(spoke),'SpokeTaxID':ctaxa[spoke]}
                    newentry['Evidence'] = evidence
                    newentry['IType'] = itypes
                    entry = pdb.addEntry(rje.combineDict(newentry,hentry,overwrite=False)); cix += 1
                    if self.getBool('Symmetry'):
                        pdb.addEntry({'#':cix,'Hub':entry['Spoke'],'Spoke':entry['Hub'],
                                      'HubUni':entry['SpokeUni'],'SpokeUni':entry['HubUni'],
                                      'HubTaxID':entry['SpokeTaxID'],'SpokeTaxID':entry['HubTaxID'],
                                      'Evidence':entry['Evidence'],'IType':entry['IType']})
                        cix += 1
            self.printLog('#CPLEX','%s complex IDs expanded to pairwise PPI => %s ppi (symmetry=%s).' % (rje.iLen(complexidlist),rje.iStr(pdb.entryNum()),self.getBool('Symmetry')))
            return pdb
        except: self.errorLog('%s.parseMITAB error' % self.prog())
#########################################################################################################################
    def getUniXRef(self,seqid,mapfields=[]):   ### Returns first Uniprot ID for given sequence ID and mapfields
        '''Returns first Uniprot ID for given sequence ID and mapfields.'''
        xref = self.obj['XRef']
        unixref = xref.xref(seqid,self.getStr('UniField'),mapfields=mapfields,unique=False,usedict=True)
        if unixref: return unixref[0]
        else: return ''
#########################################################################################################################
### End of SECTION II: MITAB Class                                                                                      #
#########################################################################################################################

                                                    ### ~ ### ~ ###

#########################################################################################################################
### SECTION III: MODULE METHODS                                                                                         #
#########################################################################################################################

#########################################################################################################################
### END OF SECTION III                                                                                                  #
#########################################################################################################################

                                                    ### ~ ### ~ ###

#########################################################################################################################
### SECTION IV: MAIN PROGRAM                                                                                            #
#########################################################################################################################
def runMain():
    ### ~ [1] ~ Basic Setup of Program  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    try: (info,out,mainlog,cmd_list) = setupProgram()
    except SystemExit: return  
    except: print 'Unexpected error during program setup:', sys.exc_info()[0]; return
    
    ### ~ [2] ~ Rest of Functionality... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    try: MITAB(mainlog,cmd_list).run()

    ### ~ [3] ~ End ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    except SystemExit: return  # Fork exit etc.
    except KeyboardInterrupt: mainlog.errorLog('User terminated.')
    except: mainlog.errorLog('Fatal error in main %s run.' % info.program)
    mainlog.endLog(info)
#########################################################################################################################
if __name__ == "__main__":      ### Call runMain 
    try: runMain()
    except: print 'Cataclysmic run error:', sys.exc_info()[0]
    sys.exit()
#########################################################################################################################
### END OF SECTION IV                                                                                                   #
#########################################################################################################################
