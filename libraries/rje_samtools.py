#!/usr/bin/python

# See below for name and description
# Copyright (C) 2012 Richard J. Edwards <redwards@cabbagesofdoom.co.uk>
#  
# This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program; if not, write to 
# the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# Author contact: <redwards@cabbagesofdoom.co.uk> / School of Biological Sciences, University of Southampton, UK.
#
# To incorporate this module into your own programs, please see GNU Lesser General Public License disclaimer in rje.py

"""
Module:       rje_samtools
Description:  RJE SAMtools parser and processor
Version:      0.1.0
Last Edit:    17/11/15
Copyright (C) 2013  Richard J. Edwards - See source code for GNU License Notice

Function:
    The initial function of this program is for calling/assessing genetic changes following MPileup mapping of a
    wildtype (e.g. ancestor) and mutant (BAM file) against the same reference genome. The MPileup files should be
    generated by piping the output of the following into a file:

    samtools mpileup -BQ0 -d10000000 -f <Ref Genome Fasta> <BAM file>

Commandline:
    wtpileup=FILE   : MPileup results for wildtype genome resequencing [None]
    mutpileup=FILE  : MPileup results for mutant genome resequencing [None]
    qcut=X          : Min. quality score for a call to include [40]
    ignoren=T/F     : Whether to exclude "N" calls for major/minor alleles [True]
    minfreq=X       : Minor allele(s) frequency correction for zero counts (e.g. Sequencing error) [0.001]
    majdif=T/F      : Whether to restrict output and stats to positions with Major Allele differences [True]
    snptables=LIST  : Existing SNPs of interest to be cross-referenced with the WT and Mutant SNPs []

See also rje.py generic commandline options.

Uses general modules: copy, glob, os, string, sys, time
Uses RJE modules: rje, rje_db, rje_obj, rje_zen
Other modules needed: None
"""
#########################################################################################################################
### SECTION I: GENERAL SETUP & PROGRAM DETAILS                                                                          #
#########################################################################################################################
import copy, glob, os, string, sys, time
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)),'../libraries/'))
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)),'../tools/'))
### User modules - remember to add *.__doc__ to cmdHelp() below ###
import rje, rje_db, rje_obj, rje_zen
#########################################################################################################################
def history():  ### Program History - only a method for PythonWin collapsing! ###
    '''
    # 0.0 - Initial Compilation.
    # 0.1.0 - Modified version to handle multiple loci per file. (Original was for single bacterial chromosomes.)
    '''
#########################################################################################################################
def todo():     ### Major Functionality to Add - only a method for PythonWin collapsing! ###
    '''
    # [Y] : Populate Module Docstring with basic info.
    # [Y] : Populate makeInfo() method with basic info.
    # [Y] : Add full description of program to module docstring.
    # [Y] : Create initial working version of program.
    # [ ] : Add option to limit output to different Major Alleles only. (And/or Allele Freq cutoffs?)
    # [ ] : Add option to output data for specific subset of positions (e.g. from different analysis)
    # [ ] : Add option to compare outputs with different QCs?
    # [ ] : Add options/warnings for low QN counts?
    # [ ] : Add Locus to SNP table.
    # [ ] : Add Locus to mpileup reading.
    # [ ] : Add pvalue threshold and p-value cutoff summaries.
    '''
#########################################################################################################################
def makeInfo(): ### Makes Info object which stores program details, mainly for initial print to screen.
    '''Makes Info object which stores program details, mainly for initial print to screen.'''
    (program, version, last_edit, copyyear) = ('rje_samtools', '0.1.0', 'November 2015', '2013')
    description = 'RJE SAMtools parser and processor'
    author = 'Dr Richard J. Edwards.'
    comments = ['This program is still in development and has not been published.',rje_zen.Zen().wisdom()]
    return rje.Info(program,version,last_edit,description,author,time.time(),copyyear,comments)
#########################################################################################################################
def cmdHelp(info=None,out=None,cmd_list=[]):   ### Prints *.__doc__ and asks for more sys.argv commands
    '''Prints *.__doc__ and asks for more sys.argv commands.'''
    try:### ~ [1] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        if not info: info = makeInfo()
        if not out: out = rje.Out()
        ### ~ [2] ~ Look for help commands and print options if found ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        helpx = cmd_list.count('help') + cmd_list.count('-help') + cmd_list.count('-h')
        if helpx > 0:
            print '\n\nHelp for %s %s: %s\n' % (info.program, info.version, time.asctime(time.localtime(info.start_time)))
            out.verbose(-1,4,text=__doc__)
            if rje.yesNo('Show general commandline options?'): out.verbose(-1,4,text=rje.__doc__)
            if rje.yesNo('Quit?'): sys.exit()           # Option to quit after help
            cmd_list += rje.inputCmds(out,cmd_list)     # Add extra commands interactively.
        elif out.stat['Interactive'] > 1: cmd_list += rje.inputCmds(out,cmd_list)    # Ask for more commands
        ### ~ [3] ~ Return commands ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        return cmd_list
    except SystemExit: sys.exit()
    except KeyboardInterrupt: sys.exit()
    except: print 'Major Problem with cmdHelp()'
#########################################################################################################################
def setupProgram(): ### Basic Setup of Program when called from commandline.
    '''
    Basic Setup of Program when called from commandline:
    - Reads sys.argv and augments if appropriate
    - Makes Info, Out and Log objects
    - Returns [info,out,log,cmd_list]
    '''
    try:### ~ [1] ~ Initial Command Setup & Info ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        info = makeInfo()                                   # Sets up Info object with program details
        cmd_list = rje.getCmdList(sys.argv[1:],info=info)   # Reads arguments and load defaults from program.ini
        out = rje.Out(cmd_list=cmd_list)                    # Sets up Out object for controlling output to screen
        out.verbose(2,2,cmd_list,1)                         # Prints full commandlist if verbosity >= 2 
        out.printIntro(info)                                # Prints intro text using details from Info object
        cmd_list = cmdHelp(info,out,cmd_list)               # Shows commands (help) and/or adds commands from user
        log = rje.setLog(info,out,cmd_list)                 # Sets up Log object for controlling log file output
        return (info,out,log,cmd_list)                      # Returns objects for use in program
    except SystemExit: sys.exit()
    except KeyboardInterrupt: sys.exit()
    except: print 'Problem during initial setup.'; raise
#########################################################################################################################
### END OF SECTION I                                                                                                    #
#########################################################################################################################

                                                    ### ~ ### ~ ###

#########################################################################################################################
### SECTION II: SAMtools Class                                                                                          #
#########################################################################################################################
class SAMtools(rje_obj.RJE_Object):     
    '''
    Class. Author: Rich Edwards (2012).

    Str:str
    - MutPileup = MPileup results for mutant genome resequencing [None]
    - WTPileup = MPileup results for wildtype genome resequencing [None]
    - RefSeq = String of the reference sequence used for Pileup []

    Bool:boolean
    - IgnoreN = Whether to exclude "N" calls for major/minor alleles [True]
    - MajDif = Whether to restrict output and stats to positions with Major Allele differences [True]

    Int:integer
    - QCut = Min. quality score for a call to include [40]

    Num:float
    - MinFreq = Minor allele(s) frequency correction for zero counts (e.g. Sequencing error) [0.01]
    
    List:list
    - SNPTables = List of files with existing SNPs to map
    - WTMajor = List of the Major alleles for the wildtype

    Dict:dictionary    

    Obj:RJE_Objects
    '''
#########################################################################################################################
    ### <1> ### Class Initiation etc.: sets attributes                                                                  #
#########################################################################################################################
    def _setAttributes(self):   ### Sets Attributes of Object
        '''Sets Attributes of Object.'''
        ### ~ Basics ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        self.strlist = ['MutPileup','WTPileup','RefSeq']
        self.boollist = ['IgnoreN','MajDif']
        self.intlist = ['QCut']
        self.numlist = ['MinFreq']
        self.listlist = ['SNPTables','WTMajor']
        self.dictlist = []
        self.objlist = []
        ### ~ Defaults ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        self._setDefaults(str='None',bool=False,int=0,num=0.0,obj=None,setlist=True,setdict=True)
        self.setStr({'RefSeq':''})
        self.setBool({'IgnoreN':True,'MajDif':True})
        self.setInt({'QCut':40})
        self.setNum({'MinFreq':0.001})
        ### ~ Other Attributes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        self._setForkAttributes()   # Delete if no forking
#########################################################################################################################
    def _cmdList(self):     ### Sets Attributes from commandline
        '''
        Sets attributes according to commandline parameters:
        - see .__doc__ or run with 'help' option
        '''
        for cmd in self.cmd_list:
            try:
                self._generalCmd(cmd)   ### General Options ### 
                self._forkCmd(cmd)  # Delete if no forking
                ### Class Options (No need for arg if arg = att.lower()) ### 
                #self._cmdRead(cmd,type='str',att='Att',arg='Cmd')  # No need for arg if arg = att.lower()
                #self._cmdReadList(cmd,'str',['Att'])   # Normal strings
                #self._cmdReadList(cmd,'path',['Att'])  # String representing directory path 
                self._cmdReadList(cmd,'file',['MutPileup','WTPileup'])  # String representing file path 
                self._cmdReadList(cmd,'bool',['IgnoreN','MajDif'])  # True/False Booleans
                self._cmdReadList(cmd,'int',['QCut'])   # Integers
                self._cmdReadList(cmd,'float',['MinFreq']) # Floats
                #self._cmdReadList(cmd,'min',['Att'])   # Integer value part of min,max command
                #self._cmdReadList(cmd,'max',['Att'])   # Integer value part of min,max command
                #self._cmdReadList(cmd,'list',['Att'])  # List of strings (split on commas or file lines)
                #self._cmdReadList(cmd,'clist',['Att']) # Comma separated list as a *string* (self.str)
                self._cmdReadList(cmd,'glist',['SNPTables']) # List of files using wildcards and glob
                #self._cmdReadList(cmd,'cdict',['Att']) # Splits comma separated X:Y pairs into dictionary
                #self._cmdReadList(cmd,'cdictlist',['Att']) # As cdict but also enters keys into list
            except: self.errorLog('Problem with cmd:%s' % cmd)
#########################################################################################################################
    ### <2> ### Main Class Backbone                                                                                     #
#########################################################################################################################
    def run(self):  ### Main run method
        '''Main run method.'''
        try:### ~ [1] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.setup()
            ### ~ [2] ~ Add main run code here ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.pileUpStats()
            self.combineSNPs()
        except:
            self.errorLog(rje_zen.Zen().wisdom())
            raise   # Delete this if method error not terrible
#########################################################################################################################
    def setup(self):    ### Main class setup method.
        '''Main class setup method.'''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.obj['DB'] = rje_db.Database(self.log,self.cmd_list+['tuplekeys=T'])
            if self.baseFile().lower() in ['','none']: self.baseFile('%s.vs.%s.Q%d' % (rje.baseFile(self.getStr('MutPileup'),True),rje.baseFile(self.getStr('WTPileup'),True),self.getInt('QCut')))
            if not self.force() and os.path.exists('%s.fdr.tdt' % self.baseFile()): return
            ### ~ [2] Look for/process WT Data ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            if self.force() or not os.path.exists('%s.WT.tdt' % self.baseFile()): self.parsePileup('WT',self.getStr('WTPileup'))
            ### ~ [3] Generate Reference sequences and Major Alleles (by locus) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            refseq = {}; rx = 0
            majors = {}
            locus = None
            WTDATA = open('%s.WT.tdt' % self.baseFile(),'r'); wx = 0
            for line in WTDATA:
                self.progLog('\r#WT','Reading WT data: Reference seq length = %s nt' % (rje.iStr(rx)),rand=0.01)
                data = rje.readDelimit(line); wx += 1
                if data[0] == 'Locus': continue
                else:
                    if data[0] != locus: locus = data[0]; refseq[locus] = ''; majors[locus] = []
                    pos = int(data[1])
                    while (pos - 1) > len(refseq[locus]): refseq[locus] += '?'; rx += 1
                    while (pos - 1) > len(majors[locus]): majors[locus].append('-')
                    refseq[locus] += data[2]; majors[locus].append(data[5]); rx += len(data[2])
            WTDATA.close()
            self.printLog('\r#WT','%s lines read from WT data: Reference seq length = %s nt' % (rje.iStr(wx),rje.iStr(rx)))
            for locus in rje.sortKeys(majors):
                if len(majors[locus]) != len(refseq[locus]): self.errorLog('%s WTMajor versus RefSeq length mismatch!' % locus,printerror=False); raise ValueError
            self.dict['WTMajor'] = majors
            self.dict['RefSeq'] = refseq
            ### ~ [3] Look for/process Mutant Data ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            if self.force() or not os.path.exists('%s.Mut.tdt' % self.baseFile()): self.parsePileup('Mut',self.getStr('MutPileup'),True)
            return True     # Setup successful
        except: self.errorLog('Problem during %s setup.' % self); return False  # Setup failed
#########################################################################################################################
    ### <3> ### Additional Class Methods                                                                                #
#########################################################################################################################
    def parsePileup(self,tname,filename,wtdb=None):  ### Extracts, filters and processes PileUp data
        '''Extracts, filters and processes PileUp data.'''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            table = self.db().addEmptyTable(tname,['Locus','Pos','Seq','N','QN','Major','MajFreq'],keys=['Locus','Pos'])
            qc = []
            if wtdb: table.addField('WTFreq')
            PILEUP = open(filename,'r'); px = 0; ex = 0
            PILEOUT = open('%s.%s.tdt' % (self.baseFile(),tname),'w')
            rje.writeDelimit(PILEOUT,outlist=table.fields(),delimit='\t')
            locus = None
            refseq = ''     #? What is this used for?
            majors = []     #? What is this used for?
            ### ~ [2] Process each entry ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            for line in PILEUP:
                data = string.split(rje.chomp(line))
                if not data: break
                self.progLog('\r#PARSE','Parsing %s: %s pos...' % (filename,rje.iStr(px)),rand=0.01); px += 1
                ## ~ [2a] Extract Read Data ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                entry = {'Locus':data[0],'Pos':int(data[1]),'Seq':data[2],'N':int(data[3]),'QN':0}
                if entry['Locus'] != locus: locus = entry['Locus']; refseq = ''; majors = []
                refseq += data[2]
                #entry => 'Ref','Pos','Seq','N','Reads','Qual'
                rseq = data[4]
                reads = []
                delx = 0
                while rseq:                    
                    try:
                        if rseq[:1] in ['.',',']: reads.append(entry['Seq']); rseq = rseq[1:]
                        elif rseq[:1] == '^': rseq = rseq[2:]
                        #elif rseq[:1] == '*':
                        #    reads.append('-1%s' % entry['Seq'].upper())
                        #    rseq = rseq[1:]
                        elif rseq[:1] in ['-','+']:
                            ilen = string.atoi(rje.matchExp('^(\d+)',rseq[1:])[0])
                            indel = rseq[len('%s' % ilen)+1:][:ilen]
                            #self.deBug('%s: %s' % (rseq,indel))
                            if rseq[:1] == '-':
                                delx += 1
                                reads.append(rseq[:len('%s' % ilen)+ilen+1].upper())
                            else:
                                reads[-1] += indel.upper()
                            #self.deBug(reads[-1])
                            rseq = rseq[len('%s' % ilen)+ilen+1:]
                        elif rseq[:1] in ['$']: rseq = rseq[1:]
                        else:
                            if rseq[0].upper() not in 'ATGCN*': print ' ???', rseq[0].upper(), '???'
                            reads.append(rseq[0].upper()); rseq = rseq[1:]
                    except:
                        self.errorLog('!')
                        self.deBug(rseq)
                        raise ValueError
                if len(reads) != (entry['N'] + delx):
                    self.deBug('%s = %d' % (data[4],entry['N']))
                    self.deBug('%s = %d' % (reads,len(reads)))
                    self.errorLog('Read versus Read Count mismatch for %s Pos %s' % (table.name(),entry['Pos']),printerror=False)
                    raise ValueError
                ## ~ [2b] Convert Quality Scores ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                qual = []
                for q in data[5]:
                    while len(qual) < len(reads) and reads[len(qual)][0] == '-': qual.append(self.getInt('QCut'))
                    qual.append(ord(q) - 33)
                    qc += [0] * (qual[-1] - len(qc)); qc[qual[-1]-1] += 1
                while len(qual) < len(reads) and reads[len(qual)][0] == '-': qual.append(self.getInt('QCut'))
                while '*' in reads: reads[reads.index('*')] = '-'   #'-1%s' % entry['Seq'].upper()
                if len(reads) != len(qual):
                    self.deBug('%s = %d' % (reads,len(reads)))
                    self.deBug('%s = %d' % (qual,len(qual)))
                    self.deBug(data)
                    self.errorLog('Read versus Quality length mismatch for %s Pos %s' % (table.name(),entry['Pos']),printerror=False)
                    raise ValueError
                ## ~ [2c] Filter low quality ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                if entry['Pos'] in [190359]:    #100,98901,183697,169284,
                    self.deBug(qual)
                    self.deBug(reads)
                    self.deBug(qc)
                for r in range(len(qual)-1,-1,-1):
                    if qual[r] < self.getInt('QCut'): qual.pop(r); reads.pop(r)
                entry['QN'] = len(reads)
                ## ~ [2d] Major Allele ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                alleles = {}
                if reads: major = reads[0]
                else: major = '-'; alleles[major] = 0
                for read in reads:
                    if read in alleles: alleles[read] += 1
                    else: alleles[read] = 1
                    if alleles[read] > alleles[major] or (read == entry['Seq'] and alleles[read] == alleles[major]): major = read
                entry['Major'] = major
                majors.append(major)
                if reads: entry['MajFreq'] = 1.0 - max(self.getNum('MinFreq'),(len(reads) - alleles[major]) / float(len(reads)))
                else: entry['MajFreq'] = 0.0
                if wtdb:
                    try:
                        wtmajor = self.dict['WTMajor'][locus][entry['Pos']-1]
                        if wtmajor in alleles and reads: entry['WTFreq'] = 1.0 - max(self.getNum('MinFreq'),(len(reads) - alleles[wtmajor]) / float(len(reads)))
                        else: entry['WTFreq'] = 0.0
                    except: self.warnLog('WTFreq Error (%s:Pos=%d) [Probably no WT read mapped]' % (locus,entry['Pos'])); entry['WTFreq'] = 0.0
                if entry['Pos'] in [190359]:    #100,98901,183697,169284,
                    self.deBug(qual)
                    self.deBug(reads)
                    self.deBug(alleles)
                    self.deBug(entry)
                    self.deBug(line)
                #table.addEntry(entry)
                outlist = []
                for field in table.fields(): outlist.append(entry[field])
                rje.writeDelimit(PILEOUT,outlist,delimit='\t'); ex += 1
            self.printLog('\r#PARSE','Parsed %s: %s entries from %s lines.' % (filename,rje.iStr(ex),rje.iStr(px)))
            PILEOUT.close()
            PILEUP.close()
            ### ~ [3] Save QC ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            QC = open('%s.%s.QC.tdt' % (self.baseFile(),tname),'w')
            QC.write('Qual\tCount\n')
            for q in range(len(qc)):
                try: QC.write('%d\t%d\n' % (q+1,qc[q]))
                except: self.errorLog('!')
            QC.close()
            return table
        except: self.errorLog('%s.parsePileup(%s) error' % (self,filename)); return None
#########################################################################################################################
    def pileUpStats(self):  ### Calculates statistics of genetic differences from parsed PileUp Tables
        '''Calculates statistics of genetic differences from parsed PileUp Tables.'''
        try:### ~ [0] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            statfile = '%s.pdiff.tdt' % self.baseFile()
            if not self.force() and os.path.exists(statfile): return self.pileUpFDR()
            ## ~ [0a] Load WT Data ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            wtdata = {}     # Load lists of data for compiling
            for locus in self.dict['RefSeq']:
                wtdata[locus] = {}
                for field in ['N','QN','MajFreq']: wtdata[locus][field] = []
            WTDATA = open('%s.WT.tdt' % self.baseFile(),'r'); wx = 1
            fields = []
            for line in WTDATA:
                data = rje.readDelimit(line)
                if fields:
                    locus = data[0]
                    pos = int(data[1])
                    while pos > wx:
                        wtdata[locus]['N'].append(0); wtdata[locus]['QN'].append(0); wtdata[locus]['MajFreq'].append(0.0); wx += 1
                    for field in ['N','QN']: wtdata[locus][field].append(int(data[fields.index(field)]))
                    for field in ['MajFreq']: wtdata[locus][field].append(string.atof(data[fields.index(field)]))
                    wx += 1
                else: fields = data[0:]
            WTDATA.close()
            ## ~ [0b] Load WT Data ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            mutdata = {}     # Load lists of data for compiling
            for locus in self.dict['RefSeq']:
                mutdata[locus] = {}
                for field in ['N','QN','Major','MajFreq','WTFreq']: mutdata[locus][field] = []
            MUTDATA = open('%s.Mut.tdt' % self.baseFile(),'r'); mx = 1
            fields = []
            for line in MUTDATA:
                data = rje.readDelimit(line)
                if fields:
                    locus = data[0]
                    self.str['RefSeq'] = self.dict['RefSeq'][locus]
                    pos = int(data[1])
                    try:
                        if pos > len(self.str['RefSeq']):
                            while (pos-1) > len(self.str['RefSeq']): self.str['RefSeq'] += '?'
                            self.str['RefSeq'] += data[2]
                            self.dict['RefSeq'][locus] = self.str['RefSeq']
                        elif self.str['RefSeq'][pos-1] == '?':
                            self.str['RefSeq'] = self.str['RefSeq'][:pos-1] + data[2] + self.str['RefSeq'][pos:]
                            self.dict['RefSeq'][locus] = self.str['RefSeq']
                    except: self.warnLog('Problem mapping Pos %s onto %snt %s RefSeq' % (rje.iStr(pos),locus,rje.iLen(self.str['RefSeq'])))
                    while pos > mx:
                        mutdata[locus]['N'].append(0); mutdata[locus]['QN'].append(0); mutdata[locus]['Major'].append('-'); mutdata[locus]['MajFreq'].append(0.0); mutdata[locus]['WTFreq'].append(0.0); mx += 1
                    for field in ['N','QN']: mutdata[locus][field].append(int(data[fields.index(field)]))
                    for field in ['MajFreq','WTFreq']: mutdata[locus][field].append(string.atof(data[fields.index(field)]))
                    for field in ['Major']: mutdata[locus][field].append(data[fields.index(field)])
                    mx += 1
                else: fields = data[0:]
            MUTDATA.close()
            ## ~ [0c] Integrity check ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            #!# Need a new check with locus info #!#
            #for field in wtdata:    #!# Won't be true - not all reference genome positions present in output (0 mapped reads)
            #    if len(wtdata[field]) != len(self.str['RefSeq']): self.errorLog('Data length mismatch for WT %s' % field,printerror=False); raise ValueError
            #for field in mutdata:    #!# Won't be true - not all reference genome positions present in output (0 mapped reads)
            #    if len(mutdata[field]) != len(self.str['RefSeq']): self.errorLog('Data length mismatch for Mutant %s' % field,printerror=False); raise ValueError
            #self.printLog('#REF','WT and Mutant data for %s reference positions' % rje.iLen(self.str['RefSeq']))
            ### ~ [1] Assess and output ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            SAMSIG = open('%s.pdiff.tdt' % self.baseFile(),'w')
            headers = ['Locus','Pos','Ref','WT.N','WT.QN','WT.Major','WT.MajFreq','Mut.N','Mut.QN','Mut.Major','Mut.MajFreq','Mut.WTFreq','p.Over','p.Under','p.Diff']
            SAMSIG.write('%s\n' % string.join(headers,'\t'))
            for locus in rje.sortKeys(self.dict['RefSeq']):
                self.str['RefSeq'] = self.dict['RefSeq'][locus]
                self.list['WTMajor'] = self.dict['WTMajor'][locus]
                for i in range(len(self.str['RefSeq'])):
                    try:
                        sigdata = [locus,i+1,self.str['RefSeq'][i],wtdata[locus]['N'][i],wtdata[locus]['QN'][i],self.list['WTMajor'][i],wtdata[locus]['MajFreq'][i],
                                   mutdata[locus]['N'][i],mutdata[locus]['QN'][i],mutdata[locus]['Major'][i],mutdata[locus]['MajFreq'][i],mutdata[locus]['WTFreq'][i]]
                    except: self.warnLog('Incomplete data for %s:%s (no pdiff output)' % (locus,rje.iStr(i+1))); continue
                    if self.getBool('MajDif') and self.list['WTMajor'][i] == mutdata[locus]['Major'][i]: sigdata += [1.0,1.0]
                    elif not wtdata[locus]['MajFreq'][i]:    # No Data for WT
                        if mutdata[locus]['WTFreq'][i]: sigdata += [0.0,1.0]
                        else: sigdata += [1.0,1.0]
                    elif mutdata[locus]['WTFreq'][i] > wtdata[locus]['MajFreq'][i]:
                        obs = int((mutdata[locus]['QN'][i] * mutdata[locus]['WTFreq'][i]) + 0.5)
                        sigdata.append(rje.binomial(obs,mutdata[locus]['QN'][i],wtdata[locus]['MajFreq'][i],usepoisson=False,callobj=self))
                        sigdata.append(1.0)
                    elif mutdata[locus]['WTFreq'][i] < wtdata[locus]['MajFreq'][i]:
                        obs = int((mutdata[locus]['QN'][i] * mutdata[locus]['WTFreq'][i]) + 0.5)
                        sigdata.append(1.0)
                        sigdata.append(1.0 - rje.binomial(obs+1,mutdata[locus]['QN'][i],wtdata[locus]['MajFreq'][i],usepoisson=False,callobj=self))
                    else: sigdata += [1.0,1.0]
                    sigdata.append(min(1.0,2*min(sigdata[-2:])))
                    rje.writeDelimit(SAMSIG,sigdata)
            SAMSIG.close()
            ### ~ [2] FDR Correction ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.pileUpFDR()
        except: self.errorLog('%s.pileUpStats() error' % (self)); return None
#########################################################################################################################
    def pileUpFDR(self):  ### Calculates statistics of genetic differences from parsed PileUp Tables
        '''Calculates statistics of genetic differences from parsed PileUp Tables.'''
        try:### ~ [0] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            fdrfile = '%s.fdr.tdt' % self.baseFile()
            if not self.force() and os.path.exists(fdrfile): return 
            sigpval = {}    # pval:[fpos]
            npos = 0; nx = 0
            for locus in rje.sortKeys(self.dict['RefSeq']):
                npos += len(self.dict['RefSeq'][locus]) - self.dict['RefSeq'][locus].count('?')
            ### ~ [1] Parse out stats ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            SAMSIG = open('%s.pdiff.tdt' % self.baseFile(),'r')
            headers = string.split(SAMSIG.readline()) + ['p.FDR']
            fpos = SAMSIG.tell(); fline = SAMSIG.readline(); px = 0
            while fline:
                self.progLog('\r#SIG','Reading Pvalues: %s p <= 0.05...' % rje.iStr(px))
                try: pval = float(string.split(fline)[-1])
                except: break
                if pval <= 0.05:
                    if pval not in sigpval: sigpval[pval] = []
                    sigpval[pval].append(fpos); px += 1
                fpos = SAMSIG.tell(); fline = SAMSIG.readline()
            self.printLog('\r#SIG','Reading Pvalues complete: %s p <= 0.05.' % rje.iStr(px))
            ### ~ [2] Calculate FDR and output ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            SAMFDR = open(fdrfile,'w')
            rje.writeDelimit(SAMFDR, headers)
            px = 0; sx = 0.0; stot = len(sigpval)
            for pval in rje.sortKeys(sigpval):
                self.progLog('\r#FDR','Calculating FDR: %.2f%%' % (sx/stot)); sx += 100.0
                px += len(sigpval[pval])
                if pval: fdr = (pval * npos) / px
                else: fdr = 0.0
                for fpos in sigpval[pval]:
                    SAMSIG.seek(fpos)
                    rje.writeDelimit(SAMFDR,rje.readDelimit(SAMSIG.readline())+[rje.expectString(fdr)])
            SAMSIG.close()
            SAMFDR.close()
            self.printLog('\r#FDR','%s FDR lines output to %s' % (rje.iStr(px),fdrfile))
        except: self.errorLog('%s.pileUpFDR() error' % (self)); return None
#########################################################################################################################
    def combineSNPs(self):  ### Calculates statistics of genetic differences from parsed PileUp Tables
        '''Calculates statistics of genetic differences from parsed PileUp Tables.'''
        try:### ~ [0] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            if not self.list['SNPTables']: self.printLog('\r#SNP','No SNP tables to add.'); return False
            fdb = self.db().addTable(name='fdr',expect=True,mainkeys=['Locus','Pos'])
            fdb.remakeKeys()   #!# Delete once tuple thing OK
            fdbkeys = fdb.dataKeys()
            self.debug(fdbkeys[:100])
            snps = []
            snppos = []
            for snptable in self.list['SNPTables']:
                snps.append(self.db().addTable(snptable,name=rje.baseFile(snptable,True),expect=True,mainkeys=['Locus','Pos']))
                snps[-1].addField('SNP',evalue="YES")
                self.debug(snps[-1].dataKeys()[:100])
                snps[-1].remakeKeys()   #!# Delete once tuple thing OK
                self.debug(snps[-1].dataKeys()[:100])
                px = 0; ptot = snps[-1].entryNum(); sx = 0
                for pos in snps[-1].dataKeys(): # This should be a (Locus,Pos) tuple
                    self.progLog('\r#SNP','Scanning %s for extra SNP positions: %.2f%%' % (snps[-1].name(),px/ptot)); px += 100.0
                    if pos not in snppos + fdbkeys: snppos.append(pos); sx += 1
                self.printLog('\r#SNP','Scanned %s for extra SNP positions: %s to add.' % (snps[-1].name(),rje.iStr(sx)))
            ## ~ [0a] Add missing data from other tables ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if snppos:
                SAMSIG = open('%s.pdiff.tdt' % self.baseFile(),'r'); px = 0; ptot = len(snppos); ix = 0
                fline = SAMSIG.readline(); headers = rje.readDelimit(fline)
                fline = SAMSIG.readline()
                self.progLog('\r#SNP','%s/%s SNP positions added from %s PDiff filelines.' % (rje.iStr(px),rje.iStr(ptot),rje.iStr(ix)))
                while fline:
                    data = rje.readDelimit(fline); ix += 1
                    if (data[0],data[1]) in snppos:
                        entry = {'p.FDR':'-'}
                        for i in range(len(data)): entry[headers[i]] = data[i]
                        fdb.addEntry(entry); px += 1
                        snppos.remove((data[0],data[1]))
                        self.progLog('\r#SNP','%s/%s SNP positions added from %s PDiff filelines.' % (rje.iStr(px),rje.iStr(ptot),rje.iStr(ix)))
                    else: self.progLog('\r#SNP','%s/%s SNP positions added from %s PDiff filelines.' % (rje.iStr(px),rje.iStr(ptot),rje.iStr(ix)))
                    if not snppos: break
                    fline = SAMSIG.readline()
                SAMSIG.close()
                self.printLog('\r#SNP','%s/%s SNP positions added from PDiff file.' % (rje.iStr(px),rje.iStr(ptot)))
            else: self.printLog('\r#SNP','No SNP positions to add.'); return False

            ### ~ [1] Join Tables ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            temp = fdb
            temp.makeField('#Locus#|#Pos#')
            for snptable in snps:
                snptable.makeField('#Locus#|#Pos#')
                newtemp = self.db().joinTables(name='newtemp',join=[(temp,'#Locus#|#Pos#'),(snptable,'#Locus#|#Pos#',['SNP'])],newkey=['Locus','Pos'],keeptable=True)
                self.printLog('#SNP','Added SNPs from %s' % snptable.name())
                self.db().deleteTable(temp)
                temp = newtemp
                temp.renameField('SNP',snptable.name())
                temp.setStr({'Name':'temp'})
            temp.dropField('#Locus#|#Pos#')
            self.db().list['Tables'].append(temp)
            temp.setStr({'Name':'SNPs'})
            temp.saveToFile()
            return temp
        except: self.errorLog('%s.pileUpStats() error' % (self)); return None
#########################################################################################################################
### End of SECTION II: SAMtools Class                                                                                   #
#########################################################################################################################

                                                    ### ~ ### ~ ###

#########################################################################################################################
### SECTION III: MODULE METHODS                                                                                         #
#########################################################################################################################

#########################################################################################################################
### END OF SECTION III                                                                                                  #
#########################################################################################################################

                                                    ### ~ ### ~ ###

#########################################################################################################################
### SECTION IV: MAIN PROGRAM                                                                                            #
#########################################################################################################################
def runMain():
    ### ~ [1] ~ Basic Setup of Program  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    try: (info,out,mainlog,cmd_list) = setupProgram()
    except SystemExit: return  
    except: print 'Unexpected error during program setup:', sys.exc_info()[0]; return
    
    ### ~ [2] ~ Rest of Functionality... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    try: SAMtools(mainlog,cmd_list).run()

    ### ~ [3] ~ End ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    except SystemExit: return  # Fork exit etc.
    except KeyboardInterrupt: mainlog.errorLog('User terminated.')
    except: mainlog.errorLog('Fatal error in main %s run.' % info.program)
    mainlog.printLog('#LOG', '%s V:%s End: %s\n' % (info.program,info.version,time.asctime(time.localtime(time.time()))))
#########################################################################################################################
if __name__ == "__main__":      ### Call runMain 
    try: runMain()
    except: print 'Cataclysmic run error:', sys.exc_info()[0]
    sys.exit()
#########################################################################################################################
### END OF SECTION IV                                                                                                   #
#########################################################################################################################
