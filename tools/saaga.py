#!/usr/bin/python

# See below for name and description
# Copyright (C) 2016 Richard J. Edwards <redwards@cabbagesofdoom.co.uk>
#  
# This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program; if not, write to 
# the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# Author contact: <seqsuite@gmail.com> / School of Biotechnology and Biomolecular Sciences, UNSW, Sydney, Australia.
#
# To incorporate this module into your own programs, please see GNU Lesser General Public License disclaimer in rje.py

"""
Module:       SAAGA
Description:  Summarise, Annotate & Assess Genome Annotations
Version:      0.7.7
Last Edit:    25/11/21
Citation:     Edwards RJ et al. (2021), BMC Genomics 22, 188 https://doi.org/10.1186/s12864-021-07493-6
Assess Citation:  Stuart KC et al. (2021), bioRvix https://doi.org/10.1101/2021.04.07.438753
GitHub:       http://github.com/slimsuite/saaga
Copyright (C) 2020  Richard J. Edwards - See source code for GNU License Notice

Function:
    SAAGA is a tool for summarising, annotating and assessing genome annotations, with a particular focus on annotation
    generated by GeMoMa. The core of SAAGA is reciprocal MMeqs searches of the annotation and reference proteomes. These
    are used to identify the best hits for protein product identification and to assess annotations based on query and
    hit coverage. SAAGA will also generate annotation summary statistics, and extract the longest protein from each gene
    for a representative non-redundant proteome (e.g. for BUSCO analysis).

Run modes:

    assess = Assess annotation using reference annotation (e.g. a reference organism proteome)
    annotate = Rename annotation using reference annotation (could be Swissprot)
    longest = Extract the longest protein per gene
    mmseq = Run the mmseq2 steps in preparation for further analysis
    summarise = Summarise annotation from GFF file
    taxonomy = Summarise taxonomic assignments for contamination assessments (Taxolotl)

Commandline:
    ### ~ Input/Output options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    seqin=FILE      : Protein annotation file to assess [annotation.faa]
    gffin=FILE      : Protein annotation GFF file [annotation.gff]
    cdsin=FILE      : Optional transcript annotation file for renaming and/or longest isoform extraction [annotation.fna]
    assembly=FILE   : Optional genome fasta file (required for some outputs) [None]
    refprot=FILE    : Reference proteome for mapping data onto [refproteome.fasta]
    refdb=FILE      : Reference proteome MMseqs2 database (over-rules mmseqdb path) []
    mmseqdb=PATH    : Directory in which to find/create MMseqs2 databases [./mmseqdb/]
    mmsearch=PATH   : Directory in which to find/create MMseqs2 databases [./mmsearch/]
    basefile=X      : Prefix for output files [$SEQBASE.$REFBASE]
    gffgene=X       : Label for GFF gene feature type ['gene']
    gffcds=X        : Label for GFF CDS feature type ['CDS']
    gffmrna=X       : Label for GFF mRNA feature type ['mRNA']
    gffdesc=X       : GFF output field label for annotated proteins (e.g. note, product) [product]
    ### ~ Run mode options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    annotate=T/F    : Rename annotation using reference annotation (could be Swissprot) [False]
    assess=T/F      : Assess annotation using reference annotation [False]
    longest=T/F     : Extract longest protein per gene into *.longest.faa [False]
    mmseqs=T/F      : Run the MMseqs2 steps in preparation for further analysis [True]
    summarise=T/F   : Summarise annotation from GFF file [True]
    taxonomy=T/F    : Summarise taxonomic assignments for contamination assessments (Taxolotl) [False]
    dochtml=T/F     : Generate HTML SAAGA documentation (*.docs.html) instead of main run [False]
    ### ~ Search and filter options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    tophits=INT     : Restrict mmseqs hits to the top X hits [250]
    minglobid=PERC  : Minimum global query percentage identity for a hit to be kept [40.0]
    ### ~ Precomputed MMSeq2 options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    mmqrymap=TSV    : Tab-delimited output for query versus reference search (see docs) [$SEQBASE.$REFBASE.mmseq.tsv]
    mmhitmap=TSV    : Tab-delimited output for reference versus query search (see docs) [$REFBASE.$SEQBASE.mmseq.tsv]
    ### ~ Batch Run options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    batchseq=FILELIST   : List of seqin=FILE annotation proteomes for comparison
    batchref=FILELIST   : List of refprot=FILE reference proteomes for comparison
    ### ~ Taxonomy options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    taxdb=FILE      : MMseqs2 taxonomy database for taxonomy assignment [seqTaxDB]
    taxbase=X       : Output prefix for taxonomy output [$SEQBASE.$TAXADB]
    taxorfs=T/F     : Whether to generate ORFs from assembly if no seqin=FILE given [True]
    taxbyseq=T/F    : Whether to parse and generate taxonomy output for each assembly (GFF) sequence [True]
    taxbycontig=T/F : Whether to generate taxonomy output for each contig if the assembly is loaded [True]
    taxbyseqfull=T/F: Whether generate full easy taxonomy report outputs for each assembly (GFF) sequence [False]
    taxsubsets=FILELIST : Files (fasta/id) with sets of assembly input sequences (matching GFF) to summarise []
    taxlevels=LIST  : List of taxonomic levels to report (* for superkingdom and below) ['*']
    taxwarnrank=X   : Taxonomic rank (and above) to warn when deviating for consensus [family]
    bestlineage=T/F : Whether to enforce a single lineage for best taxa ratings [True]
    mintaxnum=INT   : Minimum gene count in main dataset to keep taxon, else merge with higher level [2]
    ### ~ System options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    forks=X         : Number of parallel sequences to process at once [0]
    killforks=X     : Number of seconds of no activity before killing all remaining forks. [36000]
    forksleep=X     : Sleep time (seconds) between cycles of forking out more process [0]
    tmpdir=PATH     : Temporary directory path for running mmseqs2 [./tmp/]
    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
"""
#########################################################################################################################
### SECTION I: GENERAL SETUP & PROGRAM DETAILS                                                                          #
#########################################################################################################################
import os, re, string, sys, time
slimsuitepath = os.path.abspath(os.path.join(os.path.dirname(os.path.realpath(__file__)),'../')) + os.path.sep
sys.path.append(os.path.join(slimsuitepath,'libraries/'))
sys.path.append(os.path.join(slimsuitepath,'tools/'))
### User modules - remember to add *.__doc__ to cmdHelp() below ###
import rje, rje_db, rje_gff, rje_obj, rje_rmd, rje_seqlist
#########################################################################################################################
def history():  ### Program History - only a method for PythonWin collapsing! ###
    '''
    # 0.0.0 - Initial Compilation.
    # 0.1.0 - Initial working version. Needs improved documentation.
    # 0.2.0 - Added extra annotation/longest output for CDS and GFF.
    # 0.2.1 - Renamed to SAAGA and tidied some documentation.
    # 0.3.0 - Added some additional hit info to annotation and reworked to allow multiple query-hit pairs.
    # 0.3.1 - Fixed assess bug and sped up GFF parsing.
    # 0.4.0 - Added tophits=X [250] and minglobid=X [40.0] options, plus gobid and hitnum to output.
    # 0.5.0 - Added definitions for gffgene=X, gffcds=X and gffmrna=X. Modified output.
    # 0.5.1 - Tidied some of the code and added some identifier checks for GFF and Fasta input.
    # 0.5.2 - Fixed issue with swapped transcript and exon feature identifiers following v0.5.1 tidying.
    # 0.5.3 - Added pident compatibility with updated mmseq2. Updated documentation. Modified some stats calculations.
    # 0.5.4 - Added restricted feature parsing from GFF. Fixed GFF type input bug.
    # 0.6.0 - Added more graceful failure if no sequences loaded. Added GFF renaming output field options. Fixed GFF output bug.
    # 0.7.0 - Added taxonomy mode for taxonomic summaries and contamination checks.
    # 0.7.1 - Added taxorfs setting to generate ORFs in absence of GFF or protein file.
    # 0.7.2 - Updated docstring. Added rating to lca_genes. Add batchrun for matching seqin/gffin pairs. Added GFF output.
    # 0.7.3 - Fixed lca_genes rating and added taxbycontig=T/F taxonomy output for each contig if the assembly is loaded.
    # 0.7.4 - Updated some of the outputs to Taxolotl rather than SAAGA.
    # 0.7.5 - Added bestlineage=T/F : Whether to enforce a single lineage for best taxa ratings [True]
    # 0.7.6 - Fixed GFF output.
    # 0.7.7 - Fixed contig output for Taxolotl.
    '''
#########################################################################################################################
def todo():     ### Major Functionality to Add - only a method for PythonWin collapsing! ###
    '''
    # [Y] : Populate Module Docstring with basic info.
    # [Y] : Populate makeInfo() method with basic info.
    # [Y] : Add full description of program to module docstring.
    # [Y] : Create initial working version of program.
    # [?] : Add REST outputs to restSetup() and restOutputOrder()
    # [ ] : Add to SLiMSuite or SeqSuite.
    # [ ] : Add option to only update "Protein of unknown function" annotations using single reference or iteratively.
    # [ ] : Move some functionality into a rje_mmseq2.py module?
    # [ ] : Add passing of MMSeqs options to tweak the sensitivity.
    # [?] : Need to separate some of the summarise and assess functions into GFF +/- for batch assessment.
    # [Y] : Add BatchRun options.
    # [ ] : Document BatchRun options.
    # [ ] : Add mmsearchdir to output names to keep things clean. (And option to clean up everything at end)
    # [Y] : Add descriptions to longest output if annotate=True (read output back in as seqin object)
    # [Y] : Add descriptions to GFF and transcript file.
    # [Y] : Speed up the GFF parsing.
    # [Y] : Implement taxonomy mode.
    # [?] : Add taxnoranks=T/F  : Whether to include re-labelled "no rank" or "clade" taxonomic levels in output [False]
    # [ ] : Add loading of assembly and then summary of percentage coverage of gene and coding sequences.
    # [Y] : Add taxbycontig=T/F if the assembly is loaded. (Get contig generation from seqlist or synbad?)
    # [Y] : Add GFF output of taxa ratings withing rating=good/bad/none and note="taxrank:taxid:taxname (taxlineage list)"
    # [Y] : Move Taxonomy functions to new Taxolotl program. Remove SAAGA from taxonomy outputs.
    # [ ] : Fix protein sequence name mapping for taxonomy mode in line with rest of SAAGA.
    # [ ] : Add window and region badtaxa scanning. (Could be useful for HGT detection?)
    # [ ] : Add CAI calculation.
    # [ ] : Tidy up the d.p. output for the stats table.
    '''
#########################################################################################################################
def makeInfo(): ### Makes Info object which stores program details, mainly for initial print to screen.
    '''Makes Info object which stores program details, mainly for initial print to screen.'''
    (program, version, last_edit, copy_right) = ('SAAGA', '0.7.7', 'November 2021', '2020')
    description = 'Summarise, Annotate & Assess Genome Annotations'
    author = 'Dr Richard J. Edwards.'
    comments = ['Citation: Edwards RJ et al. (2021), BMC Genomics 22, 188.',
                'Assess Citation: Stuart KC et al. (2021), bioRvix https://doi.org/10.1101/2021.04.07.438753',
                'GitHub: http://github.com/slimsuite/saaga',rje_obj.zen()]
    return rje.Info(program,version,last_edit,description,author,time.time(),copy_right,comments)
#########################################################################################################################
def cmdHelp(info=None,out=None,cmd_list=[]):   ### Prints *.__doc__ and asks for more sys.argv commands
    '''Prints *.__doc__ and asks for more sys.argv commands.'''
    try:### ~ [1] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        if not info: info = makeInfo()
        if not out: out = rje.Out()
        ### ~ [2] ~ Look for help commands and print options if found ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        cmd_help = cmd_list.count('help') + cmd_list.count('-help') + cmd_list.count('-h')
        if cmd_help > 0:
            rje.printf('\n\nHelp for {0} {1}: {2}\n'.format(info.program, info.version, time.asctime(time.localtime(info.start_time))))
            out.verbose(-1,4,text=__doc__)
            if rje.yesNo('Show general commandline options?',default='N'): out.verbose(-1,4,text=rje.__doc__)
            if rje.yesNo('Quit?'): sys.exit()           # Option to quit after help
            cmd_list += rje.inputCmds(out,cmd_list)     # Add extra commands interactively.
        elif out.stat['Interactive'] > 1: cmd_list += rje.inputCmds(out,cmd_list)    # Ask for more commands
        ### ~ [3] ~ Return commands ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        return cmd_list
    except SystemExit: sys.exit()
    except KeyboardInterrupt: sys.exit()
    except: rje.printf('Major Problem with cmdHelp()')
#########################################################################################################################
def setupProgram(): ### Basic Setup of Program when called from commandline.
    '''
    Basic Setup of Program when called from commandline:
    - Reads sys.argv and augments if appropriate
    - Makes Info, Out and Log objects
    - Returns [info,out,log,cmd_list]
    '''
    try:### ~ [1] ~ Initial Command Setup & Info ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        info = makeInfo()                                   # Sets up Info object with program details
        if len(sys.argv) == 2 and sys.argv[1] in ['version','-version','--version']: rje.printf(info.version); sys.exit(0)
        if len(sys.argv) == 2 and sys.argv[1] in ['details','-details','--details']: rje.printf('{0} v{1}'.format(info.program,info.version)); sys.exit(0)
        if len(sys.argv) == 2 and sys.argv[1] in ['description','-description','--description']: rje.printf('%s: %s' % (info.program,info.description)); sys.exit(0)
        cmd_list = rje.getCmdList(sys.argv[1:],info=info)   # Reads arguments and load defaults from program.ini
        out = rje.Out(cmd_list=cmd_list)                    # Sets up Out object for controlling output to screen
        out.verbose(2,2,cmd_list,1)                         # Prints full commandlist if verbosity >= 2 
        out.printIntro(info)                                # Prints intro text using details from Info object
        cmd_list = cmdHelp(info,out,cmd_list)               # Shows commands (help) and/or adds commands from user
        log = rje.setLog(info,out,cmd_list)                 # Sets up Log object for controlling log file output
        return (info,out,log,cmd_list)                      # Returns objects for use in program
    except SystemExit: sys.exit()
    except KeyboardInterrupt: sys.exit()
    except: rje.printf('Problem during initial setup.'); raise
#########################################################################################################################
dbformats = {'evalue':'num','raw':'int','qlen':'int','tlen':'int','qstart':'int','qend':'int','qcov':'num','tstart':'int','tend':'int','tcov':'num','alnlen':'int','pident':'num'}
#########################################################################################################################
### END OF SECTION I                                                                                                    #
#########################################################################################################################

                                                    ### ~ ### ~ ###

#########################################################################################################################
### SECTION II: SAAGA Class                                                                                             #
#########################################################################################################################
class SAAGA(rje_obj.RJE_Object):
    '''
    SAAGA Class. Author: Rich Edwards (2015).

    Str:str
    - Assembly=FILE   : Optional genome fasta file (required for some outputs) [None]
    - CDSIn=FILE      : Optional transcript annotation file for renaming and/or longest isoform extraction [annotation.fna]
    - GFFIn=FILE      : Protein annotation GFF file [annotation.gff]
    - GFFDesc=X       : GFF output field label for annotated proteins (e.g. note, product) [product]
    - GFFGene=X       : Label for GFF gene feature type ['gene']
    - GFFCDS=X        : Label for GFF CDS feature type ['CDS']
    - GFFmRNA=X       : Label for GFF mRNA feature type ['mRNA']
    - MMHitMap=TSV    : Tab-delimited output for query versus reference MMseq2 search (see docs) [$REFBASE.$SEQBASE.mmseq.tsv]
    - MMQryMap=TSV    : Tab-delimited output for query versus reference MMseq2 search (see docs) [$SEQBASE.$REFBASE.mmseq.tsv]
    - MMSearch=PATH   : Directory in which to find/create mmseqs2 databases [./mmsearch/]
    - MMSeqDB = Directory in which to find/create mmseqs2 databases [./mmseqdb/]
    - RefDB=FILE      : Reference proteome MMseq2 database (over-rule mmseqdb path) []
    - RefProt = Reference proteome for mapping data onto []
    - SeqIn = Protein annotation file to assess [annotation.faa]
    - TaxBase=X       : Output prefix for taxonomy output [$SEQBASE.$TAXADB]
    - TaxDB=FILE      : MMseqs2 taxonomy database for taxonomy assignment [seqTaxDB]
    - TaxWarnRank=X   : Taxonomic rank (and above) to warn when deviating for consensus [family]
    - TmpDir=PATH     : Temporary directory path for running mmseqs2 [./tmp/]

    Bool:boolean
    - Annotate=T/F    : Rename annotation using reference annotation (could be Swissprot) [False]
    - Assess=T/F      : Assess annotation using reference annotation [False]
    - BatchRun=T/F    : Whether to assess batchrun options (set to False for single runs within batch) [True]
    - BestLineage=T/F : Whether to enforce a single lineage for best taxa ratings [True]
    - DocHTML=T/F     : Generate HTML SAAGA documentation (*.info.html) instead of main run [False]
    - Longest=T/F     : Extract longest protein per gene into *.longest.faa [False]
    - MMseqs=T/F      : Run the mmseq2 steps in preparation for further analysis [True]
    - Summarise=T/F   : Summarise annotation from GFF file [True]
    - TaxByContig=T/F : Whether to generate taxonomy output for each contig if the assembly is loaded [True]
    - TaxBySeq=T/F    : Whether to parse and generate taxonomy output for each assembly (GFF) sequence [True]
    - TaxBySeqFull=T/F: Whether generate full easy taxonomy report outputs for each assembly (GFF) sequence [False]
    - Taxonomy=T/F    : Summarise taxonomic assignments for contamination assessments [False]
    - TaxORFs=T/F     : Whether to generate ORFs from assembly if no seqin=FILE given [True]

    Int:integer
    - MinTaxNum=INT   : Minimum gene count in main dataset to keep taxon, else merge with higher level [2]
    - TopHits=INT     : Restrict mmseqs hits to the top X hits [250]

    Num:float
    - MinGlobID=PERC  : Minimum global query percentage identity for a hit to be kept [40.0]

    File:file handles with matching str filenames
    
    List:list
    - BatchSeq=FILELIST   : List of seqin=FILE annotation proteomes for comparison
    - BatchRef=FILELIST   : List of refprot=FILE reference proteomes for comparison
    - TaxLevels=LIST  : List of taxonomic levels to report (* for superkingdom and below) ['*']
    - TaxRanks : Actual taxonomic levels used in the taxonomy analysis (high to low)
    - TaxSubsets=FILELIST : Files (fasta/id) with sets of assembly input sequences (matching GFF) to summarise []

    Dict:dictionary
    - TaxLineage = taxtuple:list of (taxrank,taxid,taxname) in high to low order
    - TaxTuple = taxid:(taxrank,taxid,taxname)

    Obj:RJE_Objects
    - CDSIn = SeqList: Optional transcript annotation file for renaming and/or longest isoform extraction [annotation.fna]
    - DB = Database object
    - GFF = rje_gff.GFF
    - RefProt = SeqList: Reference proteome for mapping data onto []
    - Rmd = RMarkdown control object
    - SeqIn = SeqList: Protein annotation file to assess [predicted_cds.fasta]
    '''
#########################################################################################################################
    ### <1> ### Class Initiation etc.: sets attributes                                                                  #
#########################################################################################################################
    def _setAttributes(self):   ### Sets Attributes of Object
        '''Sets Attributes of Object.'''
        ### ~ Basics ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        self.strlist = ['Assembly','CDSIn','GFFIn','GFFDesc','GFFGene','GFFCDS','GFFmRNA','MMHitMap','MMQryMap','MMSearch',
                        'MMSeqDB','RefDB','RefProt','SeqIn','TaxBase','TaxDB','TaxWarnRank','TmpDir']
        self.boollist = ['Annotate','Assess','BatchRun','BestLineage','DocHTML','Longest','MMseqs','Summarise',
                         'TaxByContig','TaxBySeq','TaxBySeqFull','Taxonomy','TaxORFs']
        self.intlist = ['MinTaxNum','TopHits']
        self.numlist = ['MinGlobID']
        self.filelist = []
        self.listlist = ['BatchSeq','BatchRef','TaxLevels','TaxRanks','TaxSubsets']
        self.dictlist = ['TaxLineage','TaxTuple']
        self.objlist = ['SeqIn','RefProt']
        ### ~ Defaults ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        self._setDefaults(str='None',bool=False,int=0,num=0.0,obj=None,setlist=True,setdict=True,setfile=True)
        self.setStr({'CDSIn':'annotation.fna','GFFGene':'gene','GFFCDS':'CDS','GFFmRNA':'mRNA','GFFDesc':'product',
                     'GFFIn':'annotation.gff','MMSearch':'./mmsearch/','MMSeqDB':'./mmseqdb/',
                     'RefProt':'refproteome.fasta','SeqIn':'annotation.faa',
                     'TaxDB':'seqTaxDB', 'TaxWarnRank':'family',
                     'TmpDir':'./tmp/'})
        self.setBool({'Annotate':False,'Assess':False,'BatchRun':True,'BestLineage':True,'DocHTML':False,'Longest':False,'MMseqs':True,
                      'Summarise':True,'TaxByContig':True,'TaxBySeq':True,'TaxBySeqFull':False,'Taxonomy':False,'TaxORFs':True})
        self.setInt({'MinTaxNum':2,'TopHits':250})
        self.setNum({'MinGlobID':40.0})
        self.list['TaxLevels'] = ['*']
        ### ~ Other Attributes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        self.obj['DB'] = rje_db.Database(self.log,self.cmd_list+['tuplekeys=T'])
        self.obj['GFF'] = rje_gff.GFF(self.log,['attfield=T']+self.cmd_list+['tuplekeys=T','warnfield='])
        self.obj['GFF'].obj['DB'] = self.obj['DB']
        self.obj['Rmd'] = rje_rmd.Rmd(self.log,self.cmd_list)
        self._setForkAttributes()   # Delete if no forking
#########################################################################################################################
    def _cmdList(self):     ### Sets Attributes from commandline
        '''
        Sets attributes according to commandline parameters:
        - see .__doc__ or run with 'help' option
        '''
        for cmd in self.cmd_list:
            try:
                self._generalCmd(cmd)   ### General Options ### 
                self._forkCmd(cmd)  # Delete if no forking
                ### Class Options (No need for arg if arg = att.lower()) ### 
                #self._cmdRead(cmd,type='str',att='Att',arg='Cmd')  # No need for arg if arg = att.lower()
                self._cmdReadList(cmd,'str',['GFFDesc','GFFGene','GFFCDS','GFFmRNA','TaxWarnRank'])   # Normal strings
                self._cmdReadList(cmd,'path',['MMSearch','MMSeqDB','TmpDir'])  # String representing directory path
                self._cmdReadList(cmd,'file',['Assembly','CDSIn','GFFIn','RefDB','RefProt','SeqIn','TaxBase','TaxDB'])  # String representing file path
                #self._cmdReadList(cmd,'date',['Att'])  # String representing date YYYY-MM-DD
                self._cmdReadList(cmd,'bool',['Annotate','Assess','BatchRun','BestLineage','DocHTML','Longest','MMseqs','Summarise','TaxByContig','TaxBySeq','TaxBySeqFull','Taxonomy','TaxORFs'])  # True/False Booleans
                self._cmdRead(cmd,type='bool',att='MMseqs',arg='mmseq')  # No need for arg if arg = att.lower()
                self._cmdRead(cmd,type='bool',att='MMseqs',arg='mmseqs2')  # No need for arg if arg = att.lower()
                self._cmdReadList(cmd,'int',['MinTaxNum','TopHits'])   # Integers
                #self._cmdReadList(cmd,'float',['Att']) # Floats
                self._cmdReadList(cmd,'perc',['MinGlobID']) # Floats
                #self._cmdReadList(cmd,'min',['Att'])   # Integer value part of min,max command
                #self._cmdReadList(cmd,'max',['Att'])   # Integer value part of min,max command
                self._cmdReadList(cmd,'list',['TaxLevels'])  # List of strings (split on commas or file lines)
                #self._cmdReadList(cmd,'clist',['Att']) # Comma separated list as a *string* (self.str)
                self._cmdReadList(cmd,'glist',['BatchSeq','BatchRef','TaxSubsets']) # List of files using wildcards and glob
                #self._cmdReadList(cmd,'cdict',['Att']) # Splits comma separated X:Y pairs into dictionary
                #self._cmdReadList(cmd,'cdictlist',['Att']) # As cdict but also enters keys into list
            except: self.errorLog('Problem with cmd:%s' % cmd)
        if not self.baseFile(return_none=''): self.baseFile('saaga')
#########################################################################################################################
    ### <2> ### Main Class Backbone                                                                                     #
#########################################################################################################################
    def run(self):  ### Main run method
        '''
        # SAAGA: Summarise, Annotate & Assess Genome Annotations

        SAAGA is a tool for summarising, annotating and assessing genome annotations, with a particular focus on annotation
        generated by GeMoMa. The core of SAAGA is reciprocal MMeqs searches of the annotation and reference proteomes. These
        are used to identify the best hits for protein product identification and to assess annotations based on query and
        hit coverage. SAAGA will also generate annotation summary statistics, and extract the longest protein from each gene
        for a representative non-redundant proteome (e.g. for BUSCO analysis).

        Please note that SAAGA is still in development and documentation is currently a bit sparse.

        The different run modes are set using a set of `mode=T/F` flags (or simply adding the run mode to the command):

        * `assess` = Assess annotation using reference annotation (e.g. a reference organism proteome)
        * `annotate` = Rename annotation using reference annotation (could be Swissprot)
        * `longest` = Extract the longest protein per gene
        * `mmseq` = Run the mmseq2 steps in preparation for further analysis (default)
        * `summarise` = Summarise annotation from a GFF file (default)
        * `taxonomy` = Summarise taxonomic assignments for contamination assessments

        See <https://slimsuite.github.io/saaga/> for details of each mode. Multiple modes without conflicting commandline options can be run together. Note that running `taxonomy` mode will switch off the default `mmseq` and `summarise` modes, unless reactivated with additional commands.
        General SLiMSuite run documentation can be found at <https://github.com/slimsuite/SLiMSuite>.

        SAAGA is available as part of SLiMSuite, or via a standalone GitHub repo at
        <https://github.com/slimsuite/saaga>.

        ## Citing SAAGA

        SAAGA `summarise` was introduced with basic annotation summarise functions (v0.4.0) in:

        * Edwards RJ et al. (2021), [BMC Genomics 22, 188](https://doi.org/10.1186/s12864-021-07493-6).

        For `assess` mode (v0.6.0), please cite:

        * Stuart KC et al. (2021), bioRvix https://doi.org/10.1101/2021.04.07.438753. This forms the basis of the explanation for some of the statistics, below.

        ---

        # Running SAAGA

        SAAGA is written in Python 2.x and can be run directly from the commandline:

            python $CODEPATH/saaga.py [OPTIONS]

        If running as part of [SLiMSuite](http://slimsuite.blogspot.com/), `$CODEPATH` will be the SLiMSuite `tools/`
        directory. If running from the standalone [SAAGA git repo](https://github.com/slimsuite/saaga), `$CODEPATH`
        will be the path the to `code/` directory. Please see details in the [SAAGA git repo](https://github.com/slimsuite/saaga)
        for running on example data.

        For `assess`, `annotate`, `mmseq` and `taxonomy` modes, [MMseqs2](https://github.com/soedinglab/MMseqs2) must be installed and
        either added to the environment `$PATH`.

        ## Commandline options

        A list of commandline options can be generated at run-time using the `-h` or `help` flags. Please see the general
        [SLiMSuite documentation](http://slimsuite.blogspot.com/2013/08/command-line-options.html) for details of how to
        use commandline options, including setting default values with **INI files**.

        ```
        ### ~ Input/Output options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        seqin=FILE      : Protein annotation file to assess [annotation.faa]
        gffin=FILE      : Protein annotation GFF file [annotation.gff]
        cdsin=FILE      : Optional transcript annotation file for renaming and/or longest isoform extraction [annotation.fna]
        assembly=FILE   : Optional genome fasta file (required for some outputs) [None]
        refprot=FILE    : Reference proteome for mapping data onto [refproteome.fasta]
        refdb=FILE      : Reference proteome MMseqs2 database (over-rules mmseqdb path) []
        mmseqdb=PATH    : Directory in which to find/create MMseqs2 databases [./mmseqdb/]
        mmsearch=PATH   : Directory in which to find/create MMseqs2 databases [./mmsearch/]
        basefile=X      : Prefix for output files [$SEQBASE.$REFBASE]
        gffgene=X       : Label for GFF gene feature type ['gene']
        gffcds=X        : Label for GFF CDS feature type ['CDS']
        gffmrna=X       : Label for GFF mRNA feature type ['mRNA']
        gffdesc=X       : GFF output field label for annotated proteins (e.g. note, product) [product]
        ### ~ Run mode options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        annotate=T/F    : Rename annotation using reference annotation (could be Swissprot) [False]
        assess=T/F      : Assess annotation using reference annotation [False]
        longest=T/F     : Extract longest protein per gene into *.longest.faa [False]
        mmseqs=T/F      : Run the MMseqs2 steps in preparation for further analysis [True]
        summarise=T/F   : Summarise annotation from GFF file [True]
        taxonomy=T/F    : Summarise taxonomic assignments for contamination assessments [False]
        dochtml=T/F     : Generate HTML SAAGA documentation (*.docs.html) instead of main run [False]
        ### ~ Search and filter options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        tophits=INT     : Restrict mmseqs hits to the top X hits [250]
        minglobid=PERC  : Minimum global query percentage identity for a hit to be kept [40.0]
        ### ~ Precomputed MMSeq2 options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        mmqrymap=TSV    : Tab-delimited output for query versus reference search (see docs) [$SEQBASE.$REFBASE.mmseq.tsv]
        mmhitmap=TSV    : Tab-delimited output for reference versus query search (see docs) [$REFBASE.$SEQBASE.mmseq.tsv]
        ### ~ Batch Run options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        batchseq=FILELIST   : List of seqin=FILE annotation proteomes for comparison
        batchref=FILELIST   : List of refprot=FILE reference proteomes for comparison
        ### ~ Taxonomy options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        taxdb=FILE      : MMseqs2 taxonomy database for taxonomy assignment [seqTaxDB]
        taxbase=X       : Output prefix for taxonomy output [$SEQBASE.$TAXADB]
        taxorfs=T/F     : Whether to generate ORFs from assembly if no seqin=FILE given [True]
        taxbyseq=T/F    : Whether to parse and generate taxonomy output for each assembly (GFF) sequence [True]
        taxbyseqfull=T/F: Whether generate full easy taxonomy report outputs for each assembly (GFF) sequence [False]
        taxsubsets=FILELIST : Files (fasta/id) with sets of assembly input sequences (matching GFF) to summarise []
        taxlevels=LIST  : List of taxonomic levels to report (* for superkingdom and below) ['*']
        taxwarnrank=X   : Taxonomic rank (and above) to warn when deviating for consensus [family]
        bestlineage=T/F : Whether to enforce a single lineage for best taxa ratings [True]
        mintaxnum=INT   : Minimum gene count in main dataset to keep taxon, else merge with higher level [2]
        ### ~ System options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        forks=X         : Number of parallel sequences to process at once [0]
        killforks=X     : Number of seconds of no activity before killing all remaining forks. [36000]
        forksleep=X     : Sleep time (seconds) between cycles of forking out more process [0]
        tmpdir=PATH     : Temporary directory path for running mmseqs2 [./tmp/]
        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        ```

        ---

        # SAAGA Overview

        SAAGA is based on MMseqs mapping of a predicted annotation proteome against a reference proteome. For assessment,
        this should be a high quality annotated proteome. For annotation, this should be a set of curated proteins such as SwissProt.

        ## Setup

        Unless `mmseqs` is the only active run mode, the `seqin=FILE` predicted annotation proteome is loaded and summarised.
        If `cdsin=FILE` is given and `longest`, `annotate` or `summarise` are active, the predicted annotation transcriptome
        will also be summarised. In `assess` mode, the reference proteome will also be loaded and summarised. If the reference
        proteome has more than 100,000 proteins, the option to exit will be given.

        Unless `mmseqs` is the only active run mode, the `gffin=FILE` GFF file will also be loaded and processed. Predicted
        genes, transcripts and exons are extracted based on the feature type. By default, SAAGA expects GeMoMa annotation
        with `gene`, `mRNA` and `CDS` feature types for genes, transcripts and exons, respectively. If `mRNA` features are
        not found, `prediction` features will be parsed as transcripts. These can be over-ridden with `gffgene=X`,
        `gffmrna=X` and `gffcds=X`. An optional `assembly=FILE` genome fasta file can also be provided, in which case the sequence names must match those in the GFF.

        Protein names in the `seqin=FILE` are mapped onto the `ID=X` identifiers for transcripts in the GFF file. Transcript
        `Parent=X` identifiers should map onto gene `ID=X` identifiers, and CDS `Parent=X` identifiers should map onto
        transcript `ID=X` identifiers. If mapping is incomplete, the user will be warned and given the option to exit.

        If `seqin=FILE` protein names and transcript IDs do not match, [https://github.com/gpertea/gffread](GffRead) can
        be used to generate the protein fasta file:

            gffread -y $PROTEIN_FASTA -g $GENOME $GFF

        The exception to this is that `taxonomy` mode can be run in one of two simplified modes, depending on the input given. If only `seqin=FILE` is provided (without gffin=FILE), it will be assumed that (1) each protein is encoded by a separate gene, and (2) protein names are in the form `sequence-name.X.Y`. If no `seqin=FILE` is provided, then a simple ORF dataset will be generated of all ORFs (in 6 reading frames) of 100+ amino acids mid-sequence, or 50+ amino acids at a sequence end. These will be named `sequence.RF.ORF`. In each case, the genome assembly must be provided with `assembly=FILE`.

        ### Taxonomy mode

        The `taxonomy` mode in SAAGA can be thought of as a separate tool. (And nearly was!) If `taxonomy` mode is active, this will be run next. See the run modes section below, for details. Unless another mode has been actively set, SAAGA will then exit after completing taxonomy mode.

        ### MMseqs Searches

        Unless the MMseq2 runs are already generated (or `force=T`), `mmseqs createdb` will be run on the annotation and
        reference proteomes. Following this, `mmseqs search` will be run using the `tmpdir=PATH` temporary directory
        (default, `./tmp/`). If `assess` or `annotate`, the reciprocal search of reference proteome versus predicted proteome
        is also executed. Searches are reduced to the top X hits (`tophits=INT`, default 250) using `mmseqs filterdb` and
        then tabulated `mmseqs convertalis`.

        For the annotation versus reference search, the following fields are output:

            query,target,evalue,raw,alnlen,pident,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov,theader

        For the reference versus annotation search, the following fields are output:

            query,target,evalue,raw,alnlen,pident,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov

        Unless `mmseqs` is the only active run mode, SAAGA will exit at this point. Otherwise, if multiple hits for the
        same query-hit pair exist, they are ranked by the `raw` score (big to small).

        ### Data integration

        After loading the input data and running MMseq2, the data is integrated and tidied.

        The exon (CDS) table is indexed on `parent`, `start` and `end`, and a new `exonlen` field added (`end`-`start`+1).
        This table is then collapsed by parent transcript `id`, keeping the smallest `start` position, biggest `end`,
        count of `exons` and summed `exonlen` for each transcript.

        For transcript/protein annotation, a copy of the annotation versus reference mmseqs output is made, reduced to the fields:

            query,target,raw,tcov,pident,theader

        The gene and transcripts tables are indexed on `id` for mapping onto other data.

        ---

        # SAAGA Outputs

        In addition to outputs generated by mmseqs (and a `*.sys.log` file logging any mmseqs runs), the main SAAGA outputs are:

        * `*.log` = the main SAAGA log file containing details of the run. (All modes)
        * `*.gene.tdt` = summary information per annotated gene. (`summarise` mode)
        * `*.proteins.tdt` = summary information per annotated protein
        * `*.refprot.tdt` = summary information per reference protein (Assessment mode)
        * `*.stats.tdt`= summary statistics for full annotation

        The fields for the main tables are given below. Details for some fields are provided in the **SAAGA run modes** section, below. Please contact the
        author if anything is not clear.


        ## Gene table [*.gene.tdt]

        * `locus` = Sequence name from assembly file
        * `source` = GFF source
        * `start` = Start position
        * `end` = End position
        * `strand` = Strand
        * `geneinfo` = Information parsed from GFF
        * `name` = Annotation gene name
        * `geneid` = Annotation gene ID (should map onto transcript Parent identifiers)
        * `isoforms` = Number of transcripts
        * `maxprotlen` = Maximum protein length
        * `longest` = Transcript ID for longest protein
        * `isoinfo` = Parsed GFF information for longest protein isoform

        ## Protein table [*.proteins.tdt]

        * `protname` = Protein sequence name
        * `protdesc` = Protein sequence description
        * `accnum` = Protein sequence accession number. Should map to Transcript ID.
        * `protlen` = Protein length (aa)
        * `exons` = No. exons
        * `exonlen` = Summed length of exons
        * `geneid` = Parent Gene ID (`geneid`)
        * `locus` = Location sequence name from assembly
        * `start` = Start position (transcript)
        * `end` = End position (transcript)
        * `strand` = Strand
        * `attributes` = Parsed GFF attributes
        * `bestref` = Best reference protein from mmseq search
        * `protcov` = Coverage of protein by `bestref` hit (0-1)
        * `refcov` = Coverage of `bestref` protein by mmseq hit (0-1)
        * `protratio` = Annotated protein length / `bestref` protein length
        * `lendiff` = Annotated protein length - `bestref` protein length
        * `alnlen` = Length of alignment
        * `pident` = Percentage identity of hit
        * `globid` = Global percentage identity of annotated protein
        * `hitnum` = Number of hits in mmseq search
        * `rbh` = Whether a reciprocal best hit (1/0)
        * `f1` = F1 score = 2 x Pr x Recall / (Pr + Recall) = 2 x protcov x refcov / (protcov + refcov)


        ## Reference protein table [*.refprot.tdt]

        * `refprot` = Reference protein name
        * `bestprot` = Top hit annotated protein
        * `alnlen` = Length of alignment
        * `pident` = Percentage identity of hit
        * `reflen` = Length of reference protein
        * `refcov` = Coverage of reference protein
        * `protcov` = Coverage of `bestprot`
        * `refdesc` = Description of reference protein
        * `f1` = F1 score = 2 x Pr x Recall / (Pr + Recall) = 2 x refcov x protcov  / (refcov + protcov)

        ## Summary statistics table [*.stats.tdt]

        * `seqin` = Input annotation proteome
        * `refdb` = Reference database
        * `genes` = Number of genes
        * `isoforms` = Number of transcripts
        * `exons` = Mean exons per gene
        * `exonlen` = Mean combined exon length
        * `protlen` = Mean protein length
        * `completeness` = Summed coverage of reference proteome (%)
        * `purity` = Summed reference coverage of annotated proteome (%)
        * `homology` = Percentage of genes with any hit in reference
        * `orthology` = Percentage of genes with reciprocal best hits
        * `protratio_mean` = Mean protein length ratio (only proteins with hits)
        * `protratio_median` = Median protein length ratio (only proteins with hits)
        * `protratio_sd` = StdDev of protein length ratio (only proteins with hits)
        * `duplicity` = Mean number of annotated genes sharing the same reference protein `bestref`
        * `compression` = Number of unique `bestprot` annotated genes / number of reference proteins with hit
        * `multiplicity` = Total no. Qry Genes / Total no Ref proteins
        * `f1` = Combined F1 across all query genes
        * `f1_hits` = Combined F1 across all query genes with hits
        * `mean_f1` = Mean F1 across all query genes

        ---

        # SAAGA run modes

        SAAGA can execute one or more different run modes that will generate different subsets of the main outputs. At its core, SAAGA (v0.7.x+) has four different underlying motivations:

        1. Compress protein/transcript annotation by gene to generate non-redundant summaries and/or sequences. In `summarise` mode, the `gene`, `proteins` and `stats` tables will be generated, albeit with fewer fields that in `assess` mode. If `longest` mode is activated, the longest protein sequence per gene will be output to `*.longest.faa` and the corresponding transcripts (if `cdsin=FILE` given) to `*.longest.fna`.
        2. Map annotation onto a reference proteome and make quality assessments. In `assess` mode, `refdb=FILE` should provide a single high-quality reference proteome. This will work best if the reference proteome is non-redundant and contains a single protein isoform per gene.
        3. Functional annotation of predicted proteins. In `annotate` mode, `refdb=FILE` should be a comprehensive resource of reliably annotated (named) protein sequences, e.g. SwissProt. This is not compatible with `assess` mode.
        4. Taxonomic assignment of assembly sequences. In `taxonomy` mode, the genome annotation (or crude ORF predictions) are used in conjunction with mmseqs2 `easy-taxonomy` to make taxonomic assigments for (1) genes, (2) assembly scaffolds, (3) the whole assembly, and (4) specified assembly subsets. Any genes or sequences violating the consensus taxonomy will be flagged. (See `taxonomy` mode for details.)

        **NOTE:** SAAGA is under development and documentation might be a bit sparse. Please contact the author or
        post an issue on GitHub if you have any questions.

        ---

        ## Annotation summarise mode [summarise=T]

        This mode will summarise the annotation from a GFF file. This is also executed as part of the `assess` mode. It will generate partial assessment statistics versus the `refdb=FILE` reference proteome, but will not perform any reciprocal searches or completeness analysis.

        See **SAAGA Outputs** and **Annotation assessment mode** for details of the statistics generated.

        ---

        ## Annotation assessment mode [assess=T]

        This mode compares the predicted protein sequences from an annotation to a reference proteome and asseses its
        quality and completeness. SAAGA performs a reciprocal MMseqs2 search against `refdb=FILE`, which should be a high-quality non-redundant reference proteome. The best hits are identified and then used to calculate coverage ratios between query and hit proteins as a means of annotation assessment. In general, metrics will be closer to 1 (or 100%) for complete annotations and assemblies without duplications. Although the maximum achievable value for these metrics will generally be unknown, comparative values can be used to assess improvement in assembly and/or annotation, akin to BUSCO scores.

        The main assessment statistics generated by SAAGA are:

        * **Protein length ratio.** (`protratio`) The length ratio of the annotated proteins versus its top reference hit. Long-read genome assemblies are prone to indel errors, whereas short-read assemblies tend to be fragmented. In each case, protein annotations can be truncated or fragmented. SAAGA uses a protein length ratio to assess the extent of this problem. Ideally, annotated protein will, on average, be approximately the same length as orthologous proteins in a high-quality reference proteome. If the protein length ratio is heavily skewed below 1.0, this will indicate a problem with truncated and/or fragmented protein annotations. (This can also be cause by incorrect annotation settings that miss long introns, for example.) `proratio` captures the best value per gene, which is reported as a mean, median and std dev for the whole annotation.

        * **F1 score.** (`f1`, `f1_mean` and `f1_hits`). F1 extends the protein length ratio to an annotation consistency metric calculated using the formula: (2 X PROTCOV X REFCOV) / (PROTCOV + REFCOV) where PROTCOV is the proportion of the annotated protein covered by its best reference protein hit, and REFCOV is the proportion of the best reference protein hit covered by the annotated protein. For the proteome, `f1` is the sum of the proteome coverage, whereas `f1_mean` is the mean `f1` per gene and `f1_hit` is the mean for the subset of proteins with a reference hit. (The former evaluates annotation completeness, whereas the latter evaluates the general quality of the indiviudal annotations.) As with `protratio`, `f1` values close to 1 mean that the query protein closely matches the length of the hit protein, indicating high fidelity of the gene prediction model and underlying assembly.

        * **Completeness.** (`completeness`) The summed percentage coverage of reference proteome by the annotated proteome. This is checking for "missing" proteins. Unless `refdb=FILE` represents the same species, (as with other genome completeness metrics) it is unlikely that the theoretical maximum is 100%. Nevertheless, assembly and/or annotation errors should be more likely to reduced completeness, making it a useful comparative statistic.

        * **Purity.** (`purity`) The summed percentage reference coverage of the annotated proteome, i.e. the reciprocal of completeness. This is checking for "extra" proteins, which may be indicative of either contamination (check with `taxonomy` mode) or false positive gene predictions. Note that an incomplete or divergent reference proteome will also result in low purity. As with completeness, it is unlikely that the theoretical maximum is 100%, but it should be a useful comparative statistic.

        * **Homology.** (`homology`) The percentage of annotated genes with any hit in reference. As with `purity`, this statistic gives an indication of contamination or false predictions, but without requiring good coverage of individudal genes.

        * **Orthology.** (`orthology`) The percentage of annotated genes with reciprocal best hits in the reference proteome. This should increase as assembly/annotation redundancy and duplication is decreased. As with `completeness` and `purity`, it is very unlikely to reach 100% due to lineage-specific duplications and deletions.

        * **Duplicity.** (`duplicity`) The mean number of annotated genes sharing the same best reference hit. This is somewhat analogous to the "Duplicated" part of the BUSCO score, but does not enforce an minimum coverage cutoffs. It can be useful for assessing the success of purging haplotigs, for example.

        * **Compression.** (`compression`) The number of unique annotated genes that were the top hit for reference proteins, divided by the total number of reference proteins with a hit. This is the inverse of `duplicity` and big deviations from 100% can indicate either redundancy in the reference proteome, or missing members of gene families.

        * **Multiplicity.** (`multiplicity`) The ratio of total number of annotated genes to reference proteins. This gives a broad ballpark indication of the completeness and stringency of the genome annotation. Big deviations from 1 need some explanation, whether that is genome/annotation incompleteness (under 1) or an excess of low quality annotations and/or duplications (over 1).

        **NOTE:** MMseqs2 stringency settings have not yet been optimised for performance. Results of `assess` mode should be used primarily for comparisons between annotation, rather than treated as an absolute truth in terms of completeness etc.

        **NOTE:** To use SAAGA for assembly assessment (rather than *annotation* assessment), the rapid homology-based gene prediction program GEMOMA is recommended to generate a draft annotation.

        ---

        ## Annotation annotation mode [annotate=T]

        Based on MAKER2 renaming, this mode will use the top hit to reference proteins (e.g. SwissProt) to add
        descriptions to predicted gene and proteins. Currently, `annotate` mode is explicitly designed to work with Uniprot format sequences, and will parse the description, organism (`OS=`) and gene (`GN=` where available) for the top reference hit. Proteins will then be renamed:

            Similar to $GENE: $DESCRIPTION [$ORGANISM]

        or:

            Similar to $DESCRIPTION [$ORGANISM]

        If no `OS=` tag is found, renaming will be simpler:

            Similar to $DESCRIPTION

        In each case, the description is appended with coverage and homology details, in the form `(X% cov @Y%id)`, as generated from the `refcov` and `pident` statistics from MMseqs2.

        Protein sequences with updated descriptions will be output to `*.renamed.faa`. If `cdsin=FILE` was provided, the corresponding transcripts will be output to `*.renamed.fna`.

        ---

        ## Longest protein mode [longest=T]

        This will extract the longest protein per gene, e.g. for reduced `Duplicated` ratings in BUSCO completeness
        estimates. The longest protein sequence per gene will be output to `*.longest.faa` and the corresponding transcripts (if `cdsin=FILE` given) to `*.longest.fna`.

        **NOTE:** This will include any new descriptions from `annotate` mode.

        ---

        ## MMseqs2 preparation mode [mmseq=T]

        This run the MMseqs2 steps in preparation for further analysis. It is primarily for debugging or when runs need
        to be split over multiple systems. (See **MMseqs Searches**, above.)

        ---

        ## Summarise taxonomic assignments for contamination assessments [taxonomy=T]

        Taxonomy mode combines the MMseqs2 `easy-taxonomy` with GFF parsing to perform taxonomic analysis of the input
        proteome and any subsets given by `taxsubsets=LIST`. Taxonomic assignments are mapped onto genes as well as assembly scaffolds and (if `assembly=FILE` is given) contigs.

        The first step is to run MMseqs2:

            mmseqs easy-taxonomy $PROTEOME $TAXDB $TAXBASE $TMPDIR

        Where `$PROTEOME` is the proteome provided with `seqin=FILE`, `$TAXDB` is a MMseqs2 taxonomic database (see below for creation), provided with `taxdb=FILE`, `$TAXBASE` is the `easy-taxonomy` output prefix, and `$TMPDIR` is the temporary directory (default `tmp`). If pre-existing results exist (`$TAXBASE._report` and `$TAXBASE_lca.tsv`) then these will be loaded, unless `force=T` is set. If MMseqs2 is not installed, pre-computed results *must* be provided. In principle, `report` and `lca.tsv` files generate by other tools should work as long as the format is the same.

        The core of taxonomy mode is the MMSeqs2 "Lowest Common Ancestor" (LCA) assignment, in which each sequence is associated with the lowest unabmigious taxonomic rank possible. Where amibiguity exists, a sequence will be assigned to a higher level. Higher levels also receive all the taxonomic assignments of their daughter taxa, and so the sequence count for any given taxonomic group will always be equal or greater than its lower subdivisions. Conceptually, SAAGA separates out the counts into `taxnum`, which are counts at that level or below, and `taxpure`, which are the numbers assigned specifically to that level. (i.e. `taxnum` will be the sum of `taxpure` for that taxonomic group and all lower divisions.) See the MMseqs2 documentation for more details.

        ### Taxonomy overview

        SAAGA will first read in the `*_report` file to build its internal taxonomy tree for the samples. By default, mmseqs will report all possible taxonomic levels, and SAAGA will retain the following:

            species, species subgroup, species group, subgenus, genus, subtribe, tribe, subfamily, family, superfamily, parvorder, infraorder, suborder, order, superorder, infraclass, subclass, class, superclass, subphylum, phylum, superphylum, subkingdom, kingdom, superkingdom

        This can be reduced further by specifying a subset of taxonomic levels of interest with `taxlevels=LIST`. Any missing levels, along with
        "no rank" or "clade" taxa (except `unclassified`, `root`, and `cellular organisms`), will be mapped to the next highest taxonomic level. Any MMseqs2 assignments to that level will be transferred to the higher level. Any taxa failing to meet the `mintaxnum=INT` threshold (default=2) will also be mapped onto higher levels.

        Next, the `*_lca.tsv` file is read and mapped onto the `gffin=FILE` GFF file to assign proteins to genes and
        sequences. The lowest-level hit for each gene will be kept, remapping to `taxlevels` as required. These
        collated ratings will be output to `*.lca_genes.tsv` and `*.lca_genes.gff` Gene ratings are then summed for each assembly sequence, and the dominant
        classification for each taxonomic level established for (a) each sequence, and (b) the whole dataset. Full
        collated ratings will be output to `*.taxolotl_report.tsv`. Ratings per sequence are output to `*.taxbyseq.tsv`. Dominant taxa are reported in the log file as `#BEST` entries.

        To flag contamination, each sequence is assessed against the dominant taxonomic rating at each taxonomic level.
        The percentage of genes matching each dominant rating is reported for each sequence in `*.taxolotl.tsv`
        along with the number of genes with a rating at that level, separated with a `|`. This will exclude any genes
        without ratings at that taxonomic level. A `:consensus:` entry will also report the overall values for the whole
        assembly.

        Any sequences that have a dominant taxonomic label deviating from the overall consensus at any ranking levels
        set by `taxwarnrank=X` (default family) or above will raise a contamination warning and be output in the log file with a `#BADTAX` rating. These sequences will have their dominant taxon and it's
        precentage appended to the consensus percentage, also separated by `|`. For example, `25.00|20|Chordata|50.00`
        would indicate that 25% of the 20 genes with ratings at that level matched the consensus, whilst the dominant
        classification was `Chordata` with 50% of 20 rated genes assigned to this category. Such sequences will also have `badtax` rating in the `rating` field of `*.taxolotl.tsv`. Sequences matching the dominant taxa will have a `goodtax` rating, whilst sequences without any genes mapped onto taxa by MMseqs2 will be rated `notax`.

        Good, Bad and missing sequence counts will be summarised in the log file in `#BEST`, `BADTAX`, and `#NOTAX` entries.
        Sequence subsets are output to `*.id` and `*.fasta` files, and summarised along with the full assembly in
        `*.seqsummary.tsv`. (Any ratings without sequences will not be output/summarised.) If `assembly=FILE` is provided,
        sequences without genes will also be summarised. Taxonomy ratings for these subsets are also output to
        `*.$RATING.taxolotl_report.tsv` files. Any sequence subsets provided by `taxsubsets=LIST` (see below) will also be
        summarised in `*.$SUBSET.taxolotl_report.tsv` files. It is recommended that all the MMseqs2 `_report` file is loaded
        with all the `*.taxolotl_report.tsv` for visualisation with [Pavian](https://github.com/fbreitwieser/pavian)
        (Breitwieser FP and Salzberg SL (2020) [Bioinformatics 36(4):1303-1304](https://doi.org/10.1093/bioinformatics/btz715))
        through its [Shiny App](https://fbreitwieser.shinyapps.io/pavian/).

        Finally, if `assembly=FILE` is provided (unless `taxbycontig=F`), contigs will be extracted by splitting scaffolds on `mingap=INT` (default 10) consecutive `N`s. Genes will be remapped onto contigs as with sequences, and taxonomic ratings output to `*.taxbyctg.tsv` and `*.ctgtaxolotl.tsv`. These are the contig equivalents of `*.taxbyseq.tsv` and `*.taxolotl.tsv`. Contigs without taxonomic ratings will be listed in the log file with `#BADTAX` entries, unless already reported as an assembly sequence.

        ### Main taxonomy outputs

        Outputs will be given a file prefix set by `taxbase=X`. By default, this will be `$SEQBASE.$TAXADB`, where
        `$SEQBASE` is the basename of `seqin=FILE` and `$TAXADB` is the taxonomy database set by `taxdb=FILE`.

        The main mmseqs `easy-taxonomy` output will generate:

        * `*_lca.tsv` = best assignments per protein sequence (protein, taxid, rank, taxname): required.
        * `*_report` = text summary of overall taxonomy that can be loaded by Pavian etc.: required.
        * `*_tophit_aln` = top database hits for each protein (not currently used): not required.
        * `*_tophit_report` = taxonomic classification of the top hit proteins: not required.

        In addition, Taxolotl will output:

        * `*.taxbyseq.tsv` = Rating counts for each taxonomic group by assembly sequence (scaffold).
        * `*.taxolotl_report.tsv` = Collated Kraken-style report file.
        * `*.lca_genes.tsv` = Best assignments (lowest taxonomic level) for each gene.
        * `*.lca_genes.gff` = GFF file with Taxolotly ratings for each gene.
        * `*.taxolotl.tsv` = Tab separated file with consensus taxonomic assignment at each taxonomic rank, and ratings per sequence.
        * `*.$SUBSET.id` = Sequence identifiers for assembly subsets based on Taxolotl ratings.
        * `*.$SUBSET.fasta` = Fasta files of assembly subsets based on Taxolotl ratings.
        * `*.seqsummary.tsv` = Summary statistics for assembly subset fasta files.
        * `*.taxbyctg.tsv` = Rating counts for each taxonomic group by assembly contig.
        * `*.ctgtaxolotl.tsv` = Taxolotl ratings by assembly contig.

        #### Taxonomy by sequence output

        If `taxbyseq=T` then an addition `*.taxbyseq.tsv` file will be produced, with the following fields:

        * `seqname` = assembly sequence name
        * `genenum` = number of genes parsed for that sequence
        * `protnum` = number of proteins parsed for that sequence
        * `rank` = taxonomic rank of rating
        * `genetax` = number of genes with assignment at that level
        * `taxid` = taxonomic label identifier number
        * `taxname` = taxonomic label name at that rank
        * `taxperc` = percentage assignment to this rank or lower
        * `taxnum` = number of genes assigned to this rank or lower
        * `taxpure` = number of genes assigned to this rank specifically

        ### Sequence subset analysis

        In addition to the main output for the whole proteome, any subsets given by `taxsubsets=LIST` will have their own `*.taxolotl_report.tsv` file, which can be visualised with Pavian. These must be lists of IDs that match the assembly sequence names in the GFF file. Subsets will be named after the subset file prefix, e.g. `assembly.suspect.id` would generate `*.assembly.suspect.taxolotl_report.tsv`.


        ### Generating a taxonomic database

        Please see the MMseqs2 documentation for generating a taxonomic database. To date, Taxolotl has been tested with taxonomy databases generated from NCBI nr, using BLAST+ and MMSeqs2 and the NCBI taxonomy dump (<https://ftp.ncbi.nlm.nih.gov/pub/taxonomy/taxdump.tar.gz>):

        ```
        blastdbcmd -db $NCBIPATH/nr -entry all > ncbinr.faa
        blastdbcmd -db $NCBIPATH/nr -entry all -outfmt "%a %T" > ncbinr.faa.taxidmapping

        mmseqs createdb ncbinr.faa ncbinr.faaDB
        mmseqs createtaxdb ncbinr.faaDB tmp --ncbi-tax-dump taxonomy/ --tax-mapping-file ncbinr.faa.taxidmapping
        mmseqs createindex ncbinr.faaDB tmp
        ```

        If the assembly is already in RefSeq, it is recommended that the taxa of the assembly is removed before running Taxolotl, e.g.:

        ```
        mmseqs filtertaxseqdb ncbinr.faaDB seqTaxNoQueryDB --taxon-list '!178133,!38626'
        ```

        If getting an error that the `*.dmp` files are missing, these can be added with soft links from the `taxonomy/` directory containing the NCBI taxonomy dump.


        ### Simple ORF mode

        If no proteins are given, ORFs will be generated by `SeqSuite` with default settings `minorf=100 rftran=6 terminorf=50 orfgaps=F`, i.e. ORFs of 100+ amino acids from all six reading frames, or 50+ amino acids if truncated at the end of a sequence. ORFs will not span assembly gaps, and any ambiguous (`X`) translations will be replaced with stop codons (`*`), unless `orfgaps=T` is set. Note that, due to introns, it is expected that these ORFs will often represent partial coding sequences, and many will be random junk translations.

        The idea of ORF mode is to provide a quick, crude impression of the taxonomic profile. However, for large assemblies it can be very slow to process.

        In ORF mode, each ORF is assumed to represent a different gene, although this may not be the case. Currently, `SeqSuite` will not generate a GFF file for the ORFs. As a result, the `taxbycontig` output is not available.



        '''
        try:### ~ [1] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            #i# The setup will parse the input sequences and GFF
            if self.getBool('DocHTML'): return self.docHTML()
            if not self.setup(): self.printLog('#ABORT','Problem during setup: aborted'); return False
            if self.getBool('MMseqs'):
                self.makeMMseqDB()
            ### ~ [2] ~ Add main run code here ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            if self.getBool('Taxonomy'):
                self.headLog('TAXONOMY',line='=')
                self.debug('Pure taxonomy: {0}'.format(self.pureTaxonomy()))
                if self.pureTaxonomy(): return self.taxonomy()
                elif not self.taxonomy(): return False
            self.headLog('MMSEARCH',line='=')
            self.runMMseqSearch(reciprocal=self.runMode(['assess','annotate']))
            #!# Add tophits filtering for speed. Use just the best hit for assess mode
            tophits = self.getInt('TopHits')
            #if self.runMode(['assess']) and not self.runMode(['annotate']): tophits = 1
            #!# Removing tophits reduction for now, because we want to use tied top hits and take the best coverage
            self.bestMMseqSearch(reciprocal=self.runMode(['assess']),tophits=tophits)
            self.tabulateMMseqSearch(reciprocal=self.runMode(['assess']),tophits=tophits)
            ### ~ [3] ~ Mode-specific processing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            if self.runMode(['longest','annotate','summarise','assess']):
                self.tidyTables()
            ## ~ [3a] ~ Assess Mode ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if self.runMode(['assess']): self.statistics(assess=True)
            ## ~ [3b] ~ Summary Mode ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            elif self.runMode(['summarise']): self.statistics(assess=False)
            ## ~ [3c] ~ Annotate (Rename) Mode ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            #i# Use self.db('descmap') ranked (inverse) on hitscore, chop first word and use self.newDesc(hitdesc)
            #i# Update and output fasta file -> reload into SeqList for longest mode
            #i# Reparse, update and output GFF file with description as ';note="{0}"'.format(newdesc)
            addcov = True   #!# Make an option
            unknown = 'Predicted protein'   #!# Make an option
            if self.runMode(['annotate']):
                descdb = self.db('descmap')  # - protname - refhit - hitscore - hitdesc
                seqlist = self.obj['SeqIn']
                newdesc = {}
                for seq in seqlist.seqs():
                    sname = seqlist.shortName(seq)
                    if descdb.data((sname,1)):
                        dentry = descdb.data((sname,1))
                        hitdesc = ' '.join(dentry['hitdesc'].split()[1:])
                        newdesc[sname] = self.newDesc(hitdesc)
                        if addcov:
                            newdesc[sname] = newdesc[sname] + ' ({0:.1f}% cov @{1:.1f}%id)'.format(100.0*dentry['refcov'],100.0*dentry['pident'])
                    elif seqlist.seqDesc(seq): newdesc[sname] = seqlist.seqDesc(seq)
                    else: newdesc[sname] = unknown
                seqlist.setStr({'SeqOut':'{0}.renamed.faa'.format(self.baseFile())})
                seqlist.newDesc(newdesc,keepname=True)
                seqlist.setStr({'SeqIn':'{0}.renamed.faa'.format(self.baseFile())})
                seqlist.loadSeq()
                #i# Update transcript file
                if self.obj['CDSIn']:
                    cds = self.obj['CDSIn']
                    cds.setStr({'SeqOut':'{0}.renamed.fna'.format(self.baseFile())})
                    cds.newDesc(newdesc,keepname=True)
                    cds.setStr({'SeqIn':'{0}.renamed.fna'.format(self.baseFile())})
                    cds.loadSeq()
                #i# Update GFF file
                pdb = self.db('proteins')  # newkey=['protname'] -> geneid
                for protname in rje.sortKeys(newdesc):
                    if pdb.data(protname):
                        geneid = pdb.data(protname)['geneid']
                        if geneid not in newdesc: newdesc[geneid] = newdesc[protname]
                newgff = '{0}.renamed.gff'.format(self.baseFile())
                rje.backup(self,newgff,appendable=False)
                IN = open(self.getStr('GFFIn'),'r')
                OUT = open(newgff,'w')
                gline = IN.readline(); gx = 1
                while gline:
                    self.progLog('\r#GFF','Updating {0} GFF lines'.format(rje.iStr(gx)),rand=0.01)
                    if gline.startswith('#'): OUT.write(gline)
                    else:
                        gtext = rje.chomp(gline)
                        gdata = string.split(gtext,'\t')
                        if gdata[2].lower() in ['gene','mrna']:
                            attlist = rje.longCmd(string.split(gdata[8],';'))
                            id = ''
                            for attdata in attlist:
                                if not attdata: continue
                                try:
                                    [att,val] = string.split(attdata,'=')
                                    if att.lower() == 'id': id = val; break
                                except:
                                    self.warnLog('Problem with GFF attribute: {0}'.format(attdata))
                            if id and id in newdesc and newdesc[id]:
                                if not gtext[-1:] == ';': gtext = gtext + ';'
                                gtext = '{0}{1}="{2}"'.format(gtext,self.getStr('GFFDesc'),newdesc[id])
                                OUT.write('{0}\n'.format(gtext))
                            else: OUT.write(gline)
                        else: OUT.write(gline)
                    gline = IN.readline(); gx += 1
                self.printLog('\r#GFF','Updated {0} GFF lines -> {1}'.format(rje.iStr(gx),newgff))
            ## ~ [3d] ~ Longest Mode ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            #i# Pull out 'longest' field IDs from self.db('gene')
            if self.runMode(['longest']):
                longfas = '{0}.longest.faa'.format(self.baseFile())
                genedb = self.db('gene')
                longids = genedb.dataList(genedb.entries(),'longest',sortunique=True,empties=False)
                seqlist = self.obj['SeqIn']
                longseq = []    # List of sequences to output
                for seq in seqlist.seqs():
                    if seqlist.shortName(seq) in longids: longseq.append(seq)
                seqlist.saveSeq(seqs=longseq,seqfile=longfas,reformat='fasta',append=False)
                if self.obj['CDSIn']:
                    cds = self.obj['CDSIn']
                    longfas = '{0}.longest.fna'.format(self.baseFile())
                    longseq = []    # List of sequences to output
                    for seq in cds.seqs():
                        if cds.shortName(seq) in longids: longseq.append(seq)
                    cds.saveSeq(seqs=longseq,seqfile=longfas,reformat='fasta',append=False)
            return
        except:
            self.errorLog(self.zen())
            raise   # Delete this if method error not terrible
#########################################################################################################################
    def seqBase(self): return rje.baseFile(self.getStr('SeqIn'),strip_path=True)
    def refBase(self): return rje.baseFile(self.getStr('RefProt'),strip_path=True)
    def seqMMDB(self): return '{0}{1}'.format(self.getStr('MMSeqDB'),self.seqBase())
    def refMMDB(self):
        if not self.getStrLC('RefDB'): self.setStr({'RefDB':'{0}{1}'.format(self.getStr('MMSeqDB'),self.refBase())})
        return self.getStr('RefDB')
#########################################################################################################################
    def runMode(self,checkmodes,allmodes=False):   # Check run modes and return True if any active or False if not
        '''
        Check run modes and return True if any active or False if not
        :param checkmodes: list of modes to check. Will print settings to log if none given
        :param allmodes: whether all modes given must be set to return True.
        :return: True/False
        '''
        if not checkmodes:
            for modestr in ['Annotate','Assess','Longest','MMseqs','Summarise','Taxonomy']:
                self.printLog('#MODE','{0}: {1}'.format(modestr,self.getBool(modestr)))
            return False
        modekeys = {}
        for modestr in ['Annotate','Assess','Longest','MMseqs','Summarise','Taxonomy']:
            modekeys[modestr] = modestr
            modekeys[modestr.lower()] = modestr
        active = None
        for modestr in checkmodes:
            try: modestr = modekeys[modestr]
            except:
                self.warnLog('Unrecognised modestring given: {0}'.format(modestr))
                return False
            if allmodes and active == None: active = self.getBool(modestr)
            elif allmodes: active = active and self.getBool(modestr)
            else: active = active or self.getBool(modestr)
        return active
#########################################################################################################################
    def pureTaxonomy(self): ### Returns whether only taxonomy mode is active
        '''
        Returns whether only taxonomy mode is active
        :return:
        '''
        if not self.runMode(['Taxonomy']): return False
        scheck = SAAGA(self.log,['mmseqs=F','summarise=F']+self.cmd_list)
        self.setBool({'MMseqs':scheck.getBool('MMseqs'),'Summarise':scheck.getBool('Summarise')})
        if self.runMode(['Annotate','Assess','Longest','Summarise','MMseqs']): return False
        return True
#########################################################################################################################
    def setup(self):    ### Main class setup method.
        '''Main class setup method.'''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('SETUP',line='=')
            try:
                mmseq = os.popen('mmseqs').readline().split()[0]
                if mmseq == 'MMseqs2': self.printLog('#MMSEQ2','MMseqs2 found')
                else: raise ValueError('Ran "mmseqs" - expected "MMseqs2", returned "{0}"'.format(mmseq))
                if not self.pureTaxonomy():
                    rje.mkDir(self,self.getStr('MMSeqDB'))
            except:
                self.warnLog('MMseqs2 installation not found. Some functionality will not work.')
                self.setBool({'MMseqs':False})
            ## ~ [1a] Assembly ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            self.obj['Assembly'] = None
            if self.getStrLC('TaxDB') and self.getStrLC('Assembly'):
                acmd = ['seqin={0}'.format(self.getStr('Assembly')), 'dna=T', 'summarise=F', 'autofilter=F', 'autoload=T']
                assembly = self.obj['Assembly'] = rje_seqlist.SeqList(self.log, ['minorf=100', 'rftran=6', 'terminorf=50', 'orfgaps=F'] + self.cmd_list + acmd)
                if self.pureTaxonomy() and assembly and not rje.exists(self.getStr('SeqIn')):
                    seqout = rje.baseFile(self.getStr('Assembly')) + '.orfs.faa'
                    self.setStr({'SeqIn': seqout})
                    self.cmd_list.append('seqin={0}'.format(seqout))
                    assembly.setStr({'SeqOut': seqout,'ReFormat':'dna2prot'})
                    assembly.saveSeq(seqfile=seqout)
            ## ~ [1a] Basefile ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            self.printLog('#SEQIN',self.seqBase())
            if self.pureTaxonomy():
                if not self.getStrLC('Basefile'): self.baseFile('{0}.{1}'.format(self.seqBase(),rje.baseFile(self.getStr('TaxDB'),strip_path=True)))
                if not self.getStrLC('TaxBase'): self.baseFile('{0}.{1}'.format(self.seqBase(),rje.baseFile(self.getStr('TaxDB'),strip_path=True)))
                self.printLog('#TAXDB',self.getStr('TaxDB'))
                self.printLog('#BASE',self.basefile())
                self.printLog('#TXBASE',self.getStr('TaxBase'))
            else:
                if not self.getStrLC('Basefile'): self.baseFile('{0}.{1}'.format(self.seqBase(),self.refBase()))
                self.printLog('#REFDB',self.refBase())
                self.printLog('#BASE',self.basefile())
                if self.runMode(['Taxonomy']):
                    if not self.getStrLC('TaxBase'): self.baseFile('{0}.{1}'.format(self.seqBase(), rje.baseFile(self.getStr('TaxDB'), strip_path=True)))
                    self.printLog('#TAXDB', self.getStr('TaxDB'))
                    self.printLog('#TXBASE',self.getStr('TaxBase'))
            self.runMode([])
            ## ~ [1b] Precomputed MMSeq2 options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if not self.getStrLC('MMQryMap'): self.setStr({'MMQryMap':'{0}.{1}.mmseq.tsv'.format(self.seqBase(),self.refBase())})
            if not self.getStrLC('MMHitMap'): self.setStr({'MMHitMap':'{1}.{0}.mmseq.tsv'.format(self.seqBase(),self.refBase())})
            ## ~ [1c] Protein sequence table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            seqlist = self.obj['SeqIn'] = rje_seqlist.SeqList(self.log,self.cmd_list+['seqmode=file','summarise=F','autofilter=F'])
            if not seqlist.seqNum(): raise IOError('Failed to load any sequences from "{0}"'.format(self.getStr('SeqIn')))
            seqlist.obj['DB'] = self.obj['DB']
            if self.runMode(['longest','annotate','summarise','assess','taxonomy']):
                seqlist.summarise(sumdb=True,save=False)
                seqdb = self.db('sequences') #['name','desc','gene','spec','accnum','length']
                #i# Drop gene and spec fields
                #i# Will use the name field to check against GFF
            ## ~ [1d] Transcript sequences for renaming ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if self.runMode(['longest','annotate','summarise']):
                self.obj['CDSIn'] = None
                if rje.exists(self.getStr('CDSIn')):
                    cds = self.obj['CDSIn'] = rje_seqlist.SeqList(self.log,self.cmd_list+['seqmode=file','summarise=F','autofilter=F','seqin={0}'.format(self.getStr('CDSIn'))])
                    if self.getBool('Summarise'):
                        cds.summarise(sumdb=False,save=False)
                elif self.getStrLC('CDSIn'):
                    self.warnLog('Transcript file cdsin="{0}" not found: no transcript fasta output'.format(self.getStr('CDSIn')))
            ## ~ [1e] RefProt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            #!# Check precomputed and force and switch NeedDB=False
            if self.runMode(['assess','annotate']):
                refprot = self.obj['RefProt'] = rje_seqlist.SeqList(self.log,self.cmd_list+['seqmode=file','summarise=F','seqin={0}'.format(self.getStr('RefProt')),'autofilter=F'])
                if self.runMode(['assess']):
                    refprot.summarise(sumdb=True,save=False)
                if self.runMode(['assess']) and refprot.seqNum() > 100000:
                    self.warnLog('Assement mode activated but reference proteome has >100k proteins ({0})'.format(rje.iStr(refprot.seqNum())))
                    if self.i() > -1 and rje.yesNo('Switch assess=F?',default='N'): self.setBool({'Assess':False})
            ### ~ [2] GFF parsing and data checks ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            #i# Parse GFF file
            #i# Will want to use the name field of self.db('sequences') to check against GFF IDs for mRNA
            if self.pureTaxonomy() and not rje.exists(self.getStr('GFFIn')):
                self.printLog('#WARN','No GFF found. Will assume one protein per gene.')
            elif self.runMode(['longest','annotate','summarise','assess','taxonomy']):
                #i# Parse a table of ['locus', 'source', 'ftype', 'start', 'end', 'score', 'strand', 'phase', 'attributes']
                #i# Elements also extracted from attributes into fields
                #!# Update self.obj['GFF'].list['Attributes'] = List of attributes (X=Y;) to pull out into own fields ("*" or "all" for all) [*]
                #i# Keys: ['locus','strand','start','end','source','ftype']
                #i# start and end will be integers
                #i# GeMoMa GFF:
                # CHINACHR29.01   GAF     gene    74976   128160  .       -       .       Name=BASCHINAG22344;ID=BASCHINAG22344;transcripts=1;complete=1;maxEvidence=1;combinedEvidence=1
                # CHINACHR29.01   GeMoMa  mRNA    74976   128160  .       -       .       Name=BASCHINAG22344.1;ID=BASCHINAG22344.1;ref-gene=cattle_gene97;aa=107;score=117;ce=2;rce=2;pAA=0.6241;iAA=0.3684;nps=0;start=M;stop=*;evidence=1;Parent=BASCHINAG22344;sumWeight=1.0;
                # CHINACHR29.01   GeMoMa  CDS     128029  128160  .       -       0       Parent=BASCHINAG22344.1
                ftypes = [self.getStr('GFFGene'),self.getStr('GFFmRNA'),self.getStr('GFFCDS'),'gene','mRNA','prediction','CDS']
                self.obj['GFF'].list['Attributes'] = ['Name','ID','Parent']
                self.obj['GFF'].parseGFF(self.getStr('GFFIn'),ftypes=ftypes) #,parseattributes=False)
                self.printLog('#GFF','GFF Fields: %s' % ', '.join(self.db('features').fields()))
                ## ~ [2a] Reduce fields ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                gffdb = self.db('features')
                #i# features -> ['locus','strand','start','end','source','ftype']: ['locus', 'source', 'ftype', 'start', 'end', 'score', 'strand', 'phase', 'attributes']
                #i#     |-- Elements also extracted from attributes into fields
                #i#     |-- start and end will be integers
                gffdb.rename('gff')
                gffdb.dropFields(['score','phase'])
                ## ~ [2b] Split tables created and loaded ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                self.db().splitTable(gffdb,'ftype',asdict=True,keepfield=False,splitchar=None,values=[],add=True)   ### Splits table based on unique values of given field
                gtype = self.getStr('GFFGene')
                mtype = self.getStr('GFFmRNA')
                ctype = self.getStr('GFFCDS')
                genedb = self.db('gff_{0}'.format(gtype))
                transdb = self.db('gff_{0}'.format(mtype))
                exondb = self.db('gff_{0}'.format(ctype))
                if not self.getStrLC('GFFGene'): genedb = None
                if not self.getStrLC('GFFmRNA'): transdb = None
                if not self.getStrLC('GFFCDS'): exondb = None
                gfftype = 'gemoma'   #!# May want to add alternative annotation sources at some point, or extract from GFF?
                if gfftype == 'gemoma':
                    if not genedb: gtype = 'gene'; genedb = self.db('gff_{0}'.format(gtype))
                    if not transdb: mtype = 'mRNA'; transdb = self.db('gff_{0}'.format(mtype))
                    if not transdb: mtype = 'prediction'; transdb = self.db('gff_{0}'.format(mtype))
                    if not exondb: ctype = 'CDS'; exondb = self.db('gff_{0}'.format(ctype))
                if genedb:
                    if genedb != self.db('gff_{0}'.format(gtype)):
                        self.printLog('#GFF','GFFType={0}: GFFGene={1} -> {2}'.format(gfftype,self.getStr('GFFGene'),gtype))
                else: raise ValueError('Unable to consolidate tables without valid gffgene=X and GFF file')
                if transdb:
                    if transdb != self.db('gff_{0}'.format(mtype)):
                        self.printLog('#GFF','GFFType={0}: GFFmRNA={1} -> {2}'.format(gfftype,self.getStr('GFFmRNA'),mtype))
                else: raise ValueError('Unable to consolidate tables without valid gffmrna=X and GFF file')
                if exondb:
                    if exondb != self.db('gff_{0}'.format(ctype)):
                        self.printLog('#GFF','GFFType={0}: GFFCDS={1} -> {2}'.format(gfftype,self.getStr('GFFCDS'),ctype))
                else: raise ValueError('Unable to consolidate tables without valid gffcds=X and GFF file')
                genedb.rename('gene')
                transdb.rename('trans')
                exondb.rename('exons')
                ## ~ [2c] Check data integrity by cross-referencing key data ~~~~~~~~~~~~~~~~~~~~~~ ##
                seqaccs = seqdb.dataList(seqdb.entries(),'accnum')
                #seqnames = seqdb.dataList(seqdb.entries(),'name')
                geneid = genedb.dataList(genedb.entries(),'id')
                transid = transdb.dataList(transdb.entries(),'id')
                transpar = transdb.dataList(transdb.entries(),'parent')
                exonpar = exondb.dataList(exondb.entries(),'parent')
                #i# genedb['id'] should match transdb['parent']
                badgene = rje.listDifference(transpar,geneid)
                if badgene:
                    self.warnLog('{0} of {1} transcript parent identifiers not found in Gene IDs: check GFF formatting'.format(rje.iLen(badgene),rje.iLen(transpar)))
                else:
                    self.printLog('#GFF','All {0} transcript parent identifiers mapped to Gene IDs: OK'.format(rje.iLen(transpar)))
                #i# transdb['id'] should match exondb['parent']
                badtrans = rje.listDifference(exonpar,transid)
                if badtrans:
                    self.warnLog('{0} of {1} exon parent identifiers not found in transcript IDs: check GFF formatting'.format(rje.iLen(badtrans),rje.iLen(exonpar)))
                else:
                    self.printLog('#GFF','All {0} exon parent identifiers mapped to transcript IDs: OK'.format(rje.iLen(exonpar)))
                #i# transdb['id'] should match seqdb['name']
                seqnames = seqaccs  #i# Currently actually mapping via accnum
                badseq = rje.listDifference(seqnames,transid)
                if badseq:
                    self.warnLog('{0} of {1} protein sequence names not found in transcript IDs: check GFF and protein fasta formatting'.format(rje.iLen(badseq),rje.iLen(seqnames)))
                else:
                    self.printLog('#GFF','All {0} protein sequence names mapped to transcript IDs: OK'.format(rje.iLen(seqnames)))
                badtransid = rje.listDifference(transid,seqnames)
                if badtransid:
                    self.warnLog('{0} of {1} transcript IDs not found in protein sequence names: check GFF and protein fasta formatting'.format(rje.iLen(badtransid),rje.iLen(transid)))
                else:
                    self.printLog('#GFF','All {0} transcript IDs mapped to protein sequence names: OK'.format(rje.iLen(transid)))
                #i# Option to quit
                if badgene or badtrans or badseq or badtransid and self.i() > -1 and rje.yesNo('Possible input errors. Abort run?'):
                    return False
            return True     # Setup successful
        except: self.errorLog('Problem during %s setup.' % self.prog()); return False  # Setup failed
#########################################################################################################################
    def restSetup(self):    ### Sets up self.dict['Output'] and associated output options if appropriate.
        '''
        Run with &rest=docs for program documentation and options. A plain text version is accessed with &rest=help.
        &rest=OUTFMT can be used to retrieve individual parts of the output, matching the tabs in the default
        (&rest=format) output. Individual `OUTFMT` elements can also be parsed from the full (&rest=full) server output,
        which is formatted as follows:

        ###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~###
        # OUTFMT:
        ... contents for OUTFMT section ...
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

        ### Available REST Outputs:
        There is currently no specific help available on REST output for this program.
        '''
        try:### ~ [0] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            for outfmt in self.restOutputOrder(): self.dict['Output'][outfmt] = 'No output generated.'
            #!# Add specific program output here. Point self.dict['Output'][&rest=X] to self.str key.
            return
        except: self.errorLog('RestSetup error')
#########################################################################################################################
    def restOutputOrder(self): return rje.sortKeys(self.dict['Output'])
#########################################################################################################################
    def docHTML(self):  ### Generate the SAAGA Rmd and HTML documents.                                        # v0.1.0
        '''Generate the SAAGA Rmd and HTML documents.'''
        try:### ~ [1] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            info = self.log.obj['Info']
            prog = '%s V%s' % (info.program,info.version)
            rmd = rje_rmd.Rmd(self.log,self.cmd_list)
            rtxt = rmd.rmdHead(title='%s Documentation' % prog,author='Richard J. Edwards',setup=True)
            #!# Replace this with documentation text?
            rtxt += string.replace(self.run.__doc__,'\n        ','\n')
            rtxt += '\n\n<br>\n<small>&copy; 2021 Richard Edwards | richard.edwards@unsw.edu.au</small>\n'
            rmdfile = '%s.docs.Rmd' % self.baseFile()
            open(rmdfile,'w').write(rtxt)
            self.printLog('#RMD','RMarkdown {0} documentation output to {1}'.format(info.program,rmdfile))
            rmd.rmdKnit(rmdfile)
        except:
            self.errorLog(self.zen())
            raise   # Delete this if method error not terrible
#########################################################################################################################
    ### <2> ### Database Methods                                                                                        #
#########################################################################################################################
    #i# sequences -> name:['name','desc','gene','spec','accnum','length']
    #i# features -> ['locus','strand','start','end','source','ftype']: ['locus', 'source', 'ftype', 'start', 'end', 'score', 'strand', 'phase', 'attributes']
    #i#     |-- Elements also extracted from attributes into fields
    #i#     |-- start and end will be integers
    #i# loci -> locus:['locus','start','end','sequence']
    #i# qrymap ->  query,target:[query,target,evalue,raw,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov,theader]
    #i# hitmap ->  query,target:[query,target,evalue,raw,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov]
#########################################################################################################################
    #i# GeMoMa GFF:
    # CHINACHR29.01   GAF     gene    74976   128160  .       -       .       Name=BASCHINAG22344;ID=BASCHINAG22344;transcripts=1;complete=1;maxEvidence=1;combinedEvidence=1
    # CHINACHR29.01   GeMoMa  mRNA    74976   128160  .       -       .       Name=BASCHINAG22344.1;ID=BASCHINAG22344.1;ref-gene=cattle_gene97;aa=107;score=117;ce=2;rce=2;pAA=0.6241;iAA=0.3684;nps=0;start=M;stop=*;evidence=1;Parent=BASCHINAG22344;sumWeight=1.0;
    # CHINACHR29.01   GeMoMa  CDS     128029  128160  .       -       0       Parent=BASCHINAG22344.1
    # CHINACHR29.01   GeMoMa  CDS     74976   75164   .       -       0       Parent=BASCHINAG22344.1
#########################################################################################################################
    def tidyTables(self,save=True):   ### Consolidate the database tables, adjusting fields and keys
        '''
        Consolidate the database tables, adjusting fields and keys.

        # Annotated protein sequence table
        - protname
        - protlen
        - protdesc
        - protid = parent mRNA ID from GFF
        - exons = exon count (CDS feature) from GFF -> Might need to modify for other GFF Types
        - exonlen = combined length of exons from GFF
        - geneid = parent gene from GFF
        - locus = location data parsed from GFF for mRNA
        - strand
        - start
        - end
        - attributes = mRNA attributes parsed from GFF
        - bestref (qrymap:target)
        - protcov (qrymap:qcov)
        - refcov (qrymap:tcov)
        - protratio (qrymap:(qlen/tlen))
        - rbh = whether bestref has protid as bestprot [Q. How to handle isoforms in Reference?]

        # Reference protein sequence table [assess mode]
        - refprot
        - reflen
        - refdesc
        - bestprot (hitmap:target)
        - protcov (hitmap:tcov)
        - refcov (hitmap:qcov)
        - protratio (qrymap:(qlen/tlen))

        # Annotated genes from GFF
        - geneid
        - locus = location data parsed from GFF for mRNA
        - strand
        - start
        - end
        - isoforms = number of proteins
        - maxprotlen = max protein length
        - longest = protname of longest isoform
        - attributes = mRNA attributes parsed from GFF

        ## Proteins mapped onto reference
        - refhit
        - hitscore
        - hitdesc

        '''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('CONSOLIDATE TABLES',line='=')
            db = self.db()
            ## ~ [1a] Tables created and loaded ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            #i# sequences -> name:['name','desc','gene','spec','accnum','length']
            seqdb = self.db('sequences')
            db.list['Tables'].append(seqdb)

            #i# Splitting and initial processing of GFF tables managed by Setup
            genedb = self.db('gene')
            transdb = self.db('trans')
            exondb = self.db('exons')

            genedb.newKey(['id'])
            transdb.newKey(['id'])
            exondb.newKey(['parent','start','end'])
            exondb.keepFields(['parent','start','end'])
            exondb.renameField('parent','id')
            exondb.addField('exons',evalue=1)
            exondb.makeField('end-start+1','exonlen')
            exondb.compress(['id'],rules={'start':'min','end':'max','exons':'sum','exonlen':'sum'})

            #i# loci -> locus:['locus','start','end','sequence']
            locdb = self.db('loci')
            #i# qrymap ->  query,target:[query,target,evalue,raw,alnlen,pident,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov,theader]
            qrymap = self.db('qrymap')
            descdb = db.copyTable(qrymap,'descmap') # For annnotation
            descdb.keepFields(['query','target','raw','tcov','pident','theader'])
            qrymap.rankFieldByIndex('query','raw',newfield='rank',rev=True,absolute=True,lowest=True,unique=False,warn=True,highest=False)
            if self.getInt('TopHits'):
                qrymap.dropEntries(['rank>{0}'.format(self.getInt('TopHits'))])
            qrymap.makeField('100*qcov*pident','globid')
            if self.getNum('MinGlobID'):
                qrymap.dropEntries(['globid<{0}'.format(self.getNum('MinGlobID'))])
            qrymap.addField('hitnum',evalue=1)
            qrymap.index('target')
            for qentry in qrymap.entries():
                qentry['hitnum'] = len(qrymap.index('target')[qentry['target']])
            #i# Reduce to best hit
            qrymap.compress(['query'],best=['raw','globid','qcov','tcov'])
            #i# Assuming qcov and pident are both 0-1 scales
            qrymap.makeField('qlen/tlen','protratio')
            qrymap.makeField('qlen-tlen','lendiff')
            #i# Check for SLiMSuite format names
            queries = qrymap.dataList(qrymap.entries(),'query')
            seqaccs = seqdb.dataList(seqdb.entries(),'accnum')
            goodacc = rje.listIntersect(seqaccs,queries)
            seqnames = seqdb.dataList(seqdb.entries(),'name')
            goodseq = rje.listIntersect(seqnames,queries)
            if rje.listDifference(goodseq,goodacc):
                self.printLog('#ACCNUM','SeqSuite GnSpAcc format recognised: translating sequence names to accnum')
                name2acc = {}; idx = 0
                for entry in seqdb.entries():
                    name2acc[entry['name']] = entry['accnum']
                    if entry['name'] == entry['accnum']: idx += 1
                self.printLog('#ACCNUM','%s name to accnum translations (%s identical)' % (rje.iLen(name2acc),rje.iStr(idx)))
                mapx = 0
                for qentry in qrymap.entries():
                    if qentry['query'] != name2acc[qentry['query']]:
                        qentry['query'] = name2acc[qentry['query']]
                        mapx += 1
                self.printLog('#QRYMAP','%s MMSeqs query name to accnum translations made' % (rje.iStr(mapx)))
            #i# hitmap ->  query,target:[query,target,evalue,raw,alnlen,pident,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov]
            if self.runMode(['assess']):
                hitmap = self.db('hitmap')
                hitmap.rankFieldByIndex('query','raw',newfield='rank',rev=True,absolute=True,lowest=True,unique=False,warn=True,highest=False)
                #i# Reduce to all best hits for RBH
                hitmap.dropEntriesDirect('rank',[1],inverse=True)

            ### ~ [2] Consolidate tables ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            ## ~ [2a] Annotated protein sequence table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            self.headLog('Annotated protein sequence table',line='-')
            # - protname
            seqdb.renameField('name','protname')
            # - protlen
            seqdb.renameField('length','protlen')
            # - protdesc
            seqdb.renameField('desc','protdesc')
            joinlist = [(seqdb,'accnum'),
                        (exondb,'id',['exons','exonlen']),
                        (transdb,'id',['parent','locus','start','end','strand','attributes']),
                        (qrymap,'query',['target','qcov','tcov','protratio','lendiff','alnlen','pident','globid','hitnum'])]
            # - accnum = parent mRNA ID from GFF
            # - exons = exon count (CDS feature) from GFF -> Might need to modify for other GFF Types
            # - exonlen = combined length of exons from GFF
            # - geneid = parent gene from GFF
            # - locus = location data parsed from GFF for mRNA
            # - strand
            # - start
            # - end
            # - attributes = mRNA attributes parsed from GFF
            # - bestref (qrymap:target)
            # - protcov (qrymap:qcov)
            # - refcov (qrymap:tcov)
            # - protratio (qrymap:(qlen/tlen))
            # - rbh = Whether it is a reciprocal best hit of a reference protein
            # - f1 = the F1 score = 2 x Pr x Recall / (Pr + Recall)
            #    |- Pr = TP / (TP + FP) = qcov
            #           |- TP = qcov
            #           |- FP = (1 - qcov)
            #    |- Recall = TP / (TP + FN)
            #           | = tcov
            protdb = db.joinTables('proteins',join=joinlist,newkey=['protname'],cleanup=True,delimit='\t',empties=True,check=False,keeptable=True,warnings=True)
            protdb.renameField('parent','geneid')
            protdb.renameField('target','bestref')
            protdb.renameField('qcov','protcov')
            protdb.renameField('tcov','refcov')
            protdb.dropFields(['gene','spec']) #?# Drop protdesc?
            protdb.fillBlanks(blank=0,fields=['protcov','refcov','protratio','lendiff','alnlen','pident','globid','hitnum'],fillempty=True,prog=True,log=True)
            # - rbh = whether bestref has protid as bestprot [Q. How to handle isoforms in Reference?]
            protdb.addField('rbh',evalue=0)
            protdb.addField('f1',evalue=0)
            for pentry in protdb.entries():
                if self.runMode(['assess']):
                    if pentry['protname'] in hitmap.indexDataList('query',pentry['bestref'],'target'): pentry['rbh'] = 1
                    elif pentry['accnum'] in hitmap.indexDataList('query',pentry['bestref'],'target'): pentry['rbh'] = 1
                if pentry['protcov']: pentry['f1'] = 2 * pentry['protcov'] * pentry['refcov'] / (pentry['protcov'] + pentry['refcov'])
            if save: protdb.saveToFile()

            # # Reference protein sequence table [assess mode]
            # - refprot
            # - reflen
            # - refdesc - read in from fasta?
            # - bestprot (hitmap:target)
            # - protcov (hitmap:tcov)
            # - refcov (hitmap:qcov)
            # - protratio (qrymap:(qlen/tlen))
            # - f1 = 2 * protcov * refcov / (protcov + refcov)
            if self.runMode(['assess']):
                hitmap.rename('refprot')
                hitmap.makeField('qcov+tcov','totcov')
                hitmap.makeField('qlen/tlen','protratio')
                hitmap.dropField('rank')
                hitmap.rankFieldByIndex('query','totcov',newfield='rank',rev=True,absolute=True,unique=True,warn=True)
                hitmap.dropEntriesDirect('rank',[1],inverse=True)
                hitmap.newKey(['query'])
                hitmap.renameField('query','refprot')
                hitmap.renameField('qlen','reflen')
                hitmap.renameField('target','bestprot')
                hitmap.renameField('tcov','protcov')
                hitmap.renameField('qcov','refcov')
                hitmap.addField('refdesc')
                hitmap.keepFields(['refprot','reflen','refdesc','bestprot','protcov','refcov','alnlen','pident'])
                hitmap.addField('f1',evalue=0.0)
                for pentry in hitmap.entries():
                    if pentry['protcov']: pentry['f1'] = 2 * pentry['protcov'] * pentry['refcov'] / (pentry['protcov'] + pentry['refcov'])
                refprot = self.obj['RefProt'].db('sequences')   # ['name','desc','gene','spec','accnum','length']
                for refseq in refprot.entries():
                    found = hitmap.data(refseq['name'])
                    name = 'name'
                    if not found: found = hitmap.data(refseq['accnum']); name = 'accnum'
                    if found: found['refdesc'] = refseq['desc']
                    else: hitmap.addEntry({'refprot':refseq[name],'reflen':refseq['length'],'refdesc':refseq['desc'],'bestprot':'',
                                           'protcov':0,'refcov':0,'protratio':0,'f1':0})
                if save: hitmap.saveToFile()

            # # Annotated genes from GFF
            # - geneid
            # - locus = location data parsed from GFF for mRNA
            # - strand
            # - start
            # - end
            # - isoforms = number of proteins
            # - maxprotlen = max protein length
            # - longest = protname of longest isoform
            # - attributes = mRNA attributes parsed from GFF
            #i# features -> ['locus','strand','start','end','source','ftype']: ['locus', 'source', 'ftype', 'start', 'end', 'score', 'strand', 'phase', 'attributes']
            genedb.renameField('id','geneid')
            genedb.renameField('attributes','geneinfo')
            genedb.dropField('parent')
            genedb.addField('isoforms',evalue=0)
            genedb.addField('maxprotlen',evalue=0)
            genedb.addField('longest',evalue="")
            genedb.addField('isoinfo',evalue="")
            for gene in genedb.entries():
                geneid = gene['geneid']
                for isoform in protdb.indexEntries('geneid',geneid):
                    gene['isoforms'] += 1
                    if isoform['protlen'] > gene['maxprotlen']:
                        gene['maxprotlen'] = isoform['protlen']
                        gene['longest'] = isoform['accnum']
                        gene['isoinfo'] = isoform['attributes']
            if save: genedb.saveToFile()

            # ## Proteins mapped onto reference
            # - protname
            # - refhit
            # - hitscore
            # - hitdesc
            descdb.renameField('query','protname')
            descdb.renameField('target','refhit')
            descdb.renameField('raw','hitscore')
            descdb.renameField('tcov','refcov')
            descdb.renameField('theader','hitdesc')
            descdb.rankFieldByIndex('protname','hitscore',newfield='rank',rev=True,absolute=True,lowest=False,unique=True,warn=True,highest=False)
            descdb.newKey(['protname','rank'])
            descdb.keepFields(['protname','rank','hitscore','pident','refcov','refhit','hitdesc'])
            for dentry in descdb.entries():
                dsplit = dentry['hitdesc'].split()
                if len(dsplit) > 1 and dsplit[0] == dentry['refhit']:
                    dentry['hitdesc'] = ' '.join(dsplit[1:])
            if self.debugging() or self.dev(): descdb.saveToFile()

        except: self.errorLog('%s.tidyTables error' % self.prog()); raise
#########################################################################################################################
    # def annotate(self):
        # replace Similar to: Similar to:
        #?# TopHits=INT for annotation carryover? (Use the dominant annotation)
    #!# Add a list of annotations to ignore/downweight, e.g. Uncharacterised protein.
#########################################################################################################################
    ### <3> ### MMseq2 Methods                                                                                          #
#########################################################################################################################
    def makeMMseqDB(self):      ### Checks and creates MMseq2 databases
        '''
        Checks and creates MMseq2 databases.
        '''
        try:### ~ [1] MMseq2 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Make MMseq2 databases',line='-')
            ## ~ [1a] Reference database ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            refdb = self.refMMDB()
            refprot = self.getStr('RefProt')
            if rje.checkForFile(refprot):
                if rje.exists(refdb) and not self.force():
                    self.printLog('#REFDB','{0} already exists (force=F)'.format(refdb))
                else:
                    mmcmd = 'mmseqs createdb {0} {1} --dbtype 1'.format(refprot,refdb)
                    self.loggedSysCall(mmcmd)
            elif self.runMode(['Annotate','Assess','MMseqs']):
                raise IOError('Reference proteome not found: {0}'.format(refprot))
            ## ~ [1b] Query database ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            seqdb = self.seqMMDB()
            seqin = self.getStr('SeqIn')
            if rje.checkForFile(seqin):
                if rje.exists(seqdb) and not self.force():
                    self.printLog('#SEQDB','{0} already exists (force=F)'.format(seqdb))
                else:
                    mmcmd = 'mmseqs createdb {0} {1} --dbtype 1'.format(seqin,seqdb)
                    self.loggedSysCall(mmcmd)
            elif self.runMode(['Annotate','Assess','MMseqs','Summarise']):
                raise IOError('Annotation proteome not found: {0}'.format(refprot))
            ### ~ [2] Check ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            allgood = True
            for filename in [refprot,refdb,seqin,seqdb]:
                if not rje.checkForFile(filename):
                    self.warnLog('File "%s" does not exist.' % filename,'file_missing')
                    allgood = False

            return allgood
        except: self.errorLog('%s.makeMMseqDB error' % self.prog()); raise
#########################################################################################################################
    def runMMseqSearch(self,reciprocal=True):      ### Runs MMseqs search
        '''
        Generate mmseq table:

        mmseqs search toad_proteins human_proteome toad2human /scratch/tmp/
        mmseqs filterdb toad2human toad2human-best --extract-lines 1
        mmseqs convertalis toad_proteins human_proteome toad2human-best toad2human-best.table --format-output "query,target,evalue,raw,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov"

        mmseqs convertalis toad_proteins human_proteome toad2human-best toad2human-best.table --format-output "query,target,evalue,raw,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov"
        '''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Run MMseq2 searches',line='-')
            refdb = self.refMMDB()
            seqdb = self.seqMMDB()
            tmpdir = self.getStr('TmpDir')
            searchdir = self.getStr('MMSearch')
            rje.mkDir(self,searchdir)
            outbase = '{0}{1}'.format(searchdir,self.basefile())
            if tmpdir != '$TMPDIR': rje.mkDir(self,tmpdir,True)
            self.printLog('#TMP','TmpDir: {0}'.format(tmpdir))
            ### ~ [2] Run ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            #!# Add mmsearchdir to output names to keep things clean. (And option to clean up everything at end)
            outfile = '{0}.mmsearch'.format(outbase)
            checkfile = '{0}.index'.format(outfile)
            if rje.exists(checkfile) and not self.force():
                self.printLog('#MMSEQ','{0} already exists (force=F)'.format(checkfile))
            else:
                mmcmd = 'mmseqs search {0} {1} {2} {3}'.format(seqdb,refdb,outfile,tmpdir)
                self.loggedSysCall(mmcmd)
            if not rje.checkForFile(checkfile):
                raise IOError('File "%s" not generated.' % checkfile)
            if not reciprocal: return True
            outfile = '{0}.invsearch'.format(outbase)
            checkfile = '{0}.index'.format(outfile)
            if rje.exists(checkfile) and not self.force():
                self.printLog('#MMSEQ','{0} already exists (force=F)'.format(checkfile))
            else:
                mmcmd = 'mmseqs search {1} {0} {2} {3}'.format(seqdb,refdb,outfile,tmpdir)
                self.loggedSysCall(mmcmd)
            if not rje.checkForFile(checkfile):
                raise IOError('File "%s" not generated.' % checkfile)

            return True
        except: self.errorLog('%s.runMMseqSearch error' % self.prog()); raise
#########################################################################################################################
    def bestMMseqSearch(self,reciprocal=True,tophits=1):      ### Filters MMseqs search to best hits
        '''
        Generate mmseq table:

        mmseqs filterdb toad2human toad2human-best --extract-lines 1
        '''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Filter MMseq2 searches',line='-')
            searchdir = self.getStr('MMSearch')
            rje.mkDir(self,searchdir)
            outbase = '{0}{1}'.format(searchdir,self.basefile())
            ### ~ [2] Run ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            infile = '{0}.mmsearch'.format(outbase)
            outfile = '{0}.mmsearch-best'.format(outbase)
            if tophits > 1: outfile = '{0}.mmsearch-top{1}'.format(outbase,tophits)
            else: tophits = 1
            checkfile = '{0}.index'.format(outfile)
            if rje.exists(checkfile) and not self.force():
                self.printLog('#MMSEQ','{0} already exists (force=F)'.format(checkfile))
            else:
                mmcmd = 'mmseqs filterdb {0} {1} --extract-lines {2}'.format(infile,outfile,tophits)
                self.loggedSysCall(mmcmd)
            if not rje.checkForFile(checkfile):
                raise IOError('File "%s" not generated.' % checkfile)
            if not reciprocal: return True
            infile = '{0}.invsearch'.format(outbase)
            outfile = '{0}.invsearch-best'.format(outbase)
            if tophits > 1: outfile = '{0}.invsearch-top{1}'.format(outbase,tophits)
            checkfile = '{0}.index'.format(outfile)
            if rje.exists(checkfile) and not self.force():
                self.printLog('#MMSEQ','{0} already exists (force=F)'.format(checkfile))
            else:
                mmcmd = 'mmseqs filterdb {0} {1} --extract-lines {2}'.format(infile,outfile,tophits)
                self.loggedSysCall(mmcmd)
            if not rje.checkForFile(checkfile):
                raise IOError('File "%s" not generated.' % checkfile)

            return True
        except: self.errorLog('%s.runMMseqSearch error' % self.prog()); raise
#########################################################################################################################
    def tabulateMMseqSearch(self,fields=None,reciprocal=True,loaddb=True,tophits=0):      ### Tabulate MMSearch methods
        '''
        Generate mmseq table:

        mmseqs convertalis toad_proteins human_proteome toad2human-best toad2human-best.table --format-output "query,target,evalue,raw,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov,theader"
        '''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Tabulate MMseq2 searches',line='-')
            db = self.db()
            qfields = hfields = fields
            if not fields:
                qfields = 'query,target,evalue,raw,alnlen,pident,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov,theader'
                hfields = 'query,target,evalue,raw,alnlen,pident,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov'
            qrymap = self.getStr('MMQryMap')
            hitmap = self.getStrLC('MMHitMap')
            refdb = self.refMMDB()
            seqdb = self.seqMMDB()
            searchdir = self.getStr('MMSearch')
            rje.mkDir(self,searchdir)
            inbase = '{0}{1}'.format(searchdir,self.basefile())
            ### ~ [2] Run ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            ## ~ [2a] Query vs Hit ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            outfile = '{0}.mmsearch'.format(inbase)
            if tophits == 1: outfile = '{0}.mmsearch-best'.format(inbase)
            elif tophits > 1: outfile = '{0}.mmsearch-top{1}'.format(inbase,tophits)
            if rje.exists(qrymap) and not self.force():
                self.printLog('#MMSEQ','{0} already exists (force=F)'.format(qrymap))
            else:
                mmcmd = 'mmseqs convertalis {0} {1} {2} {3} --format-output "{4}"'.format(seqdb,refdb,outfile,qrymap,qfields)
                self.loggedSysCall(mmcmd)
            if not rje.checkForFile(qrymap):
                raise IOError('File "%s" not generated.' % qrymap)
            if loaddb:
                #qdb = db.addTable(qrymap,mainkeys=['query','target'],expect=True,headers=qfields.split(','),name='qrymap')
                qdb = db.addTable(qrymap,mainkeys=['#'],expect=True,headers=qfields.split(','),name='qrymap')
                qdb.makeField(formula='#query#:#target#',fieldname='hitpair')
                qdb.rankFieldByIndex('hitpair','raw',newfield='alnid',rev=True,absolute=True,unique=True,warn=True)
                qdb.newKey(['query','target','alnid'])
                qdb.dropFields(['#','hitpair'])
                qdb.dataFormat(dbformats)
                pident = qdb.dataList(qdb.entries(),'pident',sortunique=False,empties=False)
                if max(pident) > 1.0:   #!# New mmseq2 with 0-100 pident range
                    for entry in qdb.entries(): entry['pident'] = entry['pident']/100.0
            if not reciprocal: return True
            ## ~ [2b] Reference vs Query ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            outfile = '{0}.invsearch'.format(inbase)
            if tophits == 1: outfile = '{0}.invsearch-best'.format(inbase)
            elif tophits > 1: outfile = '{0}.invsearch-top{1}'.format(inbase,tophits)
            if rje.exists(hitmap) and not self.force():
                self.printLog('#MMSEQ','{0} already exists (force=F)'.format(hitmap))
            else:
                mmcmd = 'mmseqs convertalis {1} {0} {2} {3} --format-output "{4}"'.format(seqdb,refdb,outfile,hitmap,hfields)
                self.loggedSysCall(mmcmd)
            if not rje.checkForFile(hitmap):
                raise IOError('File "%s" not generated.' % hitmap)
            if loaddb:
                #hdb = db.addTable(hitmap,mainkeys=['query','target'],expect=True,headers=hfields.split(','),name='hitmap')
                hdb = db.addTable(hitmap,mainkeys=['#'],expect=True,headers=hfields.split(','),name='hitmap')
                hdb.makeField(formula='#query#:#target#',fieldname='hitpair')
                hdb.rankFieldByIndex('hitpair','raw',newfield='alnid',rev=True,absolute=True,unique=True,warn=True)
                hdb.newKey(['query','target','alnid'])
                hdb.dropFields(['#','hitpair'])
                hdb.dataFormat(dbformats)
                pident = hdb.dataList(hdb.entries(),'pident',sortunique=False,empties=False)
                if max(pident) > 1.0:   #!# New mmseq2 with 0-100 pident range
                    for entry in hdb.entries(): entry['pident'] = entry['pident']/100.0
            return True
        except: self.errorLog('%s.tabulateMMseqSearch error' % self.prog()); raise
#########################################################################################################################
    ### <4> ### Assess Methods                                                                                          #
#########################################################################################################################
    def statistics(self,assess=True,save=True):      ### Checks and creates MMseq2 databases
        '''
        4. Calculate statistics:

        For qry:ref - calculate the qrylen/reflen [ANNOTATION] = calculate the best per gene [ASSEMBLY]
        Median, Mean and 95% CI of ratio?
        Also the F1 score = 2 x Pr x Recall / (Pr + Recall)
            |- Pr = TP / (TP + FP)
            |- Recall = TP / (TP + FN)
        Duplicity = Av. Qry Genes per Ref Gene (with hits)
        Compression = Av. Ref Genes per Qry Gene (with hits)
        Multiplicity = Total no. Qry Genes (Qry vs Ref) / Total no Ref Genes (Ref vs Qry)
        Orthology = % RBH Genes
        Purity = % Qry Genes = summed protcov [Could have cut-off too?]
        Completeness = % Ref Genes (=Recall) = summed
        NOTE: Might be able to short cut a lot of this using mmseq2 output.

        - Calculate F1 score distributions for both Qry and Reference (0 if 100% missing) => median F1?

        #i# Table: proteins
        # - protname
        # - protlen
        # - protdesc
        # - protid = parent mRNA ID from GFF
        # - exons = exon count (CDS feature) from GFF -> Might need to modify for other GFF Types
        # - exonlen = combined length of exons from GFF
        # - geneid = parent gene from GFF
        # - locus = location data parsed from GFF for mRNA
        # - strand
        # - start
        # - end
        # - attributes = mRNA attributes parsed from GFF
        # - bestref (qrymap:target)
        # - protcov (qrymap:qcov)
        # - refcov (qrymap:tcov)
        # - protratio (qrymap:(qlen/tlen))
        # - rbh = Whether it is a reciprocal best hit of a reference protein
        # - f1 = the F1 score = 2 x Pr x Recall / (Pr + Recall)
        #    |- Pr = TP / (TP + FP) = qcov
        #           |- TP = qcov
        #           |- FP = (1 - qcov)
        #    |- Recall = TP / (TP + FN)
        #           | = tcov

        #i# Table: refprot
        # - refprot
        # - reflen
        # - refdesc - read in from fasta?
        # - bestprot (hitmap:target)
        # - protcov (hitmap:tcov)
        # - refcov (hitmap:qcov)
        # - protratio (qrymap:(qlen/tlen))
        # - f1 = 2 * protcov * refcov / (protcov + refcov)
        '''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            #i# NOTE: Assess and Summarise share core query stats - Assess has reference data too
            db = self.db()
            refdb = None
            if assess:
                refdb = self.db('refprot')
                refdb = db.copyTable(refdb,'refstats') # For annnotation
            qrydb = self.db('proteins')
            qrydb = db.copyTable(qrydb,'qrystats') # For annnotation
            ### ~ [2] Calculate ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            stats = {}
            ## ~ [2a] Compress Protein Table to Best Gene Hits ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            qrydb.dropFields(['protdesc'])
            qrydb.addField('bigratio',evalue=0)
            qrydb.dataFormat({'protratio':'float'})
            for entry in qrydb.entries():
                if entry['protratio'] > 1:
                    entry['bigratio'] = 1.0 / entry['protratio']
                    entry['protratio'] = 0
            refhits = qrydb.dataList(qrydb.entries(),'bestref',sortunique=True)
            refhitnum = len(refhits)
            qrydb.addField('isoforms',evalue=1)
            qrydb.compress(['geneid'],default='max',rules={'start':'min','isoforms':'sum'})

            ## ~ [2b] Gene Hits ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            for entry in qrydb.entries():
                if (1.0 - entry['bigratio']) < (1.0 - entry['protratio']):
                    entry['protratio'] = 1.0 / entry['bigratio']
            qrydb.dropFields(['protname','protid','bigratio','strand','start','end','bestref'])
            qrydb.addField('table',evalue='qry')
            qrydb.addField('genes',evalue=1)
            qryhits = db.copyTable(qrydb,'qryhits') # For annnotation
            qryhits.renameField('genes','hom')
            qryhits.dropEntriesDirect('protratio',[0])
            stats['duplicity'] = qryhits.entryNum() / float(refhitnum)
            ratios = qryhits.dataList(qryhits.entries(),'protratio',sortunique=False,empties=False)
            (ratmean,ratsd) = rje.meansd(ratios)
            ratmedian = rje.median(ratios)
            stats['protratio_mean'] = ratmean
            stats['protratio_sd'] = ratsd
            stats['protratio_median'] = ratmedian
            qryhits.compress(['table'],default='mean',rules={'hom':'sum','rbh':'sum'})
            qentry = qryhits.data('qry')
            stats['f1_hits'] = qentry['f1']     # f1_hits is the mean f1 score excluding no-hits
            stats['homology'] = 100.0 * qentry['hom'] / qrydb.entryNum()
            stats['orthology'] = 100.0 * qentry['rbh'] / qrydb.entryNum()

            ## ~ [2c] Gene Total ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            f1dist = qrydb.dataList(qrydb.entries(),'f1',sortunique=False)
            if assess:
                stats['multiplicity'] = float(qrydb.entryNum()) / refdb.entryNum()
            qrydb.compress(['table'],default='mean',rules={'genes':'sum','isoforms':'sum'})
            sentry = qrydb.data('qry')
            for field in ['genes','isoforms','exons','protlen','exonlen']: stats[field] = sentry[field]
            stats['purity'] = sentry['protcov']
            stats['mean_f1'] = sentry['f1']

            ## ~ [2d] Ref hits ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if assess:
                qryhitnum = len(refdb.dataList(refdb.entries(),'bestprot',sortunique=True))
                stats['compression'] = float(qryhitnum) / refdb.entryNum()
                refdb.addField('table',evalue='ref')
                refdb.compress(['table'],default='mean',rules={'genes':'sum','isoforms':'sum'})
                rentry = refdb.data('ref')
                stats['completeness'] = rentry['refcov']

            ## ~ [2e] Final stats ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                # final stats
                stats['f1'] = (2 * stats['purity'] * stats['completeness']) / (stats['purity'] + stats['completeness'])
                stats['completeness'] = 100.0 * stats['completeness']
            stats['purity'] = 100.0 * stats['purity']

            ### ~ [3] Generate and save stats table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            # Genome, Reference, Genes, Isoforms, Mean exons, Mean exon length, Mean protein length, Completeness, Purity, Homology, Orthology, Mean prot length ratio, Median prot length ratio, SD prot length ratio
            outstats = ['genes','isoforms','exons','exonlen','protlen','completeness','purity','homology','orthology','protratio_mean','protratio_median','protratio_sd']
            # Duplicity = Av. Qry Genes per Ref Gene (with hits)
            # Compression = Av. Ref Genes per Qry Gene (with hits)
            # Multiplicity = Total no. Qry Genes (Qry vs Ref) / Total no Ref Genes (Ref vs Qry)
            outstats += ['duplicity','compression','multiplicity','f1','f1_hits','mean_f1']
            statfields = ['seqin','refdb'] + outstats    #!# Replace with correct order
            stats['seqin'] = rje.stripPath(self.getStr('SeqIn'))
            stats['refdb'] = rje.stripPath(self.getStr('RefProt'))
            if not self.db('stats'):
                for field in statfields[0:]:
                    if field not in stats: statfields.remove(field)
                db.addEmptyTable('stats',statfields,['seqin','refdb'])
            self.db('stats').addEntry(stats)
            if save: self.db('stats').saveToFile()
            return stats
        except: self.errorLog('%s.assess error' % self.prog()); raise
#########################################################################################################################
    ### <5> ### Annotate Methods                                                                                        #
#########################################################################################################################
    def newDesc(self,seqdesc):  ### Returns new name from parsed sequence description based on MAKER rules
        '''
        Returns new name from parsed sequence description based on MAKER rules.
        :param seqdesc:
        :return:
        '''
        try:### ~ [1] Parse ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            ## ~ [1a] SwissProt with Gene ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if rje.matchExp('(.*?)\s+OS=(.*?)\s+GN=(.*?)\s+PE=',seqdesc):
                (desc,org,name) = rje.matchExp('(.*?)\s+OS=(.*?)\s+GN=(.*?)\s+PE=',seqdesc)
                return 'Similar to {0}: {1} [{2}]'.format(name,desc,org)
            ## ~ [1b] SwissProt without Gene ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if rje.matchExp('(.*?)\s+OS=(.*?)\s+PE=',seqdesc):
                (desc,org) = rje.matchExp('(.*?)\s+OS=(.*?)\s+PE=',seqdesc)
                return 'Similar to {0} [{1}]'.format(desc,org)
            ## ~ [1x] Other ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if seqdesc: return 'Similar to {0}'.format(seqdesc)
            return ''
        except: self.errorLog('%s.newDesc error' % self.prog()); raise
#########################################################################################################################
    ### <6> ### Taxonomy Methods                                                                                        #
#########################################################################################################################
    def setTaxRanks(self): ### Sets up and returns taxranks high -> low.
        '''
        Sets up and returns taxranks high -> low
        :return: taxranks list
        '''
        taxranks = 'species, species subgroup, species group, subgenus, genus, subtribe, tribe, subfamily, family, superfamily, parvorder, infraorder, suborder, order, superorder, infraclass, subclass, class, superclass, subphylum, phylum, superphylum, subkingdom, kingdom, superkingdom'.split(', ')   # List of descending taxonomic rank types
        taxranks.reverse()
        # - TaxLevels=LIST  : List of taxonomic levels to report (* for superkingdom and below) ['*']
        if '*' not in self.list['TaxLevels']:
            badranks = rje.listDifference(self.list['TaxLevels'],taxranks)
            if badranks:
                for bad in badranks:
                    self.warnLog('"{0}" taxlevels=LIST rank not recognised'.format(bad))
                self.warnLog('{0} taxlevels=LIST ranks not recognised'.format(len(badranks)))
            newranks = []
            for rank in taxranks:
                if rank in self.list['TaxLevels']: newranks.append(rank)
            taxranks = newranks
            if not taxranks: raise ValueError('No recognised taxonomic levels in taxlevels=LIST')
        self.printLog('#RANKS','{0} taxonomic ranks to consider: {1}'.format(len(taxranks),', '.join(taxranks)))
        return taxranks
#########################################################################################################################
    def taxonomy(self):  ### Performs/parses mmseqs2 easy taxonomy and collates gene/sequence ratings
        '''
        Performs/parses mmseqs2 easy taxonomy and collates gene/sequence ratings. See main run docstring for details.
        '''
        try:### ~ [0] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Setup Taxonomy Data',line='-')
            db = self.db()
            tmpdir = self.getStr('TmpDir')
            taxbase = self.getStr('TaxBase')
            assembly = self.obj['Assembly']
            ## ~ [1a] Set up TaxRanks ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            mintaxnum = self.getInt('MinTaxNum') # Minimum gene count in main dataset to keep taxon, else merge with higher level [2]
            self.printLog('#MINTAX','Minimum taxa count threshold (all isoforms): {0}'.format(mintaxnum))
            #!# Add taxranks to settings that can be set
            taxranks = self.setTaxRanks()
            self.list['TaxRanks'] = taxranks = ['no rank'] + taxranks  #i# Add 'no rank' for root and 'cellular organisms'
            #self.bugPrint(taxranks)
            ## ~ [1b] Tables created and loaded ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            #i# Parsed seqin and GFF during setup()
            # loci : ['locus', 'start', 'end', 'sequence']
            locdb = self.db('loci')     # Scaffolds -> locus = sequences/trans
            if not locdb:
                if not assembly: raise IOError('Need GFF or Assembly file')
                locdb = db.addEmptyTable('loci',['locus', 'start', 'end', 'sequence'],['locus'])
                for seq in assembly.seqs():
                    locdb.addEntry({'locus':assembly.shortName(seq), 'start':1, 'end':assembly.seqLen(seq), 'sequence':''})
            # sequences : ['name', 'desc', 'gene', 'spec', 'accnum', 'length']
            #seqdb = self.db('sequences')    # Proteins -> name = protdb:id
            # gene : ['#', 'locus', 'source', 'start', 'end', 'strand', 'attributes', 'name', 'id', 'parent']
            genedb = self.db('gene')    # Genes -> locus = loci:locus
            self.debug(genedb)
            # trans : ['#', 'locus', 'source', 'start', 'end', 'strand', 'attributes', 'name', 'id', 'parent']
            protdb = self.db('trans')   # Proteins: should map onto sequences -> parent = genedb:id
            if protdb:
                protdb.newKey(['id'])
                genedb.newKey(['id'])
            else:
                # sequences : ['name', 'desc', 'gene', 'spec', 'accnum', 'length']
                protdb = self.db('sequences')    # Proteins -> name = protdb:id
                protdb.addFields(['id','parent','locus'])
                for pentry in protdb.entries():
                    pentry['id'] = pentry['name']
                    pentry['parent'] = pentry['name']
                    #!# Will need to improve this
                    pentry['locus'] = '.'.join(pentry['name'].split('.')[:-2])
                    if pentry['locus'] not in locdb.dataKeys():
                        raise ValueError('Cannot parse protein sequence names as locus.RF.ORF')
                protdb.newKey(['id'])
                self.printLog('#NOTE','GFF and contig outputs not currently available for ORF input. (Needs GFF.)')
            ## ~ [1c] Check for existing taxonomy output tables ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            runmmseqs = not rje.checkForFiles(filelist=['_report','_lca.tsv'],basename=taxbase,log=self,cutshort=False,ioerror=False,missingtext='Not found.')
            if not runmmseqs:
                if self.force():
                    self.warnLog('Previous easy-taxonomy results detected and force=True: will be overwritten')
                    runmmseqs = True
                else:
                    self.printLog('#TAXRUN','Previous easy-taxonomy results detected: force=False')
            ## ~ [1d] Check for TaxDB ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if runmmseqs:
                try:
                    mmseq = os.popen('mmseqs').readline().split()[0]
                    if mmseq == 'MMseqs2':
                        self.printLog('#MMSEQ2', 'MMseqs2 found')
                    else:
                        raise ValueError('MMseqs2 installation not found. Aborted easy-taxonomy run.')
                except:
                    raise ValueError('MMseqs2 installation not found. Aborted easy-taxonomy run.')
                if not rje.checkForFile(self.getStr('TaxDB')):
                    raise IOError('TaxDB "{0}" not found. Aborted easy-taxonomy run.'.format(self.getStr('TaxDB')))
            ## ~ [1e] Load sequence subsets for outputs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            # - TaxSubsets=FILELIST : Files with sets of assembly input sequences (matching GFF) to summarise []
            taxsubsets = {}    # Dictionary of {prefix:seqname list}
            for subfile in self.list['TaxSubsets']:
                prefix = rje.baseFile(subfile,strip_path=True)
                seqs = open(subfile).read().split()
                taxsubsets[prefix] = seqs
                self.printLog('#SUBSET','{0} sequence IDs loaded for "{1}"'.format(rje.iLen(seqs),prefix))

            ### ~ [2] Run easy-taxonomy ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            #i# If required, run mmseqs easy-taxonomy $QUERY $TARGETDB $PREFIX.easy tmp
            if runmmseqs:
                self.headLog('Run easy-taxonomy', line='-')
                self.printLog('#TMP', 'TmpDir: {0}'.format(tmpdir))
                mmcmd = 'mmseqs easy-taxonomy {0} {1} {2} {3}'.format(self.getStr('SeqIn'), self.getStr('TaxDB'), taxbase, tmpdir)
                self.loggedSysCall(mmcmd)
                if not rje.checkForFiles(filelist=['_report','_lca.tsv'],basename=taxbase,log=self,cutshort=False,ioerror=False,missingtext='Not found.'):
                    raise IOError('easy-taxonomy output not generated.')
                self.printLog('#SYS','Check {0}.sys.log for mmseqs2 run details.'.format(self.baseFile()))

            ### ~ [3] Parse easy-taxonomy ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Parse easy-taxonomy', line='-')
            reportfile = '{0}_report'.format(taxbase)
            repdb = db.addTable(reportfile,mainkeys=['#'],datakeys='All',delimit='\t',headers=['taxperc','taxnum','taxpure','taxrank','taxid','taxname'],ignore=[''],name='report',expect=True)
            #i# Keep TaxID as strings
            repdb.dataFormat({'taxperc':'float','taxnum':'int','taxpure':'int'}) #,'taxid':'int'})
            taxtree = {}    # {(rank,id,name):{taxtree}}
            levels = []     # List of (rank,id,name) tuples corresponding to current level being parsed
            #X# taxmapping = {} # {(rank,id,name):(rank,id,name)} -> Will be used to reclassify lca table
            taxmapping = {} # {id:id} -> Will be used to reclassify lca table
            taxcounts = {}  # {id:taxnum}
            taxlineage = self.dict['TaxLineage'] = {} # {(rank,id,name):[list of higher levels]}
            taxtuple = self.dict['TaxTuple'] = {} # {id:(rank,id,name)}
            taxparent = {}  # {id: parent id}
            ## ~ [3a] Parse taxonomy tree ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            rx = 0.0; rtot = repdb.entryNum()
            for rentry in repdb.entries(sorted=True):
                self.progLog('\r#REPORT','Parsing taxonomy: {0:.2f}%'.format(rx/rtot)); rx += 100.0
                #self.bugPrint(rentry)
                #i# Set up root
                if rentry['taxname'] == 'unclassified':
                    taxtuple['0'] = ('no rank','0','unclassified')
                    taxcounts['0'] = rentry['taxnum']
                    taxlineage[('no rank','0','unclassified')] = []
                    continue
                if rentry['taxname'] == 'root':
                    levels = [('no rank','1','root')]
                    taxtree[('no rank','1','root')] = {}
                    taxtuple['1'] = ('no rank','1','root')
                    taxcounts['1'] = rentry['taxnum']
                    taxlineage[('no rank','1','root')] = []
                    continue
                #i# Parse levels
                i = len(rje.matchExp('^(\s+)',rentry['taxname'])[0]) / 2
                levels = levels[:i]
                #if rx < 1000: self.debug('Level {1}::{0}\n'.format(levels,i))
                mytree = taxtree
                for level in levels:
                    if level in mytree:
                        mytree = mytree[level]
                    elif level[0] in taxranks:
                        raise ValueError('{0} missing from {1}'.format(level,rje.sortKeys(mytree)))
                taxon = (rentry['taxrank'],rentry['taxid'],rentry['taxname'][i*2:])
                if taxon in mytree: raise ValueError
                #i# Map taxa based on absence from taxranks
                if taxon[0] not in taxranks and taxon[2] not in ['unclassified', 'root', 'cellular organisms']:
                    i = len(levels) - 1
                    while levels[i][0] not in taxranks: i -= 1
                    taxmapping[taxon[1]] = levels[i][1]
                    #i# Check for additional mapping due to low occurrence levels
                    while taxmapping[taxon[1]] in taxmapping:
                        taxmapping[taxon[1]] = taxmapping[taxmapping[taxon[1]]]
                    #self.debug(taxmapping)
                #!# Add additional mapping due to small numbers
                elif rentry['taxnum'] < mintaxnum:
                    #i# Just map up and then iteratively map
                    taxmapping[taxon[1]] = levels[-1][1]
                    while taxmapping[taxon[1]] in taxmapping:
                        taxmapping[taxon[1]] = taxmapping[taxmapping[taxon[1]]]
                    mytree[taxon] = {}
                else:
                    mytree[taxon] = {}
                    taxcounts[taxon[1]] = rentry['taxnum']
                taxparent[taxon[1]] = levels[-1][1]
                while taxparent[taxon[1]] in taxmapping:
                    taxparent[taxon[1]] = taxmapping[taxparent[taxon[1]]]
                taxlineage[taxon] = levels[0:]
                levels.append(taxon)
                taxtuple[taxon[1]] = taxon
                #self.bugPrint('TaxTree::{0}\n'.format(taxtree))
                #self.debug('Levels::{0}\n'.format(levels))
            self.printLog('\r#REPORT', 'Parsing taxonomy complete')
            ## ~ [3b] Process lca table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            lcafile = '{0}_lca.tsv'.format(taxbase)
            lcadb = db.addTable(lcafile,mainkeys=['protname'],delimit='\t',headers=['protname','taxid','taxrank','taxname'],ignore=[''],name='lca',expect=True)
            lcadb.addField('gene')
            lcadb.addField('seqname')
            lx = 0.0; ltot = lcadb.entryNum()
            for lentry in lcadb.entries():
                self.progLog('\r#LCA','Parsing lca table: {0:.2f}%'.format(lx/ltot)); lx += 100.0
                pentry = protdb.data(lentry['protname'])
                if not pentry:
                    raise ValueError('Problem mapping lca protein names onto annotation ({0} not found)'.format(lentry['protname']))
                lentry['gene'] = pentry['parent']
                lentry['seqname'] = pentry['locus']
                if lentry['taxid'] in taxmapping:
                    lentry['taxid'] = taxmapping[lentry['taxid']]
                    lentry['taxrank'] = taxtuple[lentry['taxid']][0]
                    lentry['taxname'] = taxtuple[lentry['taxid']][2]
            self.printLog('\r#LCA', 'Parsing lca table complete')

            ### ~ [4] Compress to genes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Compress easy-taxonomy to gene level', line='-')
            #?# Might want to give partial credit per protein, rather than keeping "best" but will this break output that expects integers?
            #?# Keep the most popular lowest level in the case of ties = taxcounts[lentry['taxid']]
            lcadb.addField('protnum',evalue=1)
            lcadb.compress(['gene'], rules={'taxid':'list','protnum':'sum'}, default='str', best=[], joinchar='|')
            if genedb:  #i# Currently unavailable for ORF mode
                lcadb.addFields(['start','end','strand'])
            lx = 0.0; ltot = lcadb.entryNum()
            for lentry in lcadb.entries():
                self.progLog('\r#LCA','Assigning gene taxa: {0:.2f}%'.format(lx/ltot)); lx += 100.0
                try:
                    if genedb:  # i# Currently unavailable for ORF mode
                        gentry = genedb.data(lentry['gene'])
                        lentry['start'] = gentry['start']
                        lentry['end'] = gentry['end']
                        lentry['strand'] = gentry['strand']
                except:
                    self.warnLog('Problem updating start/end positions for gene "{0}"'.format(lentry['gene']),suppress=True)
                idlist = lentry['taxid'].split('|')
                #self.bugPrint(lentry)
                if len(idlist) > 1:
                    idsort = []
                    for id in idlist:
                        if id == '0': continue
                        try:
                            idsort.append((taxranks.index(taxtuple[id][0]),taxcounts[id],id))
                        except:
                            self.errorLog('Problem with {0}'.format(lentry))
                    idsort.sort(reverse=True)
                    #self.debug(idsort)
                    lentry['taxid'] = idsort[0][2]
                    lentry['taxrank'] = taxtuple[lentry['taxid']][0]
                    lentry['taxname'] = taxtuple[lentry['taxid']][2]
            self.printLog('\r#LCA', 'Assigning gene taxa complete')
            #?# Should we re-apply the mintaxnum threshold here?
            lcafile = '{0}.lca_genes.tsv'.format(taxbase)
            lcadb.setFields(['seqname','gene','protnum','taxid','taxrank','taxname','start','end','strand'])
            lcadb.newKey(['seqname', 'gene'])

            ### ~ [5] Compress to taxon counts by sequence ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Compress to taxon counts by sequence', line='-')
            #i# Now make the core taxonomic assignment table with numbers per sequence for all represented taxonomic levels
            # * `seqname` = assembly sequence name
            # * `genenum` = number of genes parsed for that sequence
            # * `protnum` = number of proteins parsed for that sequence
            # * `taxrank` = taxonomic rank of rating
            # * `genetax` = number of genes with assignment at that level in that sequence
            # * `taxid` = taxonomic label identifier number
            # * `taxname` = taxonomic label name at that rank
            # * `taxperc` = percentage assignment to this rank or lower
            # * `taxnum` = number of genes assigned to this rank or lower
            # * `taxpure` = number of genes assigned to this rank specifically
            taxdb = db.copyTable(lcadb,'taxbyseq')
            #['seqname','gene','protnum','taxid','taxrank','taxname'])
            taxdb.addField('genenum',evalue=1)
            taxdb.addField('taxnum',evalue=1)
            taxdb.addField('taxpure',evalue=1)
            taxdb.compress(['seqname','taxid','taxrank','taxname'],rules={'gene':'list'},default='sum')
            taxdb.dropField('gene')
            taxdb.setFields(['seqname','genenum','protnum','taxid','taxrank','taxname','taxnum','taxpure'])
            #i# Calculate numbers
            genenum = {}
            protnum = {}
            for tentry in taxdb.entries():
                if tentry['seqname'] not in genenum: genenum[tentry['seqname']] = 0
                if tentry['seqname'] not in protnum: protnum[tentry['seqname']] = 0
                genenum[tentry['seqname']] += tentry['genenum']
                protnum[tentry['seqname']] += tentry['protnum']
            taxdb.dropEntriesDirect('taxid',['0'])
            #i# Cycle through each taxid and update the taxnum for each parent in levels. (Add if needed)
            taxdb.newKey(['seqname', 'taxid'])
            for tentry in taxdb.entries():
                tentry['genenum'] = genenum[tentry['seqname']]
                tentry['protnum'] = protnum[tentry['seqname']]
                taxid = tentry['taxid']
                taxon = taxtuple[taxid]
                levels = taxlineage[taxon]
                for level in levels:
                    if level[0] in taxranks:
                        upkey = (tentry['seqname'],level[1])
                        uentry = taxdb.data(upkey)
                        if not uentry:
                            uentry = taxdb.addEntry({'seqname':tentry['seqname'],'genenum':tentry['genenum'],'protnum':tentry['protnum'],'taxid':level[1],'taxrank':level[0],'taxname':level[2],'taxnum':0,'taxpure':0})
                        uentry['taxnum'] += tentry['taxpure']

            ### ~ [6] Refilter on mintaxnum ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            repdb = db.copyTable(taxdb,'full_report')
            repdb.keepFields(['seqname', 'taxrank', 'taxid', 'taxname', 'taxnum', 'taxpure'])
            repdb.compress(['taxid'],default='str',rules={'taxnum':'sum', 'taxpure':'sum'})
            ## ~ [6a] Map low frequency TaxIDs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            minmap = {}     # {id:id} mapping for taxa not meeting mintaxnum
            prerepx = repdb.entryNum(); pretaxx = taxdb.entryNum()
            for i in range(1,mintaxnum):
                self.progLog('\r#MAP', 'Mapping n={0} taxid to higher levels'.format(i))
                while i in repdb.index('taxnum',force=True):
                    for rentry in repdb.indexEntries('taxnum',i):
                        taxid = rentry['taxid']
                        mapid = taxparent[taxid]
                        #i# Already mapped? If so, map up higher
                        while mapid in minmap: mapid = minmap[mapid]
                        minmap[taxid] = mapid
                        mentry = repdb.data(mapid)
                        mentry['taxpure'] += rentry['taxpure']
                        repdb.dropEntry(rentry)
                        #i# Update taxdb
                        for tentry in taxdb.indexEntries('taxid',taxid):
                            seqname = tentry['seqname']
                            taxdb.data((seqname,mapid))['taxpure'] += tentry['taxpure']
                            taxdb.dropEntry(tentry)
            self.printLog('\r#MAP','{0} taxid < mintaxnum mapped to higher levels'.format(rje.iLen(minmap)))
            self.printLog('\r#MAP','{0} taxid -> {1} taxid for report'.format(rje.iStr(prerepx),repdb.entryNum()))
            self.printLog('\r#MAP','{0} sequence:taxid pairs -> {1} sequence:taxid pairs'.format(rje.iStr(pretaxx),rje.iStr(taxdb.entryNum())))
            ## ~ [6b] Sum taxnums across ranks to generate genetax numbers ~~~~~~~~~~~~~~~~~~~~~~~~ ##
            self.progLog('\r#GENES','Calculating number of rated genes per taxonomic level...')
            genetax = {}
            for tentry in taxdb.entries():
                if tentry['seqname'] not in genetax: genetax[tentry['seqname']] = {'*':0}
                if tentry['taxrank'] not in genetax[tentry['seqname']]: genetax[tentry['seqname']][tentry['taxrank']] = 0
                genetax[tentry['seqname']]['*'] += tentry['taxpure']
                genetax[tentry['seqname']][tentry['taxrank']] += tentry['taxnum']
            taxdb.addField('genetax')
            taxdb.addField('taxperc')
            for tentry in taxdb.entries():
                tentry['genetax'] = genetax[tentry['seqname']][tentry['taxrank']]
                tentry['taxperc'] = 100.0 * tentry['taxnum'] / genetax[tentry['seqname']]['*']
            self.printLog('\r#GENES', 'Calculation of number of rated genes per taxonomic level complete.')
            self.debug(taxdb.entries()[0])
            self.debug(taxdb.fields())
            ## ~ [6c] Save to taxdb to file ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            taxdb.setFields(['seqname', 'genenum', 'protnum', 'taxrank', 'genetax', 'taxid', 'taxname', 'taxperc', 'taxnum', 'taxpure'])
            if self.getBool('TaxBySeq'):
                taxdb.saveToFile('{0}.taxbyseq.tsv'.format(taxbase),sfdict={'taxperc':4})

            ### ~ [7] Generate Taxolotl reports ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Generate Taxolotl reports', line='-')
            revranks = taxranks[0:]
            revranks.reverse()   # Now bigger index is higher level
            bestranks = {}  # {level:(taxid,count)}
            for prefix in [''] + taxsubsets.keys():
                ## ~ [7a] ~ Set table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                table = 'taxolotl_report'
                if prefix: table = '{0}.taxolotl_report'.format(prefix)
                repdb = db.copyTable(taxdb,table)
                if prefix:
                    self.headLog(prefix, line='~')
                    repdb.dropEntriesDirect('seqname',taxsubsets[prefix],inverse=True)
                repdb.keepFields(['seqname', 'taxrank', 'taxid', 'taxname', 'taxnum', 'taxpure'])
                repdb.compress(['taxid'],default='str',rules={'taxnum':'sum', 'taxpure':'sum','genenum':'sum', 'protnum':'sum'})
                genenum = 0
                for rentry in repdb.entries():
                    genenum += rentry['taxpure']
                repdb.addField('taxperc')
                for rentry in repdb.entries():
                    rentry['taxperc'] = rje.dp(100.0 * rentry['taxnum'] / genenum,4)
                ## ~ [7b] Sort out ordering ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                repdb.addField('#')
                repdb.addField('taxtext')
                repsort = []    # This is going to be a list of tuple lists
                for rentry in repdb.entries():
                    taxid = rentry['taxid']
                    taxon = taxtuple[taxid]
                    sorter = []
                    for taxup in taxlineage[taxon]:
                        if repdb.data(taxup[1]):
                            sorter.append((repdb.data(taxup[1])['taxnum'],taxup[1]))
                    sorter.append((rentry['taxnum'],taxid))
                    repsort.append(sorter)
                repsort.sort(reverse=True)
                ## ~ [7c] Work through taxa ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                repkeys = repdb.dataKeys()  # Slowly work through these, removing them
                rx = 1
                for sorter in repsort:
                    ix = -1
                    for (taxnum,taxid) in sorter:
                        ix += 1
                        if taxid in repkeys:
                            #i# Update taxon rentry and mark as done by removing from repkeys
                            repkeys.remove(taxid)
                            rentry = repdb.data(taxid)
                            rentry['#'] = rx; rx += 1
                            #taxon = taxtuple[taxid]
                            rentry['taxtext'] = '  ' * ix + rentry['taxname']
                            taxrank = rentry['taxrank']
                            #i# Set best lineage. May be over-written if bestlineage=F
                            if taxrank not in bestranks: bestranks[taxrank] = (taxnum, taxid)
                ## ~ [7d] Output ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                repdb.newKey(['#'])
                repdb.saveToFile('{0}.{1}.tsv'.format(taxbase,table),delimit='\t',savefields=['taxperc','taxnum','taxpure','taxrank','taxid','taxtext'],headers=False)
                ## ~ [7e] Calculate best taxa per level ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                if prefix: continue
                if not self.getBool('BestLineage'):
                    for rentry in repdb.entries(sorted=True):
                        taxid = rentry['taxid']
                        taxrank = rentry['taxrank']
                        taxnum = rentry['taxnum']
                        #!# Add toggle for dependent or independent
                        if taxrank not in bestranks or taxnum > bestranks[taxrank][0]:
                            bestranks[taxrank] = (taxnum,taxid)
                prevnum = 0
                for taxrank in revranks:
                    if taxrank == 'no rank':
                        bestranks.pop(taxrank)
                        continue
                    if taxrank in bestranks:
                        taxid = bestranks[taxrank][1]
                        taxnum = bestranks[taxrank][0]
                        if taxnum < prevnum:
                            bestranks.pop(taxrank)
                            continue
                        prevnum = taxnum
                        taxname = taxtuple[taxid][2]
                        taxperc = rje.dp(100.0 * taxnum / genenum, 2)
                        self.printLog('#BEST','Best "{0}" rating = {1}% {2} (taxid:{3})'.format(taxrank,taxperc,taxname,taxid))
                self.debug(bestranks)
                ## ~ [7f] Update lca_genes table with best taxa rating ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                #i# If this taxon matches the consensus taxon at a level at/below , the lowest level will be given in rating
                #i# If it matches at no level
                lcadb.addField('rating')
                lcadb.addField('lineage')
                lx = 0.0; ltot = lcadb.entryNum()
                nx = 0; bx = 0; gx = 0
                self.debug(revranks)
                for lentry in lcadb.entries():
                    self.progLog('\r#LCA','Adding gene-level best taxa ratings to lca_genes table: {0:.1f}%'.format(lx/ltot)); lx += 100.0
                    lentry['lineage'] = ''
                    taxid = lentry['taxid']
                    taxon = taxtuple[taxid]
                    for taxup in taxlineage[taxon]:
                        if taxup[0] not in ['no rank','clade']:
                            lentry['lineage'] += '{0}:{1}:{2}|'.format(taxup[0].upper()[:1], taxup[1], taxup[2])
                    lentry['lineage'] = lentry['lineage'][:-1]
                    taxup = taxlineage[taxon][0:]
                    #i# If taxrank not in bestranks, work up through lineage to set new taxrank
                    #i# If taxrank in bestranks and taxid matches -> goodtax = taxrank
                    #i# If taxrank in bestranks and taxid does not match -> badtax
                    #i# If taxrank is not in bestranks -> notax
                    while taxup and (taxon[0] not in bestranks or revranks.index(taxon[0]) < revranks.index(self.getStr('TaxWarnRank'))):
                        taxon = taxup.pop(-1)
                    if taxon[0] in bestranks:
                        if bestranks[taxon[0]][1] == taxon[1]:
                            lentry['rating'] = taxon[0]
                            gx += 1
                        else:
                            lentry['rating'] = 'badtax'
                            bx += 1
                    else:
                        lentry['rating'] = 'notax'
                        nx += 1
                self.printLog('\r#LCA','Gene-level best taxa ratings: {0} good and {1} bad at {2} level; {3} w/o rank.'.format(rje.iStr(gx),rje.iStr(bx),self.getStr('TaxWarnRank'),rje.iStr(nx)))
                lcadb.saveToFile(filename=lcafile)
                if genedb:  # i# Currently unavailable for ORF mode
                    lcadb.dataFormat({'start':'int','end':'int'})
                    lcadb.newKey(('seqname', 'start', 'end', 'strand'))
                    ctgdb = db.copyTable(lcadb, 'taxbyctg')
                ## ~ [7g] Output GFF file of genes with taxa ranks and ratings ~~~~~~~~~~~~~~~~~~~~ ##
                #!# Add GFF output of taxa ratings withing rating=good/bad/none and note="taxrank:taxid:taxname (taxlineage list)"
                    lcadb.addField('source',evalue='taxolotl')
                    lcadb.addField('ftype',evalue='gene')
                    lcadb.addField('score',evalue='.')
                    lcadb.addField('phase',evalue='.')
                    lcadb.addField('attributes')
                    for lentry in lcadb.entries():
                        if lentry['lineage']:
                            lentry['attributes'] = 'ID={0};Rating="{1}";Note="{2}:{3}:{4} ({5});'.format(lentry['gene'],lentry['rating'],lentry['taxrank'],lentry['taxid'],lentry['taxname'],lentry['lineage'])
                        else:
                            lentry['attributes'] = 'ID={0};Rating="{1}";Note="{2}:{3}:{4};'.format(lentry['gene'],lentry['rating'],lentry['taxrank'],lentry['taxid'],lentry['taxname'])
                    gfields = ['seqname', 'source', 'ftype', 'start', 'end', 'score', 'strand', 'phase', 'attributes']
                    #i# Save comments first then, table with selected headers, minus the headers!
                    gcomments = ['##gff-version 3','##Generated by Taxolotl taxonomy run']
                    lcagff = '{0}.lca_genes.gff'.format(taxbase)
                    lcadb.saveToFile(lcagff,delimit='\t',backup=True,append=False,savefields=gfields,log=True,headers=False,comments=gcomments)

            ### ~ [8] TaxBySeqFull output ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            # Add taxbyseqfull output here
            if self.getBool('TaxBySeqFull'):
                self.headLog('Generate Taxolotl reports for each sequence', line='-')
                outdir = '{0}.taxbyseq'.format(taxbase)
                rje.mkDir(self,outdir)
                seqtaxdb = db.splitTable(taxdb,'seqname',asdict=True,keepfield=False)
                for seqname in rje.sortKeys(seqtaxdb):
                    ## ~ [8a] ~ Set table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                    repdb = seqtaxdb[seqname]
                    table = '{0}.taxolotl_report'.format(seqname)
                    repdb.keepFields(['seqname', 'taxrank', 'taxid', 'taxname', 'taxnum', 'taxpure'])
                    repdb.compress(['taxid'],default='str',rules={'taxnum':'sum', 'taxpure':'sum','genenum':'sum', 'protnum':'sum'})
                    genenum = 0
                    for rentry in repdb.entries():
                        genenum += rentry['taxpure']
                    repdb.addField('taxperc')
                    for rentry in repdb.entries():
                        rentry['taxperc'] = rje.dp(100.0 * rentry['taxnum'] / genenum,4)
                    ## ~ [8b] Sort out ordering ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                    repdb.addField('#')
                    repdb.addField('taxtext')
                    repsort = []    # This is going to be a list of tuple lists
                    for rentry in repdb.entries():
                        taxid = rentry['taxid']
                        taxon = taxtuple[taxid]
                        sorter = []
                        for taxup in taxlineage[taxon]:
                            if repdb.data(taxup[1]):
                                sorter.append((repdb.data(taxup[1])['taxnum'],taxup[1]))
                        sorter.append((rentry['taxnum'],taxid))
                        repsort.append(sorter)
                    repsort.sort(reverse=True)
                    ## ~ [8c] Work through taxa ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                    repkeys = repdb.dataKeys()  # Slowly work through these, removing them
                    rx = 1
                    for sorter in repsort:
                        ix = -1
                        for (taxnum,taxid) in sorter:
                            ix += 1
                            if taxid in repkeys:
                                #i# Update taxon rentry and mark as done by removing from repkeys
                                repkeys.remove(taxid)
                                rentry = repdb.data(taxid)
                                rentry['#'] = rx; rx += 1
                                #taxon = taxtuple[taxid]
                                rentry['taxtext'] = '  ' * ix + rentry['taxname']
                    ## ~ [8d] Output ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                    repdb.newKey(['#'])
                    repdb.saveToFile('{0}/{1}.tsv'.format(outdir,table),delimit='\t',savefields=['taxperc','taxnum','taxpure','taxrank','taxid','taxtext'],headers=False)

            ### ~ [9] Contamination checking ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Checking for contamination', line='-')
            # To flag contamination, each sequence will also be assessed against the dominant taxonomic rating at each level.
            # The percentage of genes matching each dominant rating will be reported for each sequence in `*.consensus.tsv`
            # along with the number of genes with a rating at that level, separated with a `|`. This will exclude any genes
            # without ratings at that taxonomic level. A `Consensus` entry will also report the overall values for the whole
            # assembly.
            #
            # Any sequences that have a dominant taxonomic label deviating from the overall consensus at any ranking levels
            # set by `taxwarnrank=X` (default family) or above will raise a contamination warning and be output to
            # `*.warnings.tsv`. This will have the same output as `*.consensus.tsv` but will have the dominant taxon and it's
            # precentage appended to the consensus percentage, also separated by `|`. For example, `25.00|20|Chordata|50.00`
            # would indicate that 25% of the 20 genes with ratings at that level matched the consensus, whilst the dominant
            # classification was `Chordata` with 50% of 20 rated genes assigned to this category.
            #
            ## ~ [9a] Set up the table fields ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            #i# bestranks now has the consensus best taxon per level
            #i# Update and output modified taxdb
            confields = ['seqname','rating']
            centry = {'seqname':':consensus:','rating':'best-taxa'}
            genetax = {}    # {taxrank:{seqname:genetax}}
            rankbest = {}   # {taxrank:taxname}
            for taxrank in revranks:
                if taxrank in bestranks:
                    confields.insert(2,taxrank)
                    taxnum = bestranks[taxrank][0]
                    taxid = bestranks[taxrank][1]
                    taxname = taxtuple[taxid][2]
                    #!# Add the percentage and total number at this level as for the sequences
                    centry[taxrank] = (taxname,taxid,taxnum)
                    rankbest[taxrank] = taxname
                    genetax[taxrank] = {}
            condb = db.addEmptyTable('consensus',confields,['seqname'])
            ## ~ [9b] Establish counts for conensus and best taxa ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            seqbest = {}    # {seqname:{taxrank:(taxnum,taxid)}}
            seqcons = {}    # {seqname:{taxrank:taxnum}}
            for tentry in taxdb.entries():
                seqname = tentry['seqname']
                if seqname not in seqbest:
                    seqbest[seqname] = {}
                    seqcons[seqname] = {}
                bdict = seqbest[seqname]
                cdict = seqcons[seqname]
                taxid = tentry['taxid']
                taxrank = tentry['taxrank']
                if taxrank not in confields: continue
                taxnum = tentry['taxnum']
                if taxrank not in bdict or taxnum > bdict[taxrank][0]:
                    bdict[taxrank] = (taxnum,taxid)
                if taxid == bestranks[taxrank][1]:
                    cdict[taxrank] = (taxnum, taxid)
                genetax[taxrank][seqname] = tentry['genetax']
            ## ~ [9c] Consensus values ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            #!# Add up the genetax[taxrank].values() for each taxrank and update centry
            for taxrank in confields[2:]:
                rankgenes = sum(genetax[taxrank].values())
                (taxname, taxid, taxnum) = centry[taxrank]
                taxperc = rje.dp(100.0 * taxnum / rankgenes, 2)
                centry[taxrank] = '{0}|{1}|{2}:{3}'.format(taxperc,rankgenes,taxname,taxid)
            condb.addEntry(centry)
            ## ~ [9d] Process each sequence ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            taxwarn = {}    # Dictionary of {seqname:warning text}
            warnrank = self.getStr('TaxWarnRank')
            if warnrank not in confields:
                self.warnLog('TaxWarnRank "{0}" not found in taxonomic ranks'.format(warnrank))
                warnrank = ''
            for seqname in rje.sortKeys(seqbest):
                sentry = {'seqname':seqname,'rating':'goodtax'}
                for taxrank in confields[2:]:
                    bdict = seqbest[seqname]
                    if taxrank not in bdict:
                        sentry[taxrank] = '0.00|0'
                        continue
                    cdict = seqcons[seqname]
                    if taxrank in cdict:
                        tentry = taxdb.data((seqname,cdict[taxrank][1]))
                        taxperc = rje.dp(100.0 * tentry['taxnum'] / tentry['genetax'], 2)
                    else:
                        taxperc = '0.00'
                        tentry = {'taxnum': 0}
                    bentry = taxdb.data((seqname, bdict[taxrank][1]))
                    taxg = bentry['genetax']
                    sentry[taxrank] = '{0}|{1}'.format(taxperc,taxg)
                    taxid = bentry['taxid']
                    if taxid != bestranks[taxrank][1] and bentry['taxnum'] > tentry['taxnum']:
                        bperc = rje.dp(100.0 * bentry['taxnum'] / bentry['genetax'], 2)
                        taxname = bentry['taxname']
                        sentry[taxrank] = '{0}|{1}|{2}'.format(sentry[taxrank],taxname,bperc)
                        if seqname not in taxwarn and warnrank and confields.index(taxrank) <= confields.index(warnrank):
                            taxwarn[seqname] = '{0} diverges from consensus at {1} level: "{2}" not "{3}"'.format(seqname,taxrank,taxname,rankbest[taxrank])
                            sentry['rating'] = 'badtax'
                            self.debug(taxwarn[seqname])
                condb.addEntry(sentry)
            ## ~ [9e] Output warnings ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            warnx = 0; missx = 0; goodx = 0
            for seqname in locdb.dataKeys():
                if seqname in taxwarn:
                    self.warnLog(taxwarn[seqname]); warnx += 1
                elif seqname in seqbest:
                    goodx += 1
                else:
                    if self.v() > 1: self.printLog('#BADTAX','{0} has no taxonomic assignment'.format(seqname))
                    missx += 1
                    sentry = {'seqname':seqname,'rating':'notax'}
                    for taxrank in confields[2:]:
                        sentry[taxrank] = '0.00|0'
                    condb.addEntry(sentry)
            self.printLog('#BEST','{0} sequences match consensus taxa. See *.taxolotl.tsv for details.'.format(rje.iStr(goodx)))
            self.printLog('#BADTAX','{0} sequences have divergent taxa. See log #BADTAX entries for details.'.format(rje.iStr(warnx)))
            self.printLog('#NOTAX','{0} sequences have no taxonomic assigment. See *.notax.id for details.'.format(rje.iStr(missx)))
            condb.index('rating')
            self.debug(condb.index('rating'))
            condb.saveToFile('{0}.taxolotl.tsv'.format(taxbase))
            ## ~ [9f] Output sequence subsets ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            self.headLog('Output sequence subsets', line='-')
            #i# Save to *.id and *.fasta and summarise
            seqfiles = []
            if not self.getStrLC('Assembly'): self.printLog('#FASOUT','No assembly file for sequence subset output')
            elif not rje.exists(self.getStr('Assembly')): self.warnLog('#FASOUT','Assembly file "{0} not found!'.format(self.getStr('Assembly')))
            else: seqfiles.append(self.getStr('Assembly'))
            for prefix in ['best-taxa','goodtax','badtax','notax']:
                if prefix not in condb.index('rating'): continue
                seqids = condb.index('rating')[prefix]
                if prefix == 'best-taxa':
                    seqids = locdb.dataKeys()
                    prefix = 'geneseq'
                idfile = '{0}.{1}.id'.format(taxbase,prefix)
                rje.backup(self,idfile)
                open(idfile,'w').write('\n'.join(seqids))
                self.printLog('#IDFILE','{0} sequence IDs output to {1}'.format(rje.iLen(seqids),idfile))
                if self.getStrLC('Assembly'):
                    acmd = ['seqin={0}'.format(self.getStr('Assembly')),'dna=T','summarise=F','autofilter=T','autoload=T']
                    if prefix == 'geneseq':
                        if len(seqids) >= self.obj['Assembly'].seqNum():
                            self.printLog('#SEQID','No SeqID without genes for *.nogenes.fasta output.')
                            continue
                        acmd += ['badseq={0}'.format(idfile),'seqout={0}.nogenes.fasta'.format(taxbase)]
                        seqfiles.append('{0}.nogenes.fasta'.format(taxbase))
                    else:
                        acmd += ['goodseq={0}'.format(idfile),'seqout={0}.{1}.fasta'.format(taxbase, prefix)]
                        seqfiles.append('{0}.{1}.fasta'.format(taxbase, prefix))
                    rje_seqlist.SeqList(self.log, self.cmd_list + acmd)
            sdb = rje_seqlist.batchSummarise(self, seqfiles, save=False, overwrite=True, seqcmd=['dna=T'])
            sdb.saveToFile('{0}.seqsummary.tsv'.format(taxbase))

            ### ~ [10] Generate Taxolotl reports ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            for prefix in ['goodtax','badtax']:
                if len(condb.index('rating')) < 3: break
                if prefix not in condb.index('rating'): continue
                if prefix in taxsubsets.keys():
                    self.warnLog('Loaded taxsubset "{0}" name clash: skipping Taxolotl report output'.format(prefix))
                    continue
                self.headLog('{0} Taxolotl Report'.format(prefix), line='~')
                ## ~ [10a] ~ Set table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                table = '{0}.taxolotl_report'.format(prefix)
                repdb = db.copyTable(taxdb,table)
                repdb.dropEntriesDirect('seqname',condb.index('rating')[prefix],inverse=True)
                repdb.keepFields(['seqname', 'taxrank', 'taxid', 'taxname', 'taxnum', 'taxpure'])
                repdb.compress(['taxid'],default='str',rules={'taxnum':'sum', 'taxpure':'sum','genenum':'sum', 'protnum':'sum'})
                genenum = 0
                for rentry in repdb.entries():
                    genenum += rentry['taxpure']
                repdb.addField('taxperc')
                for rentry in repdb.entries():
                    rentry['taxperc'] = rje.dp(100.0 * rentry['taxnum'] / genenum,4)
                ## ~ [10b] Sort out ordering ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                repdb.addField('#')
                repdb.addField('taxtext')
                repsort = []    # This is going to be a list of tuple lists
                for rentry in repdb.entries():
                    taxid = rentry['taxid']
                    taxon = taxtuple[taxid]
                    sorter = []
                    for taxup in taxlineage[taxon]:
                        if repdb.data(taxup[1]):
                            sorter.append((repdb.data(taxup[1])['taxnum'],taxup[1]))
                    sorter.append((rentry['taxnum'],taxid))
                    repsort.append(sorter)
                repsort.sort(reverse=True)
                ## ~ [10c] Work through taxa ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                repkeys = repdb.dataKeys()  # Slowly work through these, removing them
                rx = 1
                for sorter in repsort:
                    ix = -1
                    for (taxnum,taxid) in sorter:
                        ix += 1
                        if taxid in repkeys:
                            #i# Update taxon rentry and mark as done by removing from repkeys
                            repkeys.remove(taxid)
                            rentry = repdb.data(taxid)
                            rentry['#'] = rx; rx += 1
                            rentry['taxtext'] = '  ' * ix + rentry['taxname']
                ## ~ [10d] Output ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                repdb.newKey(['#'])
                repdb.saveToFile('{0}.{1}.tsv'.format(taxbase,table),delimit='\t',savefields=['taxperc','taxnum','taxpure','taxrank','taxid','taxtext'],headers=False)

            ### ~ [11] Contig table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            #i# This is going to be based on the consensus table
            #i# Need to identify the contigs and remap genes onto contigs, then compress as with genes
            if assembly and self.getBool('TaxByContig') and genedb:
                self.headLog('Taxonomy by Contig', line='-')
                mingap = max(1, assembly.getInt('MinGap'))
                gapre = re.compile('N{%d,}' % mingap)
                #i# ctgdb   # lcadb.newKey(('seqname','start','end','strand'))
                ## ~ [11a] Generate contigs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                contigs = {}    # Dictionary of seqname:[contigs]
                ctglist = []
                for seq in assembly.seqs():
                    sequence = assembly.seqSequence(seq).upper()
                    sname = assembly.shortName(seq)
                    contigs[sname] = []
                    seqi = seqj = 0
                    for m in gapre.finditer(sequence):
                        seqj = m.start()
                        contig = sequence[seqi:seqj]
                        cname = '{0}.{1}-{2}'.format(sname, seqi + 1, seqj)
                        if contig:
                            contigs[sname].append((cname,seqi+1,seqj))
                            ctglist.append(cname)
                        seqi = m.end()
                    if seqi:
                        seqj = len(sequence)
                        cname = '{0}.{1}-{2}'.format(sname, seqi + 1, seqj)
                        contigs[sname].append((cname,seqi+1,seqj))
                        ctglist.append(cname)
                    elif not seqj:
                        contigs[sname].append((sname,1,len(sequence)))
                        ctglist.append(sname)
                ## ~ [11b] Assign genes to contigs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                genectgs = {}   # Dictionary of gene:[contigs]
                for centry in ctgdb.entries():
                    gene = centry['gene']
                    sname = centry['seqname']
                    genectgs[gene] = []
                    for contig in contigs[sname]:
                        if contig[1] < centry['end'] and contig[2] > centry['start']:
                            genectgs[gene].append(contig[0])
                ## ~ [11c] Remake gene taxonomy table with contigs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                prex = ctgdb.entryNum()
                for centry in ctgdb.entries():
                    gene = centry['gene']
                    centry['seqname'] = genectgs[gene].pop(0)
                    for contig in genectgs[gene]:
                        ctgdb.addEntry(rje.combineDict({'seqname':contig},centry,overwrite=False))
                self.printLog('#CTGTAX','{0} gene-taxa seqname mappings -> {1} contig mappings'.format(rje.iStr(prex),rje.iStr(ctgdb.entryNum())))
                ## ~ [11d] Repeat the taxa-by-sequence compilation ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                ctgdb.addField('genenum',evalue=1)
                ctgdb.addField('taxnum',evalue=1)
                ctgdb.addField('taxpure',evalue=1)
                ctgdb.compress(['seqname','taxid','taxrank','taxname'],rules={'gene':'list'},default='sum')
                ctgdb.dropField('gene')
                ctgdb.setFields(['seqname','genenum','protnum','taxid','taxrank','taxname','taxnum','taxpure'])
                #i# Calculate numbers
                genenum = {}
                protnum = {}
                for tentry in ctgdb.entries():
                    if tentry['seqname'] not in genenum: genenum[tentry['seqname']] = 0
                    if tentry['seqname'] not in protnum: protnum[tentry['seqname']] = 0
                    genenum[tentry['seqname']] += tentry['genenum']
                    protnum[tentry['seqname']] += tentry['protnum']
                ctgdb.dropEntriesDirect('taxid',['0'])
                #i# Cycle through each taxid and update the taxnum for each parent in levels. (Add if needed)
                ctgdb.newKey(['seqname', 'taxid'])
                for tentry in ctgdb.entries():
                    tentry['genenum'] = genenum[tentry['seqname']]
                    tentry['protnum'] = protnum[tentry['seqname']]
                    taxid = tentry['taxid']
                    taxon = taxtuple[taxid]
                    levels = taxlineage[taxon]
                    for level in levels:
                        if level[0] in revranks:
                            upkey = (tentry['seqname'],level[1])
                            uentry = ctgdb.data(upkey)
                            if not uentry:
                                uentry = ctgdb.addEntry({'seqname':tentry['seqname'],'genenum':tentry['genenum'],'protnum':tentry['protnum'],'taxid':level[1],'taxrank':level[0],'taxname':level[2],'taxnum':0,'taxpure':0})
                            uentry['taxnum'] += tentry['taxpure']
                #X# Missing out [6] Refilter on mintaxnum and [6a] remapping based on full_report processing
                #X# I think this should have been done to the lca_genes table already!
                ## ~ [11e] Sum taxnums across ranks to generate genetax numbers ~~~~~~~~~~~~~~~~~~~~~~~~ ##
                self.progLog('\r#GENES','Calculating number of rated genes per taxonomic level...')
                genetax = {}  # {taxrank:{contig:genetax}}
                for taxrank in revranks:
                    if taxrank in bestranks:
                        genetax[taxrank] = {}
                for tentry in ctgdb.entries():
                    if tentry['seqname'] not in genetax: genetax[tentry['seqname']] = {'*':0}
                    if tentry['taxrank'] not in genetax[tentry['seqname']]: genetax[tentry['seqname']][tentry['taxrank']] = 0
                    genetax[tentry['seqname']]['*'] += tentry['taxpure']
                    genetax[tentry['seqname']][tentry['taxrank']] += tentry['taxnum']
                ctgdb.addField('genetax')
                ctgdb.addField('taxperc')
                for tentry in ctgdb.entries():
                    tentry['genetax'] = genetax[tentry['seqname']][tentry['taxrank']]
                    tentry['taxperc'] = 100.0 * tentry['taxnum'] / genetax[tentry['seqname']]['*']
                self.printLog('\r#GENES', 'Calculation of number of rated genes per taxonomic level complete.')
                self.debug(ctgdb.entries()[0])
                self.debug(ctgdb.fields())
                ## ~ [11f] Save to taxdb to file ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                ctgdb.setFields(['seqname', 'genenum', 'protnum', 'taxrank', 'genetax', 'taxid', 'taxname', 'taxperc', 'taxnum', 'taxpure'])
                ctgdb.renameField('seqname','contig')
                ctgdb.saveToFile('{0}.taxbyctg.tsv'.format(taxbase),sfdict={'taxperc':4})
                ## ~ [11g] Generate contig consensus.tsv ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                #i# bestranks has the consensus best taxon per level
                #i# Update and output modified ctgdb
                confields = ['contig','seqname','start','end'] + condb.fields()[1:]
                centry = condb.data(':consensus:')
                centry['contig'] = centry['seqname']
                centry['start'] = 0
                centry['end'] = 0
                ctgcondb = db.addEmptyTable('ctgconsensus',confields,['contig'])
                ctgcondb.addEntry(centry)
                ## ~ [11h] Establish counts for consensus and best taxa ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                self.headLog('Establishing Contig taxon counts', line='~')
                self.debug(bestranks)
                seqbest = {}    # {seqname:{taxrank:(taxnum,taxid)}}
                seqcons = {}    # {seqname:{taxrank:taxnum}}
                for tentry in ctgdb.entries():
                    seqname = tentry['contig']
                    if seqname not in seqbest:
                        seqbest[seqname] = {}
                        seqcons[seqname] = {}
                    bdict = seqbest[seqname]
                    cdict = seqcons[seqname]
                    taxid = tentry['taxid']
                    taxrank = tentry['taxrank']
                    if taxrank not in confields: continue
                    taxnum = tentry['taxnum']
                    if taxrank not in bdict or taxnum > bdict[taxrank][0]:
                        bdict[taxrank] = (taxnum,taxid)
                    if taxid == bestranks[taxrank][1]:
                        cdict[taxrank] = (taxnum, taxid)
                    genetax[taxrank][seqname] = tentry['genetax']
                ## ~ [11i] Process each sequence ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                taxwarn = {}    # Dictionary of {seqname:warning text}
                warnrank = self.getStr('TaxWarnRank')
                if warnrank not in confields:
                    self.warnLog('TaxWarnRank "{0}" not found in taxonomic ranks'.format(warnrank))
                    warnrank = ''
                for seqname in rje.sortKeys(seqbest):
                    sentry = {'contig':seqname,'rating':'goodtax'}
                    details = rje.matchExp('^(\S+)\.(\d+)-(\d+)$',seqname)
                    if details:
                        (sentry['seqname'],sentry['start'],sentry['end']) = details
                    elif seqname in contigs:
                        (sentry['seqname'], sentry['start'], sentry['end']) = (seqname, 1, contigs[seqname][0][2])
                    else:
                        (sentry['seqname'], sentry['start'], sentry['end']) = (seqname, 1, -1)
                    for taxrank in confields[confields.index('rating')+1:]:
                        bdict = seqbest[seqname]
                        if taxrank not in bdict:
                            sentry[taxrank] = '0.00|0'
                            continue
                        cdict = seqcons[seqname]
                        if taxrank in cdict:
                            tentry = ctgdb.data((seqname,cdict[taxrank][1]))
                            taxperc = rje.dp(100.0 * tentry['taxnum'] / tentry['genetax'], 2)
                        else:
                            taxperc = '0.00'
                            tentry = {'taxnum':0}
                        bentry = ctgdb.data((seqname, bdict[taxrank][1]))
                        taxg = bentry['genetax']
                        sentry[taxrank] = '{0}|{1}'.format(taxperc,taxg)
                        taxid = bentry['taxid']
                        if taxid != bestranks[taxrank][1] and bentry['taxnum'] > tentry['taxnum']:
                            bperc = rje.dp(100.0 * bentry['taxnum'] / bentry['genetax'], 2)
                            taxname = bentry['taxname']
                            sentry[taxrank] = '{0}|{1}|{2}'.format(sentry[taxrank],taxname,bperc)
                            if seqname not in taxwarn and warnrank and confields.index(taxrank) <= confields.index(warnrank):
                                taxwarn[seqname] = 'Contig {0} diverges from consensus at {1} level: "{2}" not "{3}"'.format(seqname,taxrank,taxname,rankbest[taxrank])
                                sentry['rating'] = 'badtax'
                    self.debug(sentry)
                    ctgcondb.addEntry(sentry)
                ## ~ [11j] Output warnings ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                warnx = 0; missx = 0
                for seqname in ctglist:
                    if seqname in taxwarn:
                        if seqname not in locdb.dataKeys():
                            self.printLog('#BADTAX',taxwarn[seqname])
                        warnx += 1
                    elif seqname not in seqbest:
                        if self.v() > 1: self.warnLog('{0} has no taxonomic assignment'.format(seqname))
                        missx += 1
                        sentry = {'contig':seqname,'rating':'notax'}
                        details = rje.matchExp('^(\S+)\.(\d+)-(\d+)$', seqname)
                        if details:
                            (sentry['seqname'], sentry['start'], sentry['end']) = details
                        elif seqname in contigs:
                            (sentry['seqname'], sentry['start'], sentry['end']) = (seqname, 1, contigs[seqname][0][2])
                        else:
                            (sentry['seqname'], sentry['start'], sentry['end']) = (seqname, 1, -1)
                        for taxrank in confields[confields.index('rating')+1:]:
                            sentry[taxrank] = '0.00|0'
                        ctgcondb.addEntry(sentry)
                self.printLog('#BADTAX','{0} contigs have divergent taxa. See log #BADTAX entries for details.'.format(rje.iStr(warnx)))
                self.printLog('#NOTAX','{0} contigs have no taxonomic assigment.'.format(rje.iStr(missx)))
                self.debug(ctgcondb.index('rating'))
                self.debug(ctgcondb.fields())
                ctgcondb.saveToFile('{0}.ctgtaxolotl.tsv'.format(taxbase))

            return True
        except: self.errorLog('%s.taxonomy error' % self.prog()); return False
#########################################################################################################################
### End of SECTION II: SAAGA Class                                                                                      #
#########################################################################################################################

                                                    ### ~ ### ~ ###

#########################################################################################################################
### SECTION III: MODULE METHODS                                                                                         #
#########################################################################################################################

#########################################################################################################################
### END OF SECTION III                                                                                                  #
#########################################################################################################################

                                                    ### ~ ### ~ ###

#########################################################################################################################
### SECTION IV: MAIN PROGRAM                                                                                            #
#########################################################################################################################
def runMain():
    ### ~ [1] ~ Basic Setup of Program  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    try: (info,out,mainlog,cmd_list) = setupProgram()
    except SystemExit: return  
    except: rje.printf('Unexpected error during program setup:', sys.exc_info()[0]); return
    
    ### ~ [2] ~ Rest of Functionality... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    try:
        saaga = SAAGA(mainlog,cmd_list)
        if saaga.list['BatchSeq'] or saaga.list['BatchRef']:
            #i# Setup batch lists
            batchseq = []
            for seqfile in saaga.list['BatchSeq']:
                batchseq.append((seqfile,rje.baseFile(seqfile)+'.gff'))
                saaga.printLog('#BATCH','Queuing up batch run: seqin={0} and gffin={1}'.format(seqfile,batchseq[-1][1]))
            if not batchseq:
                batchseq.append((saaga.getStr('SeqIn'), saaga.getStr('GFFIn')))
            batchref = saaga.list['BatchRef'][0:]
            if not batchref: batchref.append(saaga.getStr('RefProt'))
            #i# Run through batch runs
            for seqfile in batchseq:
                for reffile in batchref:
                    saaga.headLog('BATCH RUN',line='=')
                    saaga.printLog('#SEQIN',seqfile[0])
                    saaga.printLog('#REF',reffile)
                    scmd = ['seqin={0}'.format(seqfile[0]),'gffin={0}'.format(seqfile[1]),'cdsin=None','basefile=None','refprot={0}'.format(reffile),'refdb=None']
                    SAAGA(mainlog, cmd_list + scmd).run()
        else:
            saaga.run()

    ### ~ [3] ~ End ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    except SystemExit: return  # Fork exit etc.
    except KeyboardInterrupt: mainlog.errorLog('User terminated.')
    except: mainlog.errorLog('Fatal error in main %s run.' % info.program)
    mainlog.endLog(info)
#########################################################################################################################
if __name__ == "__main__":      ### Call runMain 
    try: runMain()
    except: rje.printf('Cataclysmic run error: {0}'.format(sys.exc_info()[0]))
    sys.exit()
#########################################################################################################################
### END OF SECTION IV                                                                                                   #
#########################################################################################################################
