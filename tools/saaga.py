#!/usr/bin/python

# See below for name and description
# Copyright (C) 2016 Richard J. Edwards <redwards@cabbagesofdoom.co.uk>
#  
# This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program; if not, write to 
# the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# Author contact: <seqsuite@gmail.com> / School of Biotechnology and Biomolecular Sciences, UNSW, Sydney, Australia.
#
# To incorporate this module into your own programs, please see GNU Lesser General Public License disclaimer in rje.py

"""
Module:       SAAGA
Description:  Summarise, Annotate & Assess Genome Annotations
Version:      0.5.4
Last Edit:    20/11/20
Citation:     Edwards RJ et al. (2020), bioRxiv https://doi.org/10.1101/2020.11.11.379073
GitHub:       http://github.com/slimsuite/saaga
Copyright (C) 2020  Richard J. Edwards - See source code for GNU License Notice

Function:
    SAAGA is a tool for summarising, annotating and assessing genome annotations, with a particular focus on annotation
    generated by GeMoMa. The core of SAAGA is reciprocal MMeqs searches of the annotation and reference proteomes. These
    are used to identify the best hits for protein product identification and to assess annotations based on query and
    hit coverage. SAAGA will also generate annotation summary statistics, and extract the longest protein from each gene
    for a representative non-redundant proteome (e.g. for BUSCO analysis).

Run modes:

    assess = Assess annotation using reference annotation (e.g. a reference organism proteome)
    annotate = Rename annotation using reference annotation (could be Swissprot)
    longest = Extract the longest protein per gene
    mmseq = Run the mmseq2 steps in preparation for further analysis
    summarise = Summarise annotation from GFF file

Commandline:
    ### ~ Input/Output options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    seqin=FILE      : Protein annotation file to assess [annotation.faa]
    gffin=FILE      : Protein annotation GFF file [annotation.gff]
    cdsin=FILE      : Optional transcript annotation file for renaming and/or longest isoform extraction [annotation.fna]
    refprot=FILE    : Reference proteome for mapping data onto [refproteome.fasta]
    refdb=FILE      : Reference proteome MMseq2 database (over-rule mmseqdb path) []
    mmseqdb=PATH    : Directory in which to find/create mmseqs2 databases [./mmseqdb/]
    mmsearch=PATH   : Directory in which to find/create mmseqs2 databases [./mmsearch/]
    basefile=X      : Prefix for output files [$SEQBASE.$REFBASE]
    gffgene=X       : Label for GFF gene feature type ['gene']
    gffcds=X        : Label for GFF CDS feature type ['CDS']
    gffmrna=X       : Label for GFF mRNA feature type ['mRNA']
    ### ~ Run mode options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    annotate=T/F    : Rename annotation using reference annotation (could be Swissprot) [False]
    assess=T/F      : Assess annotation using reference annotation [False]
    longest=T/F     : Extract longest protein per gene into *.longest.faa [False]
    mmseqs=T/F      : Run the mmseq2 steps in preparation for further analysis [True]
    summarise=T/F   : Summarise annotation from GFF file [True]
    dochtml=T/F     : Generate HTML SAAGA documentation (*.docs.html) instead of main run [False]
    ### ~ Search and filter options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    tophits=INT     : Restrict mmseqs hits to the top X hits [250]
    minglobid=PERC  : Minimum global query percentage identity for a hit to be kept [40.0]
    ### ~ Precomputed MMSeq2 options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    mmqrymap=TSV    : Tab-delimited output for query versus reference search (see docs) [$SEQBASE.$REFBASE.mmseq.tsv]
    mmhitmap=TSV    : Tab-delimited output for reference versus query search (see docs) [$REFBASE.$SEQBASE.mmseq.tsv]
    ### ~ Batch Run options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    batchseq=FILELIST   : List of seqin=FILE annotation proteomes for comparison
    batchref=FILELIST   : List of refprot=FILE reference proteomes for comparison
    ### ~ System options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    forks=X         : Number of parallel sequences to process at once [0]
    killforks=X     : Number of seconds of no activity before killing all remaining forks. [36000]
    forksleep=X     : Sleep time (seconds) between cycles of forking out more process [0]
    tmpdir=PATH     : Temporary directory path for running mmseqs2 [./tmp/]
    ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
"""
#########################################################################################################################
### SECTION I: GENERAL SETUP & PROGRAM DETAILS                                                                          #
#########################################################################################################################
import os, string, sys, time
slimsuitepath = os.path.abspath(os.path.join(os.path.dirname(os.path.realpath(__file__)),'../')) + os.path.sep
sys.path.append(os.path.join(slimsuitepath,'libraries/'))
sys.path.append(os.path.join(slimsuitepath,'tools/'))
### User modules - remember to add *.__doc__ to cmdHelp() below ###
import rje, rje_db, rje_gff, rje_obj, rje_rmd, rje_seqlist
#########################################################################################################################
def history():  ### Program History - only a method for PythonWin collapsing! ###
    '''
    # 0.0.0 - Initial Compilation.
    # 0.1.0 - Initial working version. Needs improved documentation.
    # 0.2.0 - Added extra annotation/longest output for CDS and GFF.
    # 0.2.1 - Renamed to SAAGA and tidied some documentation.
    # 0.3.0 - Added some additional hit info to annotation and reworked to allow multiple query-hit pairs.
    # 0.3.1 - Fixed assess bug and sped up GFF parsing.
    # 0.4.0 - Added tophits=X [250] and minglobid=X [40.0] options, plus gobid and hitnum to output.
    # 0.5.0 - Added definitions for gffgene=X, gffcds=X and gffmrna=X. Modified output.
    # 0.5.1 - Tidied some of the code and added some identifier checks for GFF and Fasta input.
    # 0.5.2 - Fixed issue with swapped transcript and exon feature identifiers following v0.5.1 tidying.
    # 0.5.3 - Added pident compatibility with updated mmseq2. Updated documentation. Modified some stats calculations.
    # 0.5.4 - Added restricted feature parsing from GFF. Fixed GFF type input bug.
    '''
#########################################################################################################################
def todo():     ### Major Functionality to Add - only a method for PythonWin collapsing! ###
    '''
    # [ ] : Populate Module Docstring with basic info.
    # [ ] : Populate makeInfo() method with basic info.
    # [ ] : Add full description of program to module docstring.
    # [ ] : Create initial working version of program.
    # [ ] : Add REST outputs to restSetup() and restOutputOrder()
    # [ ] : Add to SLiMSuite or SeqSuite.
    # [ ] : Add option to only update "Protein of unknown function" annotations using single reference or iteratively.
    # [ ] : Move some functionality into a rje_mmseq2.py module?
    # [ ] : Add passing of MMSeqs options to tweak the sensitivity.
    # [ ] : Need to separate some of the summarise and assess functions into GFF +/- for batch assessment.
    # [ ] : Add mmsearchdir to output names to keep things clean. (And option to clean up everything at end)
    # [ ] : Add descriptions to longest output if annotate=True (read output back in as seqin object)
    # [ ] : Add descriptions to GFF and transcript file.
    # [Y] : Speed up the GFF parsing.
    '''
#########################################################################################################################
def makeInfo(): ### Makes Info object which stores program details, mainly for initial print to screen.
    '''Makes Info object which stores program details, mainly for initial print to screen.'''
    (program, version, last_edit, copy_right) = ('SAAGA', '0.5.4', 'November 2020', '2020')
    description = 'GeMoMa output processing module'
    author = 'Dr Richard J. Edwards.'
    comments = ['This program is still in development and has not been published.',rje_obj.zen()]
    return rje.Info(program,version,last_edit,description,author,time.time(),copy_right,comments)
#########################################################################################################################
def cmdHelp(info=None,out=None,cmd_list=[]):   ### Prints *.__doc__ and asks for more sys.argv commands
    '''Prints *.__doc__ and asks for more sys.argv commands.'''
    try:### ~ [1] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        if not info: info = makeInfo()
        if not out: out = rje.Out()
        ### ~ [2] ~ Look for help commands and print options if found ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        cmd_help = cmd_list.count('help') + cmd_list.count('-help') + cmd_list.count('-h')
        if cmd_help > 0:
            rje.printf('\n\nHelp for {0} {1}: {2}\n'.format(info.program, info.version, time.asctime(time.localtime(info.start_time))))
            out.verbose(-1,4,text=__doc__)
            if rje.yesNo('Show general commandline options?',default='N'): out.verbose(-1,4,text=rje.__doc__)
            if rje.yesNo('Quit?'): sys.exit()           # Option to quit after help
            cmd_list += rje.inputCmds(out,cmd_list)     # Add extra commands interactively.
        elif out.stat['Interactive'] > 1: cmd_list += rje.inputCmds(out,cmd_list)    # Ask for more commands
        ### ~ [3] ~ Return commands ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        return cmd_list
    except SystemExit: sys.exit()
    except KeyboardInterrupt: sys.exit()
    except: rje.printf('Major Problem with cmdHelp()')
#########################################################################################################################
def setupProgram(): ### Basic Setup of Program when called from commandline.
    '''
    Basic Setup of Program when called from commandline:
    - Reads sys.argv and augments if appropriate
    - Makes Info, Out and Log objects
    - Returns [info,out,log,cmd_list]
    '''
    try:### ~ [1] ~ Initial Command Setup & Info ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        info = makeInfo()                                   # Sets up Info object with program details
        if len(sys.argv) == 2 and sys.argv[1] in ['version','-version','--version']: rje.printf(info.version); sys.exit(0)
        if len(sys.argv) == 2 and sys.argv[1] in ['details','-details','--details']: rje.printf('{0} v{1}'.format(info.program,info.version)); sys.exit(0)
        if len(sys.argv) == 2 and sys.argv[1] in ['description','-description','--description']: rje.printf('%s: %s' % (info.program,info.description)); sys.exit(0)
        cmd_list = rje.getCmdList(sys.argv[1:],info=info)   # Reads arguments and load defaults from program.ini
        out = rje.Out(cmd_list=cmd_list)                    # Sets up Out object for controlling output to screen
        out.verbose(2,2,cmd_list,1)                         # Prints full commandlist if verbosity >= 2 
        out.printIntro(info)                                # Prints intro text using details from Info object
        cmd_list = cmdHelp(info,out,cmd_list)               # Shows commands (help) and/or adds commands from user
        log = rje.setLog(info,out,cmd_list)                 # Sets up Log object for controlling log file output
        return (info,out,log,cmd_list)                      # Returns objects for use in program
    except SystemExit: sys.exit()
    except KeyboardInterrupt: sys.exit()
    except: rje.printf('Problem during initial setup.'); raise
#########################################################################################################################
dbformats = {'evalue':'num','raw':'int','qlen':'int','tlen':'int','qstart':'int','qend':'int','qcov':'num','tstart':'int','tend':'int','tcov':'num','alnlen':'int','pident':'num'}
#########################################################################################################################
### END OF SECTION I                                                                                                    #
#########################################################################################################################

                                                    ### ~ ### ~ ###

#########################################################################################################################
### SECTION II: GeMoMa Class                                                                                               #
#########################################################################################################################
class GeMoMa(rje_obj.RJE_Object):
    '''
    GeMoMa Class. Author: Rich Edwards (2015).

    Str:str
    - CDSIn=FILE      : Optional transcript annotation file for renaming and/or longest isoform extraction [annotation.fna]
    - GFFIn=FILE      : Protein annotation GFF file [annotation.gff]
    - GFFGene=X       : Label for GFF gene feature type ['gene']
    - GFFCDS=X        : Label for GFF CDS feature type ['CDS']
    - GFFmRNA=X       : Label for GFF mRNA feature type ['mRNA']
    - MMHitMap=TSV    : Tab-delimited output for query versus reference MMseq2 search (see docs) [$REFBASE.$SEQBASE.mmseq.tsv]
    - MMQryMap=TSV    : Tab-delimited output for query versus reference MMseq2 search (see docs) [$SEQBASE.$REFBASE.mmseq.tsv]
    - MMSearch=PATH   : Directory in which to find/create mmseqs2 databases [./mmsearch/]
    - MMSeqDB = Directory in which to find/create mmseqs2 databases [./mmseqdb/]
    - RefDB=FILE      : Reference proteome MMseq2 database (over-rule mmseqdb path) []
    - RefProt = Reference proteome for mapping data onto []
    - SeqIn = Protein annotation file to assess [annotation.faa]
    - TmpDir=PATH     : Temporary directory path for running mmseqs2 [./tmp/]

    Bool:boolean
    - Annotate=T/F    : Rename annotation using reference annotation (could be Swissprot) [False]
    - Assess=T/F      : Assess annotation using reference annotation [False]
    - BatchRun=T/F    : Whether to assess batchrun options (set to False for single runs within batch) [True]
    - DocHTML=T/F     : Generate HTML BUSCOMP documentation (*.info.html) instead of main run [False]
    - Longest=T/F     : Extract longest protein per gene into *.longest.faa [False]
    - MMseqs=T/F      : Run the mmseq2 steps in preparation for further analysis [True]
    - Summarise=T/F   : Summarise annotation from GFF file [True]

    Int:integer
    - TopHits=INT     : Restrict mmseqs hits to the top X hits [250]

    Num:float
    - MinGlobID=PERC  : Minimum global query percentage identity for a hit to be kept [40.0]

    File:file handles with matching str filenames
    
    List:list
    - BatchSeq=FILELIST   : List of seqin=FILE annotation proteomes for comparison
    - BatchRef=FILELIST   : List of refprot=FILE reference proteomes for comparison

    Dict:dictionary    

    Obj:RJE_Objects
    - CDSIn = SeqList: Optional transcript annotation file for renaming and/or longest isoform extraction [annotation.fna]
    - DB = Database object
    - GFF = rje_gff.GFF
    - RefProt = SeqList: Reference proteome for mapping data onto []
    - Rmd = RMarkdown control object
    - SeqIn = SeqList: Protein annotation file to assess [predicted_cds.fasta]
    '''
#########################################################################################################################
    ### <1> ### Class Initiation etc.: sets attributes                                                                  #
#########################################################################################################################
    def _setAttributes(self):   ### Sets Attributes of Object
        '''Sets Attributes of Object.'''
        ### ~ Basics ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        self.strlist = ['CDSIn','GFFIn','GFFGene','GFFCDS','GFFmRNA','MMHitMap','MMQryMap','MMSearch','MMSeqDB','RefDB','RefProt','SeqIn','TmpDir']
        self.boollist = ['Annotate','Assess','BatchRun','DocHTML','Longest','MMseqs','Summarise']
        self.intlist = ['TopHits']
        self.numlist = ['MinGlobID']
        self.filelist = []
        self.listlist = ['BatchSeq','BatchRef']
        self.dictlist = []
        self.objlist = ['SeqIn','RefProt']
        ### ~ Defaults ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        self._setDefaults(str='None',bool=False,int=0,num=0.0,obj=None,setlist=True,setdict=True,setfile=True)
        self.setStr({'CDSIn':'annotation.fna','GFFGene':'gene','GFFCDS':'CDS','GFFmRNA':'mRNA',
                     'GFFIn':'annotation.gff','MMSearch':'./mmsearch/','MMSeqDB':'./mmseqdb/',
                     'RefProt':'refproteome.fasta','SeqIn':'annotation.fasta','TmpDir':'./tmp/'})
        self.setBool({'Annotate':False,'Assess':False,'BatchRun':True,'DocHTML':False,'Longest':False,'MMseqs':True,'Summarise':True})
        self.setInt({'TopHits':250})
        self.setNum({'MinGlobID':40.0})
        ### ~ Other Attributes ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        self.obj['DB'] = rje_db.Database(self.log,self.cmd_list+['tuplekeys=T'])
        self.obj['GFF'] = rje_gff.GFF(self.log,['attfield=T']+self.cmd_list+['tuplekeys=T','warnfield='])
        self.obj['GFF'].obj['DB'] = self.obj['DB']
        self.obj['Rmd'] = rje_rmd.Rmd(self.log,self.cmd_list)
        self._setForkAttributes()   # Delete if no forking
#########################################################################################################################
    def _cmdList(self):     ### Sets Attributes from commandline
        '''
        Sets attributes according to commandline parameters:
        - see .__doc__ or run with 'help' option
        '''
        for cmd in self.cmd_list:
            try:
                self._generalCmd(cmd)   ### General Options ### 
                self._forkCmd(cmd)  # Delete if no forking
                ### Class Options (No need for arg if arg = att.lower()) ### 
                #self._cmdRead(cmd,type='str',att='Att',arg='Cmd')  # No need for arg if arg = att.lower()
                self._cmdReadList(cmd,'str',['GFFGene','GFFCDS','GFFmRNA'])   # Normal strings
                self._cmdReadList(cmd,'path',['MMSearch','MMSeqDB','TmpDir'])  # String representing directory path
                self._cmdReadList(cmd,'file',['CDSIn','GFFIn','RefDB','RefProt','SeqIn'])  # String representing file path
                #self._cmdReadList(cmd,'date',['Att'])  # String representing date YYYY-MM-DD
                self._cmdReadList(cmd,'bool',['Annotate','Assess','BatchRun','DocHTML','Longest','MMseqs','Summarise'])  # True/False Booleans
                self._cmdReadList(cmd,'int',['TopHits'])   # Integers
                #self._cmdReadList(cmd,'float',['Att']) # Floats
                self._cmdReadList(cmd,'perc',['MinGlobID']) # Floats
                #self._cmdReadList(cmd,'min',['Att'])   # Integer value part of min,max command
                #self._cmdReadList(cmd,'max',['Att'])   # Integer value part of min,max command
                #self._cmdReadList(cmd,'list',['Att'])  # List of strings (split on commas or file lines)
                #self._cmdReadList(cmd,'clist',['Att']) # Comma separated list as a *string* (self.str)
                self._cmdReadList(cmd,'glist',['BatchSeq','BatchRef']) # List of files using wildcards and glob
                #self._cmdReadList(cmd,'cdict',['Att']) # Splits comma separated X:Y pairs into dictionary
                #self._cmdReadList(cmd,'cdictlist',['Att']) # As cdict but also enters keys into list
            except: self.errorLog('Problem with cmd:%s' % cmd)
        if not self.baseFile(return_none=''): self.baseFile('saaga')
#########################################################################################################################
    ### <2> ### Main Class Backbone                                                                                     #
#########################################################################################################################
    def run(self):  ### Main run method
        '''
        # SAAGA: Summarise, Annotate & Assess Genome Annotations

        SAAGA is a tool for summarising, annotating and assessing genome annotations, with a particular focus on annotation
        generated by GeMoMa. The core of SAAGA is reciprocal MMeqs searches of the annotation and reference proteomes. These
        are used to identify the best hits for protein product identification and to assess annotations based on query and
        hit coverage. SAAGA will also generate annotation summary statistics, and extract the longest protein from each gene
        for a representative non-redundant proteome (e.g. for BUSCO analysis).

        Please note that SAAGA is still in development and documentation is currently a bit sparse.

        The different run modes are set using a set of `mode=T/F` flags (or simply adding the run mode to the command):

        * `assess` = Assess annotation using reference annotation (e.g. a reference organism proteome)
        * `annotate` = Rename annotation using reference annotation (could be Swissprot)
        * `longest` = Extract the longest protein per gene
        * `mmseq` = Run the mmseq2 steps in preparation for further analysis
        * `summarise` = Summarise annotation from a GFF file

        See <https://slimsuite.github.io/saaga/> for details of each mode. General SLiMSuite run documentation can be
        found at <https://github.com/slimsuite/SLiMSuite>.

        SAAGA is available as part of SLiMSuite, or via a standalone GitHub repo at
        <https://github.com/slimsuite/saaga>.

        ---

        # Running SAAGA

        SAAGA is written in Python 2.x and can be run directly from the commandline:

            python $CODEPATH/diploidocus.py [OPTIONS]

        If running as part of [SLiMSuite](http://slimsuite.blogspot.com/), `$CODEPATH` will be the SLiMSuite `tools/`
        directory. If running from the standalone [SAAGA git repo](https://github.com/slimsuite/saaga), `$CODEPATH`
        will be the path the to `code/` directory. Please see details in the [SAAGA git repo](https://github.com/slimsuite/saaga)
        for running on example data.

        For `assess`, `annotate` and `mmseq` modes, [MMseqs2](https://github.com/soedinglab/MMseqs2) must be installed and
        either added to the environment `$PATH`.

        ## Commandline options

        A list of commandline options can be generated at run-time using the `-h` or `help` flags. Please see the general
        [SLiMSuite documentation](http://slimsuite.blogspot.com/2013/08/command-line-options.html) for details of how to
        use commandline options, including setting default values with **INI files**.

        ```
        ### ~ Input/Output options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        seqin=FILE      : Protein annotation file to assess [annotation.faa]
        gffin=FILE      : Protein annotation GFF file [annotation.gff]
        cdsin=FILE      : Optional transcript annotation file for renaming and/or longest isoform extraction [annotation.fna]
        refprot=FILE    : Reference proteome for mapping data onto [refproteome.fasta]
        refdb=FILE      : Reference proteome MMseq2 database (over-rule mmseqdb path) []
        mmseqdb=PATH    : Directory in which to find/create mmseqs2 databases [./mmseqdb/]
        mmsearch=PATH   : Directory in which to find/create mmseqs2 databases [./mmsearch/]
        basefile=X      : Prefix for output files [$SEQBASE.$REFBASE]
        gffgene=X       : Label for GFF gene feature type ['gene']
        gffcds=X        : Label for GFF CDS feature type ['CDS']
        gffmrna=X       : Label for GFF mRNA feature type ['mRNA']
        ### ~ Run mode options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        annotate=T/F    : Rename annotation using reference annotation (could be Swissprot) [False]
        assess=T/F      : Assess annotation using reference annotation [False]
        longest=T/F     : Extract longest protein per gene into *.longest.faa [False]
        mmseqs=T/F      : Run the mmseq2 steps in preparation for further analysis [True]
        summarise=T/F   : Summarise annotation from GFF file [True]
        dochtml=T/F     : Generate HTML SAAGA documentation (*.docs.html) instead of main run [False]
        ### ~ Search and filter options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        tophits=INT     : Restrict mmseqs hits to the top X hits [250]
        minglobid=PERC  : Minimum global query percentage identity for a hit to be kept [40.0]
        ### ~ Precomputed MMSeq2 options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        mmqrymap=TSV    : Tab-delimited output for query versus reference search (see docs) [$SEQBASE.$REFBASE.mmseq.tsv]
        mmhitmap=TSV    : Tab-delimited output for reference versus query search (see docs) [$REFBASE.$SEQBASE.mmseq.tsv]
        ### ~ Batch Run options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        batchseq=FILELIST   : List of seqin=FILE annotation proteomes for comparison
        batchref=FILELIST   : List of refprot=FILE reference proteomes for comparison
        ### ~ System options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        forks=X         : Number of parallel sequences to process at once [0]
        killforks=X     : Number of seconds of no activity before killing all remaining forks. [36000]
        forksleep=X     : Sleep time (seconds) between cycles of forking out more process [0]
        tmpdir=PATH     : Temporary directory path for running mmseqs2 [./tmp/]
        ### ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
        ```

        ---

        # SAAGA Overview

        SAAGA is based on MMseqs mapping of a predicted annotation proteome against a reference proteome. For assessment,
        this should be a high quality annotated proteome. For annotation, this should be a set of curated proteins such as SwissProt.

        ## Setup

        Unless `mmseqs` is the only active run mode, the `seqin=FILE` predicted annotation proteome is loaded and summarised.
        If `cdsin=FILE` is given and `longest`, `annotate` or `summarise` are active, the predicted annotation transcriptome
        will also be summarised. In `assess` mode, the reference proteome will also be loaded and summarised. If the reference
        proteome has more than 100,000 proteins, the option to exit will be given.

        Unless `mmseqs` is the only active run mode, the `gffin=FILE` GFF file will also be loaded and processed. Predicted
        genes, transcripts and exons are extracted based on the feature type. By default, SAAGA expects GeMoMa annotation
        with `gene`, `mRNA` and `CDS` feature types for genes, transcripts and exons, respectively. If `mRNA` features are
        not found, `prediction` features will be parsed as transcripts. These can be over-ridden with `gffgene=X`,
        `gffmrna=X` and `gffcds=X`.

        Protein names in the `seqin=FILE` are mapped onto the `ID=X` identifiers for transcripts in the GFF file. Transcript
        `Parent=X` identifiers should map onto gene `ID=X` identifiers, and CDS `Parent=X` identifiers should map onto
        transcript `ID=X` identifiers. If mapping is incomplete, the user will be warned and given the option to exit.

        If `seqin=FILE` protein names and transcript IDs do not match, [https://github.com/gpertea/gffread](GffRead) can
        be used to generate the protein fasta file:

            gffread -y $PROTEIN_FASTA -g $GENOME $GFF

        ### MMseqs Searches

        Unless the MMseq2 runs are already generated (or `force=T`), `mmseqs createdb` will be run on the annotation and
        reference proteomes. Following this, `mmseqs search` will be run using the `tmpdir=PATH` temporary directory
        (default, `./tmp/`). If `assess` or `annotate`, the reciprocal search of reference proteome versus predicted proteome
        is also executed. Searches are reduced to the top X hits (`tophits=INT`, default 250) using `mmseqs filterdb` and
        then tabulated `mmseqs convertalis`.

        For the annotation versus reference search, the following fields are output:

            query,target,evalue,raw,alnlen,pident,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov,theader

        For the reference versus annotation search, the following fields are output:

            query,target,evalue,raw,alnlen,pident,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov

        Unless `mmseqs` is the only active run mode, SAAGA will exit at this point. Otherwise, if multiple hits for the
        same query-hit pair exist, they are ranked by the `raw` score (big to small).

        ### Data integration

        After loading the input data and running MMseq2, the data is integrated and tidied.

        The exon (CDS) table is indexed on `parent`, `start` and `end`, and a new `exonlen` field added (`end`-`start`+1).
        This table is then collapsed by parent transcript `id`, keeping the smallest `start` position, biggest `end`,
        count of `exons` and summed `exonlen` for each transcript.

        For transcript/protein annotation, a copy of the annotation versus reference mmseqs output is made, reduced to the fields:

            query,target,raw,tcov,pident,theader


        The gene and transcripts tables are indexed on `id` for mapping onto other data.

        ---

        # SAAGA Outputs

        In addition to outputs generated by mmseqs, the main SAAGA outputs are:

        * `*.log` = the main SAAGA log file containing
        * `*.sys.log` = logging of mmseqs runs.
        * `*.gene.tdt` = summary information per annotated gene
        * `*.proteins.tdt` = summary information per annotated protein
        * `*.refprot.tdt` = summary information per reference protein (Assessment mode)
        * `*.stats.tdt`= summary statistics for full annotation

        The fields for the main tables are given below. Details will be added in a future release. Please contact the
        author in the meantime if anything is not clear.


        ## Gene table [*.gene.tdt]

        * `locus` = Sequence name from assembly file
        * `source` = GFF source
        * `start` = Start position
        * `end` = End position
        * `strand` = Strand
        * `geneinfo` = Information parsed from GFF
        * `name` = Annotation gene name
        * `geneid` = Annotation gene ID (should map onto transcript Parent identifiers)
        * `isoforms` = Number of transcripts
        * `maxprotlen` = Maximum protein length
        * `longest` = Transcript ID for longest protein
        * `isoinfo` = Parsed GFF information for longest protein isoform

        ## Protein table [*.proteins.tdt]

        * `protname` = Protein sequence name
        * `protdesc` = Protein sequence description
        * `accnum` = Protein sequence accession number. Should map to Transcript ID.
        * `protlen` = Protein length (aa)
        * `exons` = No. exons
        * `exonlen` = Summed length of exons
        * `geneid` = Parent Gene ID (`geneid`)
        * `locus` = Location sequence name from assembly
        * `start` = Start position (transcript)
        * `end` = End position (transcript)
        * `strand` = Strand
        * `attributes` = Parsed GFF attributes
        * `bestref` = Best reference protein from mmseq search
        * `protcov` = Coverage of protein by `bestref` hit (0-1)
        * `refcov` = Coverage of `bestref` protein by mmseq hit (0-1)
        * `protratio` = Annotated protein length / `bestref` protein length
        * `lendiff` = Annotated protein length - `bestref` protein length
        * `alnlen` = Length of alignment
        * `pident` = Percentage identity of hit
        * `globid` = Global percentage identity of annotated protein
        * `hitnum` = Number of hits in mmseq search
        * `rbh` = Whether a reciprocal best hit (1/0)
        * `f1` = F1 score = 2 x Pr x Recall / (Pr + Recall) = 2 x protcov x refcov / (protcov + refcov)


        ## Reference protein table [*.refprot.tdt]

        * `refprot` = Reference protein name
        * `bestprot` = Top hit annotated protein
        * `alnlen` = Length of alignment
        * `pident` = Percentage identity of hit
        * `reflen` = Length of reference protein
        * `refcov` = Coverage of reference protein
        * `protcov` = Coverage of `bestprot`
        * `refdesc` = Description of reference protein
        * `f1` = F1 score = 2 x Pr x Recall / (Pr + Recall) = 2 x refcov x protcov  / (refcov + protcov)

        ## Summary statistics table

        * `seqin` = Input annotation proteome
        * `refdb` = Reference database
        * `genes` = Number of genes
        * `isoforms` = Number of transcripts
        * `exons` = Mean exons per gene
        * `exonlen` = Mean combined exon length
        * `protlen` = Mean protein length
        * `completeness` = Summed coverage of reference proteome (%)
        * `purity` = Summed reference coverage of annotated proteome (%)
        * `homology` = Percentage of genes with any hit in reference
        * `orthology` = Percentage of genes with reciprocal best hits
        * `protratio_mean` = Mean protein length ratio (only proteins with hits)
        * `protratio_median` = Median protein length ratio (only proteins with hits)
        * `protratio_sd` = StdDev of protein length ratio (only proteins with hits)
        * `duplicity` = Mean number of annotated genes sharing the same reference protein `bestref`
        * `compression` = Number of unique `bestprot` annotated genes / number of reference proteins with hit
        * `multiplicity` = Total no. Qry Genes / Total no Ref proteins
        * `f1` = Combined F1 across all query genes
        * `f1_hits` = Combined F1 across all query genes with hits
        * `mean_f1` = Mean F1 across all query genes

        ---

        # SAAGA run modes

        Details for the main SAAGA run modes will be added below.

        **NOTE:** SAAGA is under development and documentation might be a bit sparse. Please contact the author or
        post an issue on GitHub if you have any questions.

        ---

        ## Annotation assessment mode [assess=T]

        This mode compares the predicted protein sequences from an annotation to a reference proteome and asseses its
        quality and completeness.

        _Details to follow._

        **NOTE:** SAAGA is still under development. MMseqs2 stringency settings have not yet been optimised for
        performance.


        ---

        ## Annotation annotation mode [annotate=T]

        Based on MAKER2 renaming, this mode will use the top hit to reference proteins (e.g. SwissProt) to add
        descriptions to predicted gene and proteins.

        _Details to follow._

        ---

        ## Longest protein mode [longest=T]

        This will extract the longest protein per gene, e.g. for reduced `Duplicated` ratings in BUSCO completeness
        estimates.

        _Details to follow._

        ---

        ## Annotation summarise mode [summarise=T]

        This mode will summarise the annotation from a GFF file. This is also executed as part of the `assess` mode.

        _Details to follow._

        ---

        ## MMSeq2 preparation mode [mmseq=T]

        This run the mmseq2 steps in preparation for further analysis. It is primarily for debugging or when runs need
        to be split over multiple systems.

        _Details to follow._

        ---

        '''
        try:### ~ [1] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            #i# The setup will parse the input sequences and GFF
            if self.getBool('DocHTML'): return self.docHTML()
            if not self.setup(): raise ValueError('Problem during setup: aborted')
            if self.getBool('MMseqs'):
                self.makeMMseqDB()
            ### ~ [2] ~ Add main run code here ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('MMSEARCH',line='=')
            self.runMMseqSearch(reciprocal=self.runMode(['assess','annotate']))
            #!# Add tophits filtering for speed. Use just the best hit for assess mode
            tophits = self.getInt('TopHits')
            #if self.runMode(['assess']) and not self.runMode(['annotate']): tophits = 1
            #!# Removing tophits reduction for now, because we want to use tied top hits and take the best coverage
            self.bestMMseqSearch(reciprocal=self.runMode(['assess']),tophits=tophits)
            self.tabulateMMseqSearch(reciprocal=self.runMode(['assess']),tophits=tophits)
            ### ~ [3] ~ Mode-specific processing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            if self.runMode(['longest','annotate','summarise','assess']):
                self.tidyTables()
            ## ~ [3a] ~ Assess Mode ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if self.runMode(['assess']): self.statistics(assess=True)
            ## ~ [3b] ~ Summary Mode ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            elif self.runMode(['summarise']): self.statistics(assess=False)
            ## ~ [3c] ~ Annotate (Rename) Mode ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            #i# Use self.db('descmap') ranked (inverse) on hitscore, chop first word and use self.newDesc(hitdesc)
            #i# Update and output fasta file -> reload into SeqList for longest mode
            #i# Reparse, update and output GFF file with description as ';note="{0}"'.format(newdesc)
            addcov = True   #!# Make an option
            unknown = 'Predicted protein'   #!# Make an option
            if self.runMode(['annotate']):
                descdb = self.db('descmap')  # - protname - refhit - hitscore - hitdesc
                seqlist = self.obj['SeqIn']
                newdesc = {}
                for seq in seqlist.seqs():
                    sname = seqlist.shortName(seq)
                    if descdb.data((sname,1)):
                        dentry = descdb.data((sname,1))
                        hitdesc = ' '.join(dentry['hitdesc'].split()[1:])
                        newdesc[sname] = self.newDesc(hitdesc)
                        if addcov:
                            newdesc[sname] = newdesc[sname] + ' ({0:.1f}% cov @{1:.1f}%id)'.format(100.0*dentry['refcov'],100.0*dentry['pident'])
                    elif seqlist.seqDesc(seq): newdesc[sname] = seqlist.seqDesc(seq)
                    else: newdesc[sname] = unknown
                seqlist.setStr({'SeqOut':'{0}.renamed.faa'.format(self.baseFile())})
                seqlist.newDesc(newdesc,keepname=True)
                seqlist.setStr({'SeqIn':'{0}.renamed.faa'.format(self.baseFile())})
                seqlist.loadSeq()
                #i# Update transcript file
                if self.obj['CDSIn']:
                    cds = self.obj['CDSIn']
                    cds.setStr({'SeqOut':'{0}.renamed.fna'.format(self.baseFile())})
                    cds.newDesc(newdesc,keepname=True)
                    cds.setStr({'SeqIn':'{0}.renamed.fna'.format(self.baseFile())})
                    cds.loadSeq()
                #i# Update GFF file
                pdb = self.db('proteins')  # newkey=['protname'] -> geneid
                for protname in rje.sortKeys(newdesc):
                    if pdb.data(protname):
                        geneid = pdb.data(protname)['geneid']
                        if geneid not in newdesc: newdesc[geneid] = newdesc[protname]
                newgff = '{0}.renamed.gff'.format(self.baseFile())
                rje.backup(self,newgff,appendable=False)
                IN = open(self.getStr('GFFIn'),'r')
                OUT = open(newgff,'w')
                gline = IN.readline(); gx = 1
                while gline:
                    self.progLog('\r#GFF','Updating {0} GFF lines'.format(rje.iStr(gx)),rand=0.01)
                    if gline.startswith('#'): OUT.write(gline)
                    else:
                        gtext = rje.chomp(gline)
                        gdata = string.split(gtext,'\t')
                        if gdata[2].lower() in ['gene','mrna']:
                            attlist = rje.longCmd(string.split(gdata[8],';'))
                            id = ''
                            for attdata in attlist:
                                if not attdata: continue
                                try:
                                    [att,val] = string.split(attdata,'=')
                                    if att.lower() == 'id': id = val; break
                                except:
                                    self.warnLog('Problem with GFF attribute: {0}'.format(attdata))
                            if id and id in newdesc and newdesc[id]:
                                if not gtext[-1:] == ';': gtext = gtext + ';'
                                gtext = '{0}note="{1}"'.format(gtext,newdesc[id])
                                OUT.write('{0}\n'.format(gtext))
                        else: OUT.write(gline)
                    gline = IN.readline(); gx += 1
                self.printLog('\r#GFF','Updated {0} GFF lines -> {1}'.format(rje.iStr(gx),newgff))
            ## ~ [3d] ~ Longest Mode ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            #i# Pull out 'longest' field IDs from self.db('gene')
            if self.runMode(['longest']):
                longfas = '{0}.longest.faa'.format(self.baseFile())
                genedb = self.db('gene')
                longids = genedb.dataList(genedb.entries(),'longest',sortunique=True,empties=False)
                seqlist = self.obj['SeqIn']
                longseq = []    # List of sequences to output
                for seq in seqlist.seqs():
                    if seqlist.shortName(seq) in longids: longseq.append(seq)
                seqlist.saveSeq(seqs=longseq,seqfile=longfas,reformat='fasta',append=False)
                if self.obj['CDSIn']:
                    cds = self.obj['CDSIn']
                    longfas = '{0}.longest.fna'.format(self.baseFile())
                    longseq = []    # List of sequences to output
                    for seq in cds.seqs():
                        if cds.shortName(seq) in longids: longseq.append(seq)
                    cds.saveSeq(seqs=longseq,seqfile=longfas,reformat='fasta',append=False)
            return
        except:
            self.errorLog(self.zen())
            raise   # Delete this if method error not terrible
#########################################################################################################################
    def seqBase(self): return rje.baseFile(self.getStr('SeqIn'),strip_path=True)
    def refBase(self): return rje.baseFile(self.getStr('RefProt'),strip_path=True)
    def seqMMDB(self): return '{0}{1}'.format(self.getStr('MMSeqDB'),self.seqBase())
    def refMMDB(self):
        if not self.getStrLC('RefDB'): self.setStr({'RefDB':'{0}{1}'.format(self.getStr('MMSeqDB'),self.refBase())})
        return self.getStr('RefDB')
#########################################################################################################################
    def runMode(self,checkmodes,allmodes=False):   # Check run modes and return True if any active or False if not
        '''
        Check run modes and return True if any active or False if not
        :param checkmodes: list of modes to check. Will print settings to log if none given
        :param allmodes: whether all modes given must be set to return True.
        :return: True/False
        '''
        if not checkmodes:
            for modestr in ['Annotate','Assess','Longest','MMseqs','Summarise']:
                self.printLog('#MODE','{0}: {1}'.format(modestr,self.getBool(modestr)))
            return False
        modekeys = {}
        for modestr in ['Annotate','Assess','Longest','MMseqs','Summarise']:
            modekeys[modestr] = modestr
            modekeys[modestr.lower()] = modestr
        active = None
        for modestr in checkmodes:
            try: modestr = modekeys[modestr]
            except:
                self.warnLog('Unrecognised modestring given: {0}'.format(modestr))
                return False
            if allmodes and active == None: active = self.getBool(modestr)
            elif allmodes: active = active and self.getBool(modestr)
            else: active = active or self.getBool(modestr)
        return active
#########################################################################################################################
    def setup(self):    ### Main class setup method.
        '''Main class setup method.'''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            try:
                mmseq = os.popen('mmseqs').readline().split()[0]
                if mmseq == 'MMseqs2': self.printLog('#MMSEQ2','MMseqs2 found')
                else: raise ValueError('Ran "mmseqs" - expected "MMseqs2", returned "{0}"'.format(mmseq))
                rje.mkDir(self,self.getStr('MMSeqDB'))
            except:
                self.warnLog('MMseqs2 installation not found. Some functionality will not work.')
                self.setBool({'MMseqs':False})
            ## ~ [1a] Basefile ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if not self.getStrLC('Basefile'): self.baseFile('{0}.{1}'.format(self.seqBase(),self.refBase()))
            self.printLog('#SEQIN',self.seqBase())
            self.printLog('#REFDB',self.refBase())
            self.printLog('#BASE',self.basefile())
            self.runMode([])
            ## ~ [1b] Precomputed MMSeq2 options ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if not self.getStrLC('MMQryMap'): self.setStr({'MMQryMap':'{0}.{1}.mmseq.tsv'.format(self.seqBase(),self.refBase())})
            if not self.getStrLC('MMHitMap'): self.setStr({'MMHitMap':'{1}.{0}.mmseq.tsv'.format(self.seqBase(),self.refBase())})
            ## ~ [1c] Protein sequence table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            seqlist = self.obj['SeqIn'] = rje_seqlist.SeqList(self.log,self.cmd_list+['seqmode=file','summarise=F','autofilter=F'])
            seqlist.obj['DB'] = self.obj['DB']
            if self.runMode(['longest','annotate','summarise','assess']):
                seqlist.summarise(sumdb=True,save=False)
                seqdb = self.db('sequences') #['name','desc','gene','spec','accnum','length']
                #i# Drop gene and spec fields
                #i# Will use the name field to check against GFF
            ## ~ [1d] Transcript sequences for renaming ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if self.runMode(['longest','annotate','summarise']):
                self.obj['CDSIn'] = None
                if rje.exists(self.getStr('CDSIn')):
                    cds = self.obj['CDSIn'] = rje_seqlist.SeqList(self.log,self.cmd_list+['seqmode=file','summarise=F','autofilter=F','seqin={0}'.format(self.getStr('CDSIn'))])
                    if self.getBool('Summarise'):
                        cds.summarise(sumdb=False,save=False)
                elif self.getStrLC('CDSIn'):
                    self.warnLog('Transcript file cdsin="{0}" not found: no transcript fasta output'.format(self.getStr('CDSIn')))
            ## ~ [1e] RefProt ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            #!# Check precomputed and force and switch NeedDB=False
            if self.runMode(['assess','annotate']):
                refprot = self.obj['RefProt'] = rje_seqlist.SeqList(self.log,self.cmd_list+['seqmode=file','summarise=F','seqin={0}'.format(self.getStr('RefProt')),'autofilter=F'])
                if self.runMode(['assess']):
                    refprot.summarise(sumdb=True,save=False)
                if self.runMode(['assess']) and refprot.seqNum() > 100000:
                    self.warnLog('Assement mode activated but reference proteome has >100k proteins ({0})'.format(rje.iStr(refprot.seqNum())))
                    if self.i() > -1 and rje.yesNo('Switch assess=F?',default='N'): self.setBool({'Assess':False})
            ### ~ [2] GFF parsing and data checks ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            #i# Parse GFF file
            #i# Will want to use the name field of self.db('sequences') to check against GFF IDs for mRNA
            if self.runMode(['longest','annotate','summarise','assess']):
                #i# Parse a table of ['locus', 'source', 'ftype', 'start', 'end', 'score', 'strand', 'phase', 'attributes']
                #i# Elements also extracted from attributes into fields
                #!# Update self.obj['GFF'].list['Attributes'] = List of attributes (X=Y;) to pull out into own fields ("*" or "all" for all) [*]
                #i# Keys: ['locus','strand','start','end','source','ftype']
                #i# start and end will be integers
                #i# GeMoMa GFF:
                # CHINACHR29.01   GAF     gene    74976   128160  .       -       .       Name=BASCHINAG22344;ID=BASCHINAG22344;transcripts=1;complete=1;maxEvidence=1;combinedEvidence=1
                # CHINACHR29.01   GeMoMa  mRNA    74976   128160  .       -       .       Name=BASCHINAG22344.1;ID=BASCHINAG22344.1;ref-gene=cattle_gene97;aa=107;score=117;ce=2;rce=2;pAA=0.6241;iAA=0.3684;nps=0;start=M;stop=*;evidence=1;Parent=BASCHINAG22344;sumWeight=1.0;
                # CHINACHR29.01   GeMoMa  CDS     128029  128160  .       -       0       Parent=BASCHINAG22344.1
                ftypes = [self.getStr('GFFGene'),self.getStr('GFFmRNA'),self.getStr('GFFCDS'),'gene','mRNA','prediction','CDS']
                self.obj['GFF'].list['Attributes'] = ['Name','ID','Parent']
                self.obj['GFF'].parseGFF(self.getStr('GFFIn'),ftypes=ftypes) #,parseattributes=False)
                self.printLog('#GFF','GFF Fields: %s' % ', '.join(self.db('features').fields()))
                ## ~ [2a] Reduce fields ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                gffdb = self.db('features')
                #i# features -> ['locus','strand','start','end','source','ftype']: ['locus', 'source', 'ftype', 'start', 'end', 'score', 'strand', 'phase', 'attributes']
                #i#     |-- Elements also extracted from attributes into fields
                #i#     |-- start and end will be integers
                gffdb.rename('gff')
                gffdb.dropFields(['score','phase'])
                ## ~ [2b] Split tables created and loaded ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                self.db().splitTable(gffdb,'ftype',asdict=True,keepfield=False,splitchar=None,values=[],add=True)   ### Splits table based on unique values of given field
                gtype = self.getStr('GFFGene')
                mtype = self.getStr('GFFmRNA')
                ctype = self.getStr('GFFCDS')
                genedb = self.db('gff_{0}'.format(gtype))
                transdb = self.db('gff_{0}'.format(mtype))
                exondb = self.db('gff_{0}'.format(ctype))
                if not self.getStrLC('GFFGene'): genedb = None
                if not self.getStrLC('GFFmRNA'): transdb = None
                if not self.getStrLC('GFFCDS'): exondb = None
                gfftype = 'gemoma'   #!# May want to add alternative annotation sources at some point, or extract from GFF?
                if gfftype == 'gemoma':
                    if not genedb: gtype = 'gene'; genedb = self.db('gff_{0}'.format(gtype))
                    if not transdb: mtype = 'mRNA'; transdb = self.db('gff_{0}'.format(mtype))
                    if not transdb: mtype = 'prediction'; transdb = self.db('gff_{0}'.format(mtype))
                    if not exondb: ctype = 'CDS'; exondb = self.db('gff_{0}'.format(ctype))
                if genedb:
                    if genedb != self.db('gff_{0}'.format(gtype)):
                        self.printLog('#GFF','GFFType={0}: GFFGene={1} -> {2}'.format(gfftype,self.getStr('GFFGene'),gtype))
                else: raise ValueError('Unable to consolidate tables without valid gffgene=X and GFF file')
                if transdb:
                    if transdb != self.db('gff_{0}'.format(mtype)):
                        self.printLog('#GFF','GFFType={0}: GFFmRNA={1} -> {2}'.format(gfftype,self.getStr('GFFmRNA'),mtype))
                else: raise ValueError('Unable to consolidate tables without valid gffmrna=X and GFF file')
                if exondb:
                    if exondb != self.db('gff_{0}'.format(ctype)):
                        self.printLog('#GFF','GFFType={0}: GFFCDS={1} -> {2}'.format(gfftype,self.getStr('GFFCDS'),ctype))
                else: raise ValueError('Unable to consolidate tables without valid gffcds=X and GFF file')
                genedb.rename('gene')
                transdb.rename('trans')
                exondb.rename('exons')
                ## ~ [2c] Check data integrity by cross-referencing key data ~~~~~~~~~~~~~~~~~~~~~~ ##
                seqaccs = seqdb.dataList(seqdb.entries(),'accnum')
                #seqnames = seqdb.dataList(seqdb.entries(),'name')
                geneid = genedb.dataList(genedb.entries(),'id')
                transid = transdb.dataList(transdb.entries(),'id')
                transpar = transdb.dataList(transdb.entries(),'parent')
                exonpar = exondb.dataList(exondb.entries(),'parent')
                #i# genedb['id'] should match transdb['parent']
                badgene = rje.listDifference(transpar,geneid)
                if badgene:
                    self.warnLog('{0} of {1} transcript parent identifiers not found in Gene IDs: check GFF formatting'.format(rje.iLen(badgene),rje.iLen(transpar)))
                else:
                    self.printLog('#GFF','All {0} transcript parent identifiers mapped to Gene IDs: OK'.format(rje.iLen(transpar)))
                #i# transdb['id'] should match exondb['parent']
                badtrans = rje.listDifference(exonpar,transid)
                if badtrans:
                    self.warnLog('{0} of {1} exon parent identifiers not found in transcript IDs: check GFF formatting'.format(rje.iLen(badtrans),rje.iLen(exonpar)))
                else:
                    self.printLog('#GFF','All {0} exon parent identifiers mapped to transcript IDs: OK'.format(rje.iLen(exonpar)))
                #i# transdb['id'] should match seqdb['name']
                seqnames = seqaccs  #i# Currently actually mapping via accnum
                badseq = rje.listDifference(seqnames,transid)
                if badseq:
                    self.warnLog('{0} of {1} protein sequence names not found in transcript IDs: check GFF and protein fasta formatting'.format(rje.iLen(badseq),rje.iLen(seqnames)))
                else:
                    self.printLog('#GFF','All {0} protein sequence names mapped to transcript IDs: OK'.format(rje.iLen(seqnames)))
                badtransid = rje.listDifference(transid,seqnames)
                if badtransid:
                    self.warnLog('{0} of {1} transcript IDs not found in protein sequence names: check GFF and protein fasta formatting'.format(rje.iLen(badtransid),rje.iLen(transid)))
                else:
                    self.printLog('#GFF','All {0} transcript IDs mapped to protein sequence names: OK'.format(rje.iLen(transid)))
                #i# Option to quit
                if badgene or badtrans or badseq or badtransid and rje.i() > -1 and rje.yesNo('Possible input errors. Abort run?'):
                    return False
            return True     # Setup successful
        except: self.errorLog('Problem during %s setup.' % self.prog()); return False  # Setup failed
#########################################################################################################################
    def restSetup(self):    ### Sets up self.dict['Output'] and associated output options if appropriate.
        '''
        Run with &rest=docs for program documentation and options. A plain text version is accessed with &rest=help.
        &rest=OUTFMT can be used to retrieve individual parts of the output, matching the tabs in the default
        (&rest=format) output. Individual `OUTFMT` elements can also be parsed from the full (&rest=full) server output,
        which is formatted as follows:

        ###~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~###
        # OUTFMT:
        ... contents for OUTFMT section ...
        #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#

        ### Available REST Outputs:
        There is currently no specific help available on REST output for this program.
        '''
        try:### ~ [0] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            for outfmt in self.restOutputOrder(): self.dict['Output'][outfmt] = 'No output generated.'
            #!# Add specific program output here. Point self.dict['Output'][&rest=X] to self.str key.
            return
        except: self.errorLog('RestSetup error')
#########################################################################################################################
    def restOutputOrder(self): return rje.sortKeys(self.dict['Output'])
#########################################################################################################################
    def docHTML(self):  ### Generate the SAAGA Rmd and HTML documents.                                        # v0.1.0
        '''Generate the SAAGA Rmd and HTML documents.'''
        try:### ~ [1] ~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            info = self.log.obj['Info']
            prog = '%s V%s' % (info.program,info.version)
            rmd = rje_rmd.Rmd(self.log,self.cmd_list)
            rtxt = rmd.rmdHead(title='%s Documentation' % prog,author='Richard J. Edwards',setup=True)
            #!# Replace this with documentation text?
            rtxt += string.replace(self.run.__doc__,'\n        ','\n')
            rtxt += '\n\n<br>\n<small>&copy; 2020 Richard Edwards | richard.edwards@unsw.edu.au</small>\n'
            rmdfile = '%s.docs.Rmd' % self.baseFile()
            open(rmdfile,'w').write(rtxt)
            self.printLog('#RMD','RMarkdown SAAGA documentation output to %s' % rmdfile)
            rmd.rmdKnit(rmdfile)
        except:
            self.errorLog(self.zen())
            raise   # Delete this if method error not terrible
#########################################################################################################################
    ### <2> ### Database Methods                                                                                        #
#########################################################################################################################
    #i# sequences -> name:['name','desc','gene','spec','accnum','length']
    #i# features -> ['locus','strand','start','end','source','ftype']: ['locus', 'source', 'ftype', 'start', 'end', 'score', 'strand', 'phase', 'attributes']
    #i#     |-- Elements also extracted from attributes into fields
    #i#     |-- start and end will be integers
    #i# loci -> locus:['locus','start','end','sequence']
    #i# qrymap ->  query,target:[query,target,evalue,raw,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov,theader]
    #i# hitmap ->  query,target:[query,target,evalue,raw,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov]
#########################################################################################################################
    #i# GeMoMa GFF:
    # CHINACHR29.01   GAF     gene    74976   128160  .       -       .       Name=BASCHINAG22344;ID=BASCHINAG22344;transcripts=1;complete=1;maxEvidence=1;combinedEvidence=1
    # CHINACHR29.01   GeMoMa  mRNA    74976   128160  .       -       .       Name=BASCHINAG22344.1;ID=BASCHINAG22344.1;ref-gene=cattle_gene97;aa=107;score=117;ce=2;rce=2;pAA=0.6241;iAA=0.3684;nps=0;start=M;stop=*;evidence=1;Parent=BASCHINAG22344;sumWeight=1.0;
    # CHINACHR29.01   GeMoMa  CDS     128029  128160  .       -       0       Parent=BASCHINAG22344.1
    # CHINACHR29.01   GeMoMa  CDS     74976   75164   .       -       0       Parent=BASCHINAG22344.1
#########################################################################################################################
    def tidyTables(self,save=True):   ### Consolidate the database tables, adjusting fields and keys
        '''
        Consolidate the database tables, adjusting fields and keys.

        # Annotated protein sequence table
        - protname
        - protlen
        - protdesc
        - protid = parent mRNA ID from GFF
        - exons = exon count (CDS feature) from GFF -> Might need to modify for other GFF Types
        - exonlen = combined length of exons from GFF
        - geneid = parent gene from GFF
        - locus = location data parsed from GFF for mRNA
        - strand
        - start
        - end
        - attributes = mRNA attributes parsed from GFF
        - bestref (qrymap:target)
        - protcov (qrymap:qcov)
        - refcov (qrymap:tcov)
        - protratio (qrymap:(qlen/tlen))
        - rbh = whether bestref has protid as bestprot [Q. How to handle isoforms in Reference?]

        # Reference protein sequence table [assess mode]
        - refprot
        - reflen
        - refdesc
        - bestprot (hitmap:target)
        - protcov (hitmap:tcov)
        - refcov (hitmap:qcov)
        - protratio (qrymap:(qlen/tlen))

        # Annotated genes from GFF
        - geneid
        - locus = location data parsed from GFF for mRNA
        - strand
        - start
        - end
        - isoforms = number of proteins
        - maxprotlen = max protein length
        - longest = protname of longest isoform
        - attributes = mRNA attributes parsed from GFF

        ## Proteins mapped onto reference
        - refhit
        - hitscore
        - hitdesc

        '''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('CONSOLIDATE TABLES',line='=')
            db = self.db()
            ## ~ [1a] Tables created and loaded ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            #i# sequences -> name:['name','desc','gene','spec','accnum','length']
            seqdb = self.db('sequences')
            db.list['Tables'].append(seqdb)

            #i# Splitting and initial processing of GFF tables managed by Setup
            genedb = self.db('gene')
            transdb = self.db('trans')
            exondb = self.db('exons')

            genedb.newKey(['id'])
            transdb.newKey(['id'])
            exondb.newKey(['parent','start','end'])
            exondb.keepFields(['parent','start','end'])
            exondb.renameField('parent','id')
            exondb.addField('exons',evalue=1)
            exondb.makeField('end-start+1','exonlen')
            exondb.compress(['id'],rules={'start':'min','end':'max','exons':'sum','exonlen':'sum'})

            #i# loci -> locus:['locus','start','end','sequence']
            locdb = self.db('loci')
            #i# qrymap ->  query,target:[query,target,evalue,raw,alnlen,pident,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov,theader]
            qrymap = self.db('qrymap')
            descdb = db.copyTable(qrymap,'descmap') # For annnotation
            descdb.keepFields(['query','target','raw','tcov','pident','theader'])
            qrymap.rankFieldByIndex('query','raw',newfield='rank',rev=True,absolute=True,lowest=True,unique=False,warn=True,highest=False)
            if self.getInt('TopHits'):
                qrymap.dropEntries(['rank>{0}'.format(self.getInt('TopHits'))])
            qrymap.makeField('100*qcov*pident','globid')
            if self.getNum('MinGlobID'):
                qrymap.dropEntries(['globid<{0}'.format(self.getNum('MinGlobID'))])
            qrymap.addField('hitnum',evalue=1)
            qrymap.index('target')
            for qentry in qrymap.entries():
                qentry['hitnum'] = len(qrymap.index('target')[qentry['target']])
            #i# Reduce to best hit
            qrymap.compress(['query'],best=['raw','globid','qcov','tcov'])
            #i# Assuming qcov and pident are both 0-1 scales
            qrymap.makeField('qlen/tlen','protratio')
            qrymap.makeField('qlen-tlen','lendiff')
            #i# Check for SLiMSuite format names
            queries = qrymap.dataList(qrymap.entries(),'query')
            seqaccs = seqdb.dataList(seqdb.entries(),'accnum')
            goodacc = rje.listIntersect(seqaccs,queries)
            seqnames = seqdb.dataList(seqdb.entries(),'name')
            goodseq = rje.listIntersect(seqnames,queries)
            if rje.listDifference(goodseq,goodacc):
                self.printLog('#ACCNUM','SeqSuite GnSpAcc format recognised: translating sequence names to accnum')
                name2acc = {}; idx = 0
                for entry in seqdb.entries():
                    name2acc[entry['name']] = entry['accnum']
                    if entry['name'] == entry['accnum']: idx += 1
                self.printLog('#ACCNUM','%s name to accnum translations (%s identical)' % (rje.iLen(name2acc),rje.iStr(idx)))
                mapx = 0
                for qentry in qrymap.entries():
                    if qentry['query'] != name2acc[qentry['query']]:
                        qentry['query'] = name2acc[qentry['query']]
                        mapx += 1
                self.printLog('#QRYMAP','%s MMSeqs query name to accnum translations made' % (rje.iStr(mapx)))
            #i# hitmap ->  query,target:[query,target,evalue,raw,alnlen,pident,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov]
            if self.runMode(['assess']):
                hitmap = self.db('hitmap')
                hitmap.rankFieldByIndex('query','raw',newfield='rank',rev=True,absolute=True,lowest=True,unique=False,warn=True,highest=False)
                #i# Reduce to all best hits for RBH
                hitmap.dropEntriesDirect('rank',[1],inverse=True)

            ### ~ [2] Consolidate tables ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            ## ~ [2a] Annotated protein sequence table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            self.headLog('Annotated protein sequence table',line='-')
            # - protname
            seqdb.renameField('name','protname')
            # - protlen
            seqdb.renameField('length','protlen')
            # - protdesc
            seqdb.renameField('desc','protdesc')
            joinlist = [(seqdb,'accnum'),
                        (exondb,'id',['exons','exonlen']),
                        (transdb,'id',['parent','locus','start','end','strand','attributes']),
                        (qrymap,'query',['target','qcov','tcov','protratio','lendiff','alnlen','pident','globid','hitnum'])]
            # - accnum = parent mRNA ID from GFF
            # - exons = exon count (CDS feature) from GFF -> Might need to modify for other GFF Types
            # - exonlen = combined length of exons from GFF
            # - geneid = parent gene from GFF
            # - locus = location data parsed from GFF for mRNA
            # - strand
            # - start
            # - end
            # - attributes = mRNA attributes parsed from GFF
            # - bestref (qrymap:target)
            # - protcov (qrymap:qcov)
            # - refcov (qrymap:tcov)
            # - protratio (qrymap:(qlen/tlen))
            # - rbh = Whether it is a reciprocal best hit of a reference protein
            # - f1 = the F1 score = 2 x Pr x Recall / (Pr + Recall)
            #    |- Pr = TP / (TP + FP) = qcov
            #           |- TP = qcov
            #           |- FP = (1 - qcov)
            #    |- Recall = TP / (TP + FN)
            #           | = tcov
            protdb = db.joinTables('proteins',join=joinlist,newkey=['protname'],cleanup=True,delimit='\t',empties=True,check=False,keeptable=True,warnings=True)
            protdb.renameField('parent','geneid')
            protdb.renameField('target','bestref')
            protdb.renameField('qcov','protcov')
            protdb.renameField('tcov','refcov')
            protdb.dropFields(['gene','spec']) #?# Drop protdesc?
            protdb.fillBlanks(blank=0,fields=['protcov','refcov','protratio','lendiff','alnlen','pident','globid','hitnum'],fillempty=True,prog=True,log=True)
            # - rbh = whether bestref has protid as bestprot [Q. How to handle isoforms in Reference?]
            protdb.addField('rbh',evalue=0)
            protdb.addField('f1',evalue=0)
            for pentry in protdb.entries():
                if self.runMode(['assess']):
                    if pentry['protname'] in hitmap.indexDataList('query',pentry['bestref'],'target'): pentry['rbh'] = 1
                    elif pentry['accnum'] in hitmap.indexDataList('query',pentry['bestref'],'target'): pentry['rbh'] = 1
                if pentry['protcov']: pentry['f1'] = 2 * pentry['protcov'] * pentry['refcov'] / (pentry['protcov'] + pentry['refcov'])
            if save: protdb.saveToFile()

            # # Reference protein sequence table [assess mode]
            # - refprot
            # - reflen
            # - refdesc - read in from fasta?
            # - bestprot (hitmap:target)
            # - protcov (hitmap:tcov)
            # - refcov (hitmap:qcov)
            # - protratio (qrymap:(qlen/tlen))
            # - f1 = 2 * protcov * refcov / (protcov + refcov)
            if self.runMode(['assess']):
                hitmap.rename('refprot')
                hitmap.makeField('qcov+tcov','totcov')
                hitmap.makeField('qlen/tlen','protratio')
                hitmap.dropField('rank')
                hitmap.rankFieldByIndex('query','totcov',newfield='rank',rev=True,absolute=True,unique=True,warn=True)
                hitmap.dropEntriesDirect('rank',[1],inverse=True)
                hitmap.newKey(['query'])
                hitmap.renameField('query','refprot')
                hitmap.renameField('qlen','reflen')
                hitmap.renameField('target','bestprot')
                hitmap.renameField('tcov','protcov')
                hitmap.renameField('qcov','refcov')
                hitmap.addField('refdesc')
                hitmap.keepFields(['refprot','reflen','refdesc','bestprot','protcov','refcov','alnlen','pident'])
                hitmap.addField('f1',evalue=0.0)
                for pentry in hitmap.entries():
                    if pentry['protcov']: pentry['f1'] = 2 * pentry['protcov'] * pentry['refcov'] / (pentry['protcov'] + pentry['refcov'])
                refprot = self.obj['RefProt'].db('sequences')   # ['name','desc','gene','spec','accnum','length']
                for refseq in refprot.entries():
                    found = hitmap.data(refseq['name'])
                    name = 'name'
                    if not found: found = hitmap.data(refseq['accnum']); name = 'accnum'
                    if found: found['refdesc'] = refseq['desc']
                    else: hitmap.addEntry({'refprot':refseq[name],'reflen':refseq['length'],'refdesc':refseq['desc'],'bestprot':'',
                                           'protcov':0,'refcov':0,'protratio':0,'f1':0})
                if save: hitmap.saveToFile()

            # # Annotated genes from GFF
            # - geneid
            # - locus = location data parsed from GFF for mRNA
            # - strand
            # - start
            # - end
            # - isoforms = number of proteins
            # - maxprotlen = max protein length
            # - longest = protname of longest isoform
            # - attributes = mRNA attributes parsed from GFF
            #i# features -> ['locus','strand','start','end','source','ftype']: ['locus', 'source', 'ftype', 'start', 'end', 'score', 'strand', 'phase', 'attributes']
            genedb.renameField('id','geneid')
            genedb.renameField('attributes','geneinfo')
            genedb.dropField('parent')
            genedb.addField('isoforms',evalue=0)
            genedb.addField('maxprotlen',evalue=0)
            genedb.addField('longest',evalue="")
            genedb.addField('isoinfo',evalue="")
            for gene in genedb.entries():
                geneid = gene['geneid']
                for isoform in protdb.indexEntries('geneid',geneid):
                    gene['isoforms'] += 1
                    if isoform['protlen'] > gene['maxprotlen']:
                        gene['maxprotlen'] = isoform['protlen']
                        gene['longest'] = isoform['accnum']
                        gene['isoinfo'] = isoform['attributes']
            if save: genedb.saveToFile()

            # ## Proteins mapped onto reference
            # - protname
            # - refhit
            # - hitscore
            # - hitdesc
            descdb.renameField('query','protname')
            descdb.renameField('target','refhit')
            descdb.renameField('raw','hitscore')
            descdb.renameField('tcov','refcov')
            descdb.renameField('theader','hitdesc')
            descdb.rankFieldByIndex('protname','hitscore',newfield='rank',rev=True,absolute=True,lowest=False,unique=True,warn=True,highest=False)
            descdb.newKey(['protname','rank'])
            descdb.keepFields(['protname','rank','hitscore','pident','refcov','refhit','hitdesc'])
            for dentry in descdb.entries():
                dsplit = dentry['hitdesc'].split()
                if len(dsplit) > 1 and dsplit[0] == dentry['refhit']:
                    dentry['hitdesc'] = ' '.join(dsplit[1:])
            if self.debugging() or self.dev(): descdb.saveToFile()

        except: self.errorLog('%s.tidyTables error' % self.prog()); raise
#########################################################################################################################
    # def annotate(self):
        # replace Similar to: Similar to:
        #?# TopHits=INT for annotation carryover? (Use the dominant annotation)
    #!# Add a list of annotations to ignore/downweight, e.g. Uncharacterised protein.
#########################################################################################################################
    ### <3> ### MMseq2 Methods                                                                                          #
#########################################################################################################################
    def makeMMseqDB(self):      ### Checks and creates MMseq2 databases
        '''
        Checks and creates MMseq2 databases.
        '''
        try:### ~ [1] MMseq2 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Make MMseq2 databases',line='-')
            ## ~ [1a] Reference database ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            refdb = self.refMMDB()
            refprot = self.getStr('RefProt')
            if rje.checkForFile(refprot):
                if rje.exists(refdb) and not self.force():
                    self.printLog('#REFDB','{0} already exists (force=F)'.format(refdb))
                else:
                    mmcmd = 'mmseqs createdb {0} {1} --dbtype 1'.format(refprot,refdb)
                    self.loggedSysCall(mmcmd)
            elif self.runMode(['Annotate','Assess','MMseqs']):
                raise IOError('Reference proteome not found: {0}'.format(refprot))
            ## ~ [1b] Query database ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            seqdb = self.seqMMDB()
            seqin = self.getStr('SeqIn')
            if rje.checkForFile(seqin):
                if rje.exists(seqdb) and not self.force():
                    self.printLog('#SEQDB','{0} already exists (force=F)'.format(seqdb))
                else:
                    mmcmd = 'mmseqs createdb {0} {1} --dbtype 1'.format(seqin,seqdb)
                    self.loggedSysCall(mmcmd)
            elif self.runMode(['Annotate','Assess','MMseqs','Summarise']):
                raise IOError('Annotation proteome not found: {0}'.format(refprot))
            ### ~ [2] Check ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            allgood = True
            for filename in [refprot,refdb,seqin,seqdb]:
                if not rje.checkForFile(filename):
                    self.warnLog('File "%s" does not exist.' % filename,'file_missing')
                    allgood = False

            return allgood
        except: self.errorLog('%s.makeMMseqDB error' % self.prog()); raise
#########################################################################################################################
    def runMMseqSearch(self,reciprocal=True):      ### Runs MMseqs search
        '''
        Generate mmseq table:

        mmseqs search toad_proteins human_proteome toad2human /scratch/tmp/
        mmseqs filterdb toad2human toad2human-best --extract-lines 1
        mmseqs convertalis toad_proteins human_proteome toad2human-best toad2human-best.table --format-output "query,target,evalue,raw,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov"

        mmseqs convertalis toad_proteins human_proteome toad2human-best toad2human-best.table --format-output "query,target,evalue,raw,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov"
        '''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Run MMseq2 searches',line='-')
            refdb = self.refMMDB()
            seqdb = self.seqMMDB()
            tmpdir = self.getStr('TmpDir')
            searchdir = self.getStr('MMSearch')
            rje.mkDir(self,searchdir)
            outbase = '{0}{1}'.format(searchdir,self.basefile())
            if tmpdir != '$TMPDIR': rje.mkDir(self,tmpdir,True)
            self.printLog('#TMP','TmpDir: {0}'.format(tmpdir))
            ### ~ [2] Run ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            #!# Add mmsearchdir to output names to keep things clean. (And option to clean up everything at end)
            outfile = '{0}.mmsearch'.format(outbase)
            checkfile = '{0}.index'.format(outfile)
            if rje.exists(checkfile) and not self.force():
                self.printLog('#MMSEQ','{0} already exists (force=F)'.format(checkfile))
            else:
                mmcmd = 'mmseqs search {0} {1} {2} {3}'.format(seqdb,refdb,outfile,tmpdir)
                self.loggedSysCall(mmcmd)
            if not rje.checkForFile(checkfile):
                raise IOError('File "%s" not generated.' % checkfile)
            if not reciprocal: return True
            outfile = '{0}.invsearch'.format(outbase)
            checkfile = '{0}.index'.format(outfile)
            if rje.exists(checkfile) and not self.force():
                self.printLog('#MMSEQ','{0} already exists (force=F)'.format(checkfile))
            else:
                mmcmd = 'mmseqs search {1} {0} {2} {3}'.format(seqdb,refdb,outfile,tmpdir)
                self.loggedSysCall(mmcmd)
            if not rje.checkForFile(checkfile):
                raise IOError('File "%s" not generated.' % checkfile)

            return True
        except: self.errorLog('%s.runMMseqSearch error' % self.prog()); raise
#########################################################################################################################
    def bestMMseqSearch(self,reciprocal=True,tophits=1):      ### Filters MMseqs search to best hits
        '''
        Generate mmseq table:

        mmseqs filterdb toad2human toad2human-best --extract-lines 1
        '''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Filter MMseq2 searches',line='-')
            searchdir = self.getStr('MMSearch')
            rje.mkDir(self,searchdir)
            outbase = '{0}{1}'.format(searchdir,self.basefile())
            ### ~ [2] Run ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            infile = '{0}.mmsearch'.format(outbase)
            outfile = '{0}.mmsearch-best'.format(outbase)
            if tophits > 1: outfile = '{0}.mmsearch-top{1}'.format(outbase,tophits)
            else: tophits = 1
            checkfile = '{0}.index'.format(outfile)
            if rje.exists(checkfile) and not self.force():
                self.printLog('#MMSEQ','{0} already exists (force=F)'.format(checkfile))
            else:
                mmcmd = 'mmseqs filterdb {0} {1} --extract-lines {2}'.format(infile,outfile,tophits)
                self.loggedSysCall(mmcmd)
            if not rje.checkForFile(checkfile):
                raise IOError('File "%s" not generated.' % checkfile)
            if not reciprocal: return True
            infile = '{0}.invsearch'.format(outbase)
            outfile = '{0}.invsearch-best'.format(outbase)
            if tophits > 1: outfile = '{0}.invsearch-top{1}'.format(outbase,tophits)
            checkfile = '{0}.index'.format(outfile)
            if rje.exists(checkfile) and not self.force():
                self.printLog('#MMSEQ','{0} already exists (force=F)'.format(checkfile))
            else:
                mmcmd = 'mmseqs filterdb {0} {1} --extract-lines {2}'.format(infile,outfile,tophits)
                self.loggedSysCall(mmcmd)
            if not rje.checkForFile(checkfile):
                raise IOError('File "%s" not generated.' % checkfile)

            return True
        except: self.errorLog('%s.runMMseqSearch error' % self.prog()); raise
#########################################################################################################################
    def tabulateMMseqSearch(self,fields=None,reciprocal=True,loaddb=True,tophits=0):      ### Tabulate MMSearch methods
        '''
        Generate mmseq table:

        mmseqs convertalis toad_proteins human_proteome toad2human-best toad2human-best.table --format-output "query,target,evalue,raw,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov,theader"
        '''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            self.headLog('Tabulate MMseq2 searches',line='-')
            db = self.db()
            qfields = hfields = fields
            if not fields:
                qfields = 'query,target,evalue,raw,alnlen,pident,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov,theader'
                hfields = 'query,target,evalue,raw,alnlen,pident,qlen,tlen,qstart,qend,qcov,tstart,tend,tcov'
            qrymap = self.getStr('MMQryMap')
            hitmap = self.getStrLC('MMHitMap')
            refdb = self.refMMDB()
            seqdb = self.seqMMDB()
            searchdir = self.getStr('MMSearch')
            rje.mkDir(self,searchdir)
            inbase = '{0}{1}'.format(searchdir,self.basefile())
            ### ~ [2] Run ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            ## ~ [2a] Query vs Hit ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            outfile = '{0}.mmsearch'.format(inbase)
            if tophits == 1: outfile = '{0}.mmsearch-best'.format(inbase)
            elif tophits > 1: outfile = '{0}.mmsearch-top{1}'.format(inbase,tophits)
            if rje.exists(qrymap) and not self.force():
                self.printLog('#MMSEQ','{0} already exists (force=F)'.format(qrymap))
            else:
                mmcmd = 'mmseqs convertalis {0} {1} {2} {3} --format-output "{4}"'.format(seqdb,refdb,outfile,qrymap,qfields)
                self.loggedSysCall(mmcmd)
            if not rje.checkForFile(qrymap):
                raise IOError('File "%s" not generated.' % qrymap)
            if loaddb:
                #qdb = db.addTable(qrymap,mainkeys=['query','target'],expect=True,headers=qfields.split(','),name='qrymap')
                qdb = db.addTable(qrymap,mainkeys=['#'],expect=True,headers=qfields.split(','),name='qrymap')
                qdb.makeField(formula='#query#:#target#',fieldname='hitpair')
                qdb.rankFieldByIndex('hitpair','raw',newfield='alnid',rev=True,absolute=True,unique=True,warn=True)
                qdb.newKey(['query','target','alnid'])
                qdb.dropFields(['#','hitpair'])
                qdb.dataFormat(dbformats)
                pident = qdb.dataList(qdb.entries(),'pident',sortunique=False,empties=False)
                if max(pident) > 1.0:   #!# New mmseq2 with 0-100 pident range
                    for entry in qdb.entries(): entry['pident'] = entry['pident']/100.0
            if not reciprocal: return True
            ## ~ [2b] Reference vs Query ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            outfile = '{0}.invsearch'.format(inbase)
            if tophits == 1: outfile = '{0}.invsearch-best'.format(inbase)
            elif tophits > 1: outfile = '{0}.invsearch-top{1}'.format(inbase,tophits)
            if rje.exists(hitmap) and not self.force():
                self.printLog('#MMSEQ','{0} already exists (force=F)'.format(hitmap))
            else:
                mmcmd = 'mmseqs convertalis {1} {0} {2} {3} --format-output "{4}"'.format(seqdb,refdb,outfile,hitmap,hfields)
                self.loggedSysCall(mmcmd)
            if not rje.checkForFile(hitmap):
                raise IOError('File "%s" not generated.' % hitmap)
            if loaddb:
                #hdb = db.addTable(hitmap,mainkeys=['query','target'],expect=True,headers=hfields.split(','),name='hitmap')
                hdb = db.addTable(hitmap,mainkeys=['#'],expect=True,headers=hfields.split(','),name='hitmap')
                hdb.makeField(formula='#query#:#target#',fieldname='hitpair')
                hdb.rankFieldByIndex('hitpair','raw',newfield='alnid',rev=True,absolute=True,unique=True,warn=True)
                hdb.newKey(['query','target','alnid'])
                hdb.dropFields(['#','hitpair'])
                hdb.dataFormat(dbformats)
                pident = hdb.dataList(hdb.entries(),'pident',sortunique=False,empties=False)
                if max(pident) > 1.0:   #!# New mmseq2 with 0-100 pident range
                    for entry in hdb.entries(): entry['pident'] = entry['pident']/100.0
            return True
        except: self.errorLog('%s.tabulateMMseqSearch error' % self.prog()); raise
#########################################################################################################################
    ### <4> ### Assess Methods                                                                                          #
#########################################################################################################################
    def statistics(self,assess=True,save=True):      ### Checks and creates MMseq2 databases
        '''
        4. Calculate statistics:

        For qry:ref - calculate the qrylen/reflen [ANNOTATION] = calculate the best per gene [ASSEMBLY]
        Median, Mean and 95% CI of ratio?
        Also the F1 score = 2 x Pr x Recall / (Pr + Recall)
            |- Pr = TP / (TP + FP)
            |- Recall = TP / (TP + FN)
        Duplicity = Av. Qry Genes per Ref Gene (with hits)
        Compression = Av. Ref Genes per Qry Gene (with hits)
        Multiplicity = Total no. Qry Genes (Qry vs Ref) / Total no Ref Genes (Ref vs Qry)
        Orthology = % RBH Genes
        Purity = % Qry Genes = summed protcov [Could have cut-off too?]
        Completeness = % Ref Genes (=Recall) = summed
        NOTE: Might be able to short cut a lot of this using mmseq2 output.

        - Calculate F1 score distributions for both Qry and Reference (0 if 100% missing) => median F1?

        #i# Table: proteins
        # - protname
        # - protlen
        # - protdesc
        # - protid = parent mRNA ID from GFF
        # - exons = exon count (CDS feature) from GFF -> Might need to modify for other GFF Types
        # - exonlen = combined length of exons from GFF
        # - geneid = parent gene from GFF
        # - locus = location data parsed from GFF for mRNA
        # - strand
        # - start
        # - end
        # - attributes = mRNA attributes parsed from GFF
        # - bestref (qrymap:target)
        # - protcov (qrymap:qcov)
        # - refcov (qrymap:tcov)
        # - protratio (qrymap:(qlen/tlen))
        # - rbh = Whether it is a reciprocal best hit of a reference protein
        # - f1 = the F1 score = 2 x Pr x Recall / (Pr + Recall)
        #    |- Pr = TP / (TP + FP) = qcov
        #           |- TP = qcov
        #           |- FP = (1 - qcov)
        #    |- Recall = TP / (TP + FN)
        #           | = tcov

        #i# Table: refprot
        # - refprot
        # - reflen
        # - refdesc - read in from fasta?
        # - bestprot (hitmap:target)
        # - protcov (hitmap:tcov)
        # - refcov (hitmap:qcov)
        # - protratio (qrymap:(qlen/tlen))
        # - f1 = 2 * protcov * refcov / (protcov + refcov)
        '''
        try:### ~ [1] Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            #i# NOTE: Assess and Summarise share core query stats - Assess has reference data too
            db = self.db()
            refdb = None
            if assess:
                refdb = self.db('refprot')
                refdb = db.copyTable(refdb,'refstats') # For annnotation
            qrydb = self.db('proteins')
            qrydb = db.copyTable(qrydb,'qrystats') # For annnotation
            ### ~ [2] Calculate ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            stats = {}
            ## ~ [2a] Compress Protein Table to Best Gene Hits ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            qrydb.dropFields(['protdesc'])
            qrydb.addField('bigratio',evalue=0)
            qrydb.dataFormat({'protratio':'float'})
            for entry in qrydb.entries():
                if entry['protratio'] > 1:
                    entry['bigratio'] = 1.0 / entry['protratio']
                    entry['protratio'] = 0
            refhits = qrydb.dataList(qrydb.entries(),'bestref',sortunique=True)
            refhitnum = len(refhits)
            qrydb.addField('isoforms',evalue=1)
            qrydb.compress(['geneid'],default='max',rules={'start':'min','isoforms':'sum'})

            ## ~ [2b] Gene Hits ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            for entry in qrydb.entries():
                if (1.0 - entry['bigratio']) < (1.0 - entry['protratio']):
                    entry['protratio'] = 1.0 / entry['bigratio']
            qrydb.dropFields(['protname','protid','bigratio','strand','start','end','bestref'])
            qrydb.addField('table',evalue='qry')
            qrydb.addField('genes',evalue=1)
            qryhits = db.copyTable(qrydb,'qryhits') # For annnotation
            qryhits.renameField('genes','hom')
            qryhits.dropEntriesDirect('protratio',[0])
            stats['duplicity'] = qryhits.entryNum() / float(refhitnum)
            ratios = qryhits.dataList(qryhits.entries(),'protratio',sortunique=False,empties=False)
            (ratmean,ratsd) = rje.meansd(ratios)
            ratmedian = rje.median(ratios)
            stats['protratio_mean'] = ratmean
            stats['protratio_sd'] = ratsd
            stats['protratio_median'] = ratmedian
            qryhits.compress(['table'],default='mean',rules={'hom':'sum','rbh':'sum'})
            qentry = qryhits.data('qry')
            stats['f1_hits'] = qentry['f1']     # f1_hits is the mean f1 score excluding no-hits
            stats['homology'] = 100.0 * qentry['hom'] / qrydb.entryNum()
            stats['orthology'] = 100.0 * qentry['rbh'] / qrydb.entryNum()

            ## ~ [2c] Gene Total ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            f1dist = qrydb.dataList(qrydb.entries(),'f1',sortunique=False)
            if assess:
                stats['multiplicity'] = float(qrydb.entryNum()) / refdb.entryNum()
            qrydb.compress(['table'],default='mean',rules={'genes':'sum','isoforms':'sum'})
            sentry = qrydb.data('qry')
            for field in ['genes','isoforms','exons','protlen','exonlen']: stats[field] = sentry[field]
            stats['purity'] = sentry['protcov']
            stats['mean_f1'] = sentry['f1']

            ## ~ [2d] Ref hits ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if assess:
                qryhitnum = len(refdb.dataList(refdb.entries(),'bestprot',sortunique=True))
                stats['compression'] = float(qryhitnum) / refdb.entryNum()
                refdb.addField('table',evalue='ref')
                refdb.compress(['table'],default='mean',rules={'genes':'sum','isoforms':'sum'})
                rentry = refdb.data('ref')
                stats['completeness'] = rentry['refcov']

            ## ~ [2e] Final stats ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
                # final stats
                stats['f1'] = (2 * stats['purity'] * stats['completeness']) / (stats['purity'] + stats['completeness'])
                stats['completeness'] = 100.0 * stats['completeness']
            stats['purity'] = 100.0 * stats['purity']

            ### ~ [3] Generate and save stats table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            # Genome, Reference, Genes, Isoforms, Mean exons, Mean exon length, Mean protein length, Completeness, Purity, Homology, Orthology, Mean prot length ratio, Median prot length ratio, SD prot length ratio
            outstats = ['genes','isoforms','exons','exonlen','protlen','completeness','purity','homology','orthology','protratio_mean','protratio_median','protratio_sd']
            # Duplicity = Av. Qry Genes per Ref Gene (with hits)
            # Compression = Av. Ref Genes per Qry Gene (with hits)
            # Multiplicity = Total no. Qry Genes (Qry vs Ref) / Total no Ref Genes (Ref vs Qry)
            outstats += ['duplicity','compression','multiplicity','f1','f1_hits','mean_f1']
            statfields = ['seqin','refdb'] + outstats    #!# Replace with correct order
            stats['seqin'] = rje.stripPath(self.getStr('SeqIn'))
            stats['refdb'] = rje.stripPath(self.getStr('RefProt'))
            if not self.db('stats'):
                for field in statfields[0:]:
                    if field not in stats: statfields.remove(field)
                db.addEmptyTable('stats',statfields,['seqin','refdb'])
            self.db('stats').addEntry(stats)
            if save: self.db('stats').saveToFile()
            return stats
        except: self.errorLog('%s.assess error' % self.prog()); raise
#########################################################################################################################
    ### <5> ### Annotate Methods                                                                                        #
#########################################################################################################################
    def newDesc(self,seqdesc):  ### Returns new name from parsed sequence description based on MAKER rules
        '''
        Returns new name from parsed sequence description based on MAKER rules.
        :param seqdesc:
        :return:
        '''
        try:### ~ [1] Parse ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
            ## ~ [1a] SwissProt with Gene ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if rje.matchExp('(.*?)\s+OS=(.*?)\s+GN=(.*?)\s+PE=',seqdesc):
                (desc,org,name) = rje.matchExp('(.*?)\s+OS=(.*?)\s+GN=(.*?)\s+PE=',seqdesc)
                return 'Similar to {0}: {1} [{2}]'.format(name,desc,org)
            ## ~ [1b] SwissProt without Gene ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if rje.matchExp('(.*?)\s+OS=(.*?)\s+PE=',seqdesc):
                (desc,org) = rje.matchExp('(.*?)\s+OS=(.*?)\s+PE=',seqdesc)
                return 'Similar to {0} ({1})'.format(desc,org)
            ## ~ [1x] Other ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ##
            if seqdesc: return 'Similar to {0}'.format(seqdesc)
            return ''
        except: self.errorLog('%s.newDesc error' % self.prog()); raise
#########################################################################################################################
### End of SECTION II: GeMoMa Class                                                                                     #
#########################################################################################################################

                                                    ### ~ ### ~ ###

#########################################################################################################################
### SECTION III: MODULE METHODS                                                                                         #
#########################################################################################################################

#########################################################################################################################
### END OF SECTION III                                                                                                  #
#########################################################################################################################

                                                    ### ~ ### ~ ###

#########################################################################################################################
### SECTION IV: MAIN PROGRAM                                                                                            #
#########################################################################################################################
def runMain():
    ### ~ [1] ~ Basic Setup of Program  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    try: (info,out,mainlog,cmd_list) = setupProgram()
    except SystemExit: return  
    except: rje.printf('Unexpected error during program setup:', sys.exc_info()[0]); return
    
    ### ~ [2] ~ Rest of Functionality... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    try: GeMoMa(mainlog,cmd_list).run()

    ### ~ [3] ~ End ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ###
    except SystemExit: return  # Fork exit etc.
    except KeyboardInterrupt: mainlog.errorLog('User terminated.')
    except: mainlog.errorLog('Fatal error in main %s run.' % info.program)
    mainlog.endLog(info)
#########################################################################################################################
if __name__ == "__main__":      ### Call runMain 
    try: runMain()
    except: rje.printf('Cataclysmic run error: {0}'.format(sys.exc_info()[0]))
    sys.exit()
#########################################################################################################################
### END OF SECTION IV                                                                                                   #
#########################################################################################################################
